<?php
declare(strict_types=1);
/**
 * FormDataProcessor
 * PHP version 7.4
 *
 * @category Class
 * @package  BhrSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BambooHR API
 *
 * BambooHR API documentation. https://www.bamboohr.com/api/documentation/
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace BhrSdk;

use ArrayAccess;
use DateTime;
use GuzzleHttp\Psr7\Utils;
use Psr\Http\Message\StreamInterface;
use SplFileObject;
use BhrSdk\Model\ModelInterface;

/**
 * FormDataProcessor Class Doc Comment
 *
 * @category Class
 * @package  BhrSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FormDataProcessor {
	/**
	 * Tags whether payload passed to ::prepare() contains one or more
	 * SplFileObject or stream values.
	 */
	public bool $hasFile = false;

	/**
	 * Take value and turn it into an array suitable for inclusion in
	 * the http body (form parameter). If it's a string, pass through unchanged
	 * If it's a datetime object, format it in ISO8601
	 *
	 * @param array<string|bool|int|array|DateTime|ArrayAccess|SplFileObject|null> $values the value of the form parameter
	 *
	 * @return array [key => value] of formdata
	 */
	public function prepare(array $values): array {
		$this->hasFile = false;
		$result = [];

		foreach ($values as $key => $val) {
			if ($val === null) {
				continue;
			}

			$result[$key] = $this->makeFormSafe($val);
		}

		return $result;
	}

	/**
	 * Flattens a multi-level array of data and generates a single-level array
	 * compatible with formdata - a single-level array where the keys use bracket
	 * notation to signify nested data.
	 *
	 * credit: https://github.com/FranBar1966/FlatPHP
	 */
	public static function flatten(array $source, string $start = ''): array {
		$opt = [
			'prefix'          => '[',
			'suffix'          => ']',
			'suffix-end'      => true,
			'prefix-list'     => '[',
			'suffix-list'     => ']',
			'suffix-list-end' => true,
		];

		if ($start === '') {
			$currentPrefix    = '';
			$currentSuffix    = '';
			$currentSuffixEnd = false;
		} elseif (array_is_list($source)) {
			$currentPrefix    = $opt['prefix-list'];
			$currentSuffix    = $opt['suffix-list'];
			$currentSuffixEnd = $opt['suffix-list-end'];
		} else {
			$currentPrefix    = $opt['prefix'];
			$currentSuffix    = $opt['suffix'];
			$currentSuffixEnd = $opt['suffix-end'];
		}

		$currentName = $start;
		$result = [];

		foreach ($source as $key => $val) {
			$currentName .= $currentPrefix . $key;

			if (is_array($val) && !empty($val)) {
				$currentName .= $currentSuffix;
				$result += self::flatten($val, $currentName);
			} else {
				if ($currentSuffixEnd) {
					$currentName .= $currentSuffix;
				}

				if (is_resource($val)) {
					$result[$currentName] = $val;
				} else {
					$result[$currentName] = ObjectSerializer::toString($val);
				}
			}

			$currentName = $start;
		}

		return $result;
	}

	/**
	 * formdata must be limited to scalars or arrays of scalar values,
	 * or a resource for a file upload. Here we iterate through all available
	 * data and identify how to handle each scenario
	 *
	 * @param mixed $value The value to make form safe
	 * @return mixed The form safe value
	 */
	protected function makeFormSafe(mixed $value): mixed {
		if ($value instanceof SplFileObject) {
			return $this->processFiles([$value])[0];
		}

		if (is_resource($value)) {
			$this->hasFile = true;

			return $value;
		}

		if ($value instanceof ModelInterface) {
			return $this->processModel($value);
		}

		if (is_array($value) || (is_object($value) && !$value instanceof \DateTimeInterface && (is_iterable($value) || $value instanceof \Traversable))) {
			$data = [];

			foreach ($value as $key => $val) {
				$data[$key] = $this->makeFormSafe($val);
			}

			return $data;
		}

		return ObjectSerializer::toString($value);
	}

	/**
	 * We are able to handle nested ModelInterface. We do not simply call
	 * json_decode(json_encode()) because any given model may have binary data
	 * or other data that cannot be serialized to a JSON string
	 */
	protected function processModel(ModelInterface $model): array {
		$result = [];

		foreach ($model::openAPITypes() as $name => $type) {
			// Check if model implements ArrayAccess before using offsetGet
			// or use getter method if available
			if ($model instanceof ArrayAccess) {
				$value = $model->offsetGet($name);
			} else {
				// Try to use getter method based on property name
				$getterMethod = 'get' . str_replace(' ', '', ucwords(str_replace('_', ' ', $name)));
				if (method_exists($model, $getterMethod)) {
					$value = $model->$getterMethod();
				} else {
					// Skip properties we can't access
					continue;
				}
			}

			if ($value === null) {
				continue;
			}

			if (strpos($type, '\SplFileObject') !== false) {
				$file = is_array($value) ? $value : [$value];
				$result[$name] = $this->processFiles($file);

				continue;
			}

			if ($value instanceof ModelInterface) {
				$result[$name] = $this->processModel($value);

				continue;
			}

			if (is_array($value) || is_object($value)) {
				$result[$name] = $this->makeFormSafe($value);

				continue;
			}

			$result[$name] = ObjectSerializer::toString($value);
		}

		return $result;
	}

	/**
	 * Handle file data
	 */
	protected function processFiles(array $files): array {
		$this->hasFile = true;

		$result = [];

		foreach ($files as $index => $file) {
			if (is_array($file)) {
				$result[$index] = $this->processFiles($file);

				continue;
			}

			if ($file instanceof StreamInterface) {
				$result[$index] = $file;

				continue;
			}

			if ($file instanceof SplFileObject) {
				$result[$index] = $this->tryFopen($file);
			}
		}

		return $result;
	}

	/**
	 * Try to open a file for reading
	 * 
	 * @param SplFileObject $file The file to open
	 * @return resource The opened file resource
	 */
	private function tryFopen(SplFileObject $file): mixed {
		return Utils::tryFopen($file->getRealPath(), 'rb');
	}
}
