<?php
/**
 * PublicAPIApi
 * PHP version 8.1
 *
 * @category Class
 * @package  BhrSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BambooHR API
 *
 * BambooHR API documentation. https://www.bamboohr.com/api/documentation/
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.15.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace BhrSdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use BhrSdk\ApiException;
use BhrSdk\Configuration;
use BhrSdk\FormDataProcessor;
use BhrSdk\HeaderSelector;
use BhrSdk\ObjectSerializer;

/**
 * PublicAPIApi Class Doc Comment
 *
 * @category Class
 * @package  BhrSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PublicAPIApi {
	/**
	 * @var ClientInterface
	 */
	protected $client;

	/**
	 * @var Configuration
	 */
	protected $config;

	/**
	 * @var HeaderSelector
	 */
	protected $headerSelector;

	/**
	 * @var int Host index
	 */
	protected $hostIndex;

	/** @var string[] $CONTENT_TYPES **/
	public const CONTENT_TYPES = [
		'addCompanyFileCategory' => [
			'application/json',
        ],
		'addEditTimesheetClockEntries' => [
			'application/json',
        ],
		'addEditTimesheetHourEntries' => [
			'application/json',
        ],
		'addEmployee' => [
			'application/json',
        ],
		'addEmployeeDependent' => [
			'application/json',
        ],
		'addEmployeeFileCategory' => [
			'application/json',
        ],
		'addEmployeeTableRow' => [
			'application/json',
        ],
		'addEmployeeTableRowV1' => [
			'application/json',
        ],
		'addNewCandidate' => [
			'multipart/form-data',
        ],
		'addNewEmployeeTrainingRecord' => [
			'application/json',
        ],
		'addNewJobOpening' => [
			'multipart/form-data',
        ],
		'addTimeTrackingBulk' => [
			'application/json',
        ],
		'addTimeTrackingHourRecord' => [
			'application/json',
        ],
		'addTimesheetClockInEntry' => [
			'application/json',
        ],
		'addTimesheetClockOutEntry' => [
			'application/json',
        ],
		'addTrainingCategory' => [
			'application/json',
        ],
		'addTrainingType' => [
			'application/json',
        ],
		'createTimeTrackingProject' => [
			'application/json',
        ],
		'deleteCompanyFile' => [
			'application/json',
        ],
		'deleteEmployeeFile' => [
			'application/json',
        ],
		'deleteEmployeeTableRowV1' => [
			'application/json',
        ],
		'deleteEmployeeTrainingRecord' => [
			'application/json',
        ],
		'deleteGoal' => [
			'application/json',
        ],
		'deleteGoalComment' => [
			'application/json',
        ],
		'deleteTimeTrackingById' => [
			'application/json',
        ],
		'deleteTimesheetClockEntriesViaPost' => [
			'application/json',
        ],
		'deleteTimesheetHourEntriesViaPost' => [
			'application/json',
        ],
		'deleteTrainingCategory' => [
			'application/json',
        ],
		'deleteTrainingType' => [
			'application/json',
        ],
		'deleteWebhook' => [
			'application/json',
        ],
		'editTimeTrackingRecord' => [
			'application/json',
        ],
		'getAListOfWhoIsOut' => [
			'application/json',
        ],
		'getApplicationDetails' => [
			'application/json',
        ],
		'getApplications' => [
			'application/json',
        ],
		'getBenefitCoverages' => [
			'application/json',
        ],
		'getBenefitDeductionTypes' => [
			'application/json',
        ],
		'getByReportId' => [
			'application/json',
        ],
		'getCanCreateGoal' => [
			'application/json',
        ],
		'getChangedEmployeeIds' => [
			'application/json',
        ],
		'getChangedEmployeeTableData' => [
			'application/json',
        ],
		'getCompanyFile' => [
			'application/json',
        ],
		'getCompanyInformation' => [
			'application/json',
        ],
		'getCompanyLocations' => [
			'application/json',
        ],
		'getCompanyReport' => [
			'application/json',
        ],
		'getCountriesOptions' => [
			'application/json',
        ],
		'getDataFromDataset' => [
			'application/json',
        ],
		'getDataSets' => [
			'application/json',
        ],
		'getEmployee' => [
			'application/json',
        ],
		'getEmployeeDependent' => [
			'application/json',
        ],
		'getEmployeeDependents' => [
			'application/json',
        ],
		'getEmployeeFile' => [
			'application/json',
        ],
		'getEmployeePhoto' => [
			'application/json',
        ],
		'getEmployeeTableRow' => [
			'application/json',
        ],
		'getEmployeesDirectory' => [
			'application/json',
        ],
		'getFieldOptions' => [
			'application/json',
        ],
		'getFieldsFromDataset' => [
			'application/json',
        ],
		'getGoalAggregate' => [
			'application/json',
        ],
		'getGoalComments' => [
			'application/json',
        ],
		'getGoals' => [
			'application/json',
        ],
		'getGoalsAggregateV1' => [
			'application/json',
        ],
		'getGoalsAggregateV11' => [
			'application/json',
        ],
		'getGoalsAggregateV12' => [
			'application/json',
        ],
		'getGoalsAlignmentOptions' => [
			'application/json',
        ],
		'getGoalsFiltersV1' => [
			'application/json',
        ],
		'getGoalsFiltersV11' => [
			'application/json',
        ],
		'getGoalsFiltersV12' => [
			'application/json',
        ],
		'getGoalsShareOptions' => [
			'application/json',
        ],
		'getHiringLeads' => [
			'application/json',
        ],
		'getJobSummaries' => [
			'application/json',
        ],
		'getListOfUsers' => [
			'application/json',
        ],
		'getMemberBenefit' => [
			'application/json',
        ],
		'getMonitorFields' => [
			'application/json',
        ],
		'getStatesByCountryId' => [
			'application/json',
        ],
		'getStatuses' => [
			'application/json',
        ],
		'getTimeOffPolicies' => [
			'application/json',
        ],
		'getTimeOffTypes' => [
			'application/json',
        ],
		'getTimeTrackingRecord' => [
			'application/json',
        ],
		'getTimesheetEntries' => [
			'application/json',
        ],
		'getWebhook' => [
			'application/json',
        ],
		'getWebhookList' => [
			'application/json',
        ],
		'getWebhookLogs' => [
			'application/json',
        ],
		'listCompanyFiles' => [
			'application/json',
        ],
		'listEmployeeFiles' => [
			'application/json',
        ],
		'listEmployeeTrainings' => [
			'application/json',
        ],
		'listReports' => [
			'application/json',
        ],
		'listTrainingCategories' => [
			'application/json',
        ],
		'listTrainingTypes' => [
			'application/json',
        ],
		'login' => [
			'application/x-www-form-urlencoded',
        ],
		'metadataAddOrUpdateValuesForListFields' => [
			'application/json',
        ],
		'metadataGetAListOfFields' => [
			'application/json',
        ],
		'metadataGetAListOfTabularFields' => [
			'application/json',
        ],
		'metadataGetDetailsForListFields' => [
			'application/json',
        ],
		'postApplicantStatus' => [
			'application/json',
        ],
		'postApplicationComment' => [
			'application/json',
        ],
		'postCloseGoal' => [
			'application/json',
        ],
		'postGoal' => [
			'application/json',
        ],
		'postGoalComment' => [
			'application/json',
        ],
		'postReopenGoal' => [
			'application/json',
        ],
		'postWebhook' => [
			'application/json',
        ],
		'putGoalComment' => [
			'application/json',
        ],
		'putGoalMilestoneProgress' => [
			'application/json',
        ],
		'putGoalProgress' => [
			'application/json',
        ],
		'putGoalSharedWith' => [
			'application/json',
        ],
		'putGoalV1' => [
			'application/json',
        ],
		'putGoalV11' => [
			'application/json',
        ],
		'putWebhook' => [
			'application/json',
        ],
		'requestCustomReport' => [
			'application/json',
        ],
		'timeOffAddATimeOffHistoryItemForTimeOffRequest' => [
			'application/json',
        ],
		'timeOffAddATimeOffRequest' => [
			'application/json',
        ],
		'timeOffAdjustTimeOffBalance' => [
			'application/json',
        ],
		'timeOffAssignTimeOffPoliciesForAnEmployee' => [
			'application/json',
        ],
		'timeOffAssignTimeOffPoliciesForAnEmployeeV11' => [
			'application/json',
        ],
		'timeOffChangeARequestStatus' => [
			'application/json',
        ],
		'timeOffEstimateFutureTimeOffBalances' => [
			'application/json',
        ],
		'timeOffGetTimeOffRequests' => [
			'application/json',
        ],
		'timeOffListTimeOffPoliciesForEmployee' => [
			'application/json',
        ],
		'timeOffListTimeOffPoliciesForEmployeeV11' => [
			'application/json',
        ],
		'updateCompanyFile' => [
			'application/json',
        ],
		'updateEmployee' => [
			'application/json',
        ],
		'updateEmployeeDependent' => [
			'application/json',
        ],
		'updateEmployeeFile' => [
			'application/json',
        ],
		'updateEmployeeTableRow' => [
			'application/json',
        ],
		'updateEmployeeTableRowV' => [
			'application/json',
        ],
		'updateEmployeeTrainingRecord' => [
			'application/json',
        ],
		'updateTrainingCategory' => [
			'application/json',
        ],
		'updateTrainingType' => [
			'application/json',
        ],
		'uploadCompanyFile' => [
			'application/json',
        ],
		'uploadEmployeeFile' => [
			'application/json',
        ],
		'uploadEmployeePhoto' => [
			'application/json',
        ],
	];

	/**
	 * @param ClientInterface $client
	 * @param Configuration   $config
	 * @param HeaderSelector  $selector
	 * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
	 */
	public function __construct(
		?ClientInterface $client = null,
		?Configuration $config = null,
		?HeaderSelector $selector = null,
		int $hostIndex = 0
	) {
		$this->client = $client ?: new Client();
		$this->config = $config ?: Configuration::getDefaultConfiguration();
		$this->headerSelector = $selector ?: new HeaderSelector();
		$this->hostIndex = $hostIndex;
	}

	/**
	 * Set the host index
	 *
	 * @param int $hostIndex Host index (required)
	 */
	public function setHostIndex($hostIndex): void {
		$this->hostIndex = $hostIndex;
	}

	/**
	 * Get the host index
	 *
	 * @return int Host index
	 */
	public function getHostIndex() {
		return $this->hostIndex;
	}

	/**
	 * @return Configuration
	 */
	public function getConfig() {
		return $this->config;
	}

	/**
	 * Operation addCompanyFileCategory
	 *
	 * Add Company File Category
	 *
	 * @param  string[] $request_body request_body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addCompanyFileCategory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function addCompanyFileCategory($request_body, string $contentType = self::CONTENT_TYPES['addCompanyFileCategory'][0]) {
		$this->addCompanyFileCategoryWithHttpInfo($request_body, $contentType);
	}

	/**
	 * Operation addCompanyFileCategoryWithHttpInfo
	 *
	 * Add Company File Category
	 *
	 * @param  string[] $request_body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addCompanyFileCategory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addCompanyFileCategoryWithHttpInfo($request_body, string $contentType = self::CONTENT_TYPES['addCompanyFileCategory'][0]) {
		$request = $this->addCompanyFileCategoryRequest($request_body, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addCompanyFileCategoryAsync
	 *
	 * Add Company File Category
	 *
	 * @param  string[] $request_body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addCompanyFileCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addCompanyFileCategoryAsync($request_body, string $contentType = self::CONTENT_TYPES['addCompanyFileCategory'][0]) {
		return $this->addCompanyFileCategoryAsyncWithHttpInfo($request_body, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addCompanyFileCategoryAsyncWithHttpInfo
	 *
	 * Add Company File Category
	 *
	 * @param  string[] $request_body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addCompanyFileCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addCompanyFileCategoryAsyncWithHttpInfo($request_body, string $contentType = self::CONTENT_TYPES['addCompanyFileCategory'][0]) {
		$returnType = '';
		$request = $this->addCompanyFileCategoryRequest($request_body, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addCompanyFileCategory'
	 *
	 * @param  string[] $request_body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addCompanyFileCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addCompanyFileCategoryRequest($request_body, string $contentType = self::CONTENT_TYPES['addCompanyFileCategory'][0]) {

		// verify the required parameter 'request_body' is set
		if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $request_body when calling addCompanyFileCategory'
			);
		}


		$resourcePath = '/api/v1/files/categories';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($request_body)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
			} else {
				$httpBody = $request_body;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addEditTimesheetClockEntries
	 *
	 * Add/Edit Timesheet Clock Entries
	 *
	 * @param  \BhrSdk\Model\ClockEntriesSchema|null $clock_entries_schema clock_entries_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEditTimesheetClockEntries'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TimesheetEntryInfoApiTransformer[]|mixed|mixed|mixed|mixed|mixed|mixed
	 */
	public function addEditTimesheetClockEntries($clock_entries_schema = null, string $contentType = self::CONTENT_TYPES['addEditTimesheetClockEntries'][0]) {
		list($response) = $this->addEditTimesheetClockEntriesWithHttpInfo($clock_entries_schema, $contentType);
		return $response;
	}

	/**
	 * Operation addEditTimesheetClockEntriesWithHttpInfo
	 *
	 * Add/Edit Timesheet Clock Entries
	 *
	 * @param  \BhrSdk\Model\ClockEntriesSchema|null $clock_entries_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEditTimesheetClockEntries'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TimesheetEntryInfoApiTransformer[]|mixed|mixed|mixed|mixed|mixed|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addEditTimesheetClockEntriesWithHttpInfo($clock_entries_schema = null, string $contentType = self::CONTENT_TYPES['addEditTimesheetClockEntries'][0]) {
		$request = $this->addEditTimesheetClockEntriesRequest($clock_entries_schema, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TimesheetEntryInfoApiTransformer[]',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 401:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 406:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 409:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TimesheetEntryInfoApiTransformer[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TimesheetEntryInfoApiTransformer[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 401:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 406:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 409:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addEditTimesheetClockEntriesAsync
	 *
	 * Add/Edit Timesheet Clock Entries
	 *
	 * @param  \BhrSdk\Model\ClockEntriesSchema|null $clock_entries_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEditTimesheetClockEntries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEditTimesheetClockEntriesAsync($clock_entries_schema = null, string $contentType = self::CONTENT_TYPES['addEditTimesheetClockEntries'][0]) {
		return $this->addEditTimesheetClockEntriesAsyncWithHttpInfo($clock_entries_schema, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addEditTimesheetClockEntriesAsyncWithHttpInfo
	 *
	 * Add/Edit Timesheet Clock Entries
	 *
	 * @param  \BhrSdk\Model\ClockEntriesSchema|null $clock_entries_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEditTimesheetClockEntries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEditTimesheetClockEntriesAsyncWithHttpInfo($clock_entries_schema = null, string $contentType = self::CONTENT_TYPES['addEditTimesheetClockEntries'][0]) {
		$returnType = '\BhrSdk\Model\TimesheetEntryInfoApiTransformer[]';
		$request = $this->addEditTimesheetClockEntriesRequest($clock_entries_schema, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addEditTimesheetClockEntries'
	 *
	 * @param  \BhrSdk\Model\ClockEntriesSchema|null $clock_entries_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEditTimesheetClockEntries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addEditTimesheetClockEntriesRequest($clock_entries_schema = null, string $contentType = self::CONTENT_TYPES['addEditTimesheetClockEntries'][0]) {



		$resourcePath = '/api/v1/time_tracking/clock_entries/store';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($clock_entries_schema)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($clock_entries_schema));
			} else {
				$httpBody = $clock_entries_schema;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addEditTimesheetHourEntries
	 *
	 * Add/Edit Timesheet Hour Entries
	 *
	 * @param  \BhrSdk\Model\HourEntriesRequestSchema|null $hour_entries_request_schema hour_entries_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEditTimesheetHourEntries'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TimesheetEntryInfoApiTransformer[]|mixed|mixed|mixed|mixed|mixed|mixed
	 */
	public function addEditTimesheetHourEntries($hour_entries_request_schema = null, string $contentType = self::CONTENT_TYPES['addEditTimesheetHourEntries'][0]) {
		list($response) = $this->addEditTimesheetHourEntriesWithHttpInfo($hour_entries_request_schema, $contentType);
		return $response;
	}

	/**
	 * Operation addEditTimesheetHourEntriesWithHttpInfo
	 *
	 * Add/Edit Timesheet Hour Entries
	 *
	 * @param  \BhrSdk\Model\HourEntriesRequestSchema|null $hour_entries_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEditTimesheetHourEntries'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TimesheetEntryInfoApiTransformer[]|mixed|mixed|mixed|mixed|mixed|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addEditTimesheetHourEntriesWithHttpInfo($hour_entries_request_schema = null, string $contentType = self::CONTENT_TYPES['addEditTimesheetHourEntries'][0]) {
		$request = $this->addEditTimesheetHourEntriesRequest($hour_entries_request_schema, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TimesheetEntryInfoApiTransformer[]',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 401:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 406:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 409:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TimesheetEntryInfoApiTransformer[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TimesheetEntryInfoApiTransformer[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 401:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 406:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 409:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addEditTimesheetHourEntriesAsync
	 *
	 * Add/Edit Timesheet Hour Entries
	 *
	 * @param  \BhrSdk\Model\HourEntriesRequestSchema|null $hour_entries_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEditTimesheetHourEntries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEditTimesheetHourEntriesAsync($hour_entries_request_schema = null, string $contentType = self::CONTENT_TYPES['addEditTimesheetHourEntries'][0]) {
		return $this->addEditTimesheetHourEntriesAsyncWithHttpInfo($hour_entries_request_schema, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addEditTimesheetHourEntriesAsyncWithHttpInfo
	 *
	 * Add/Edit Timesheet Hour Entries
	 *
	 * @param  \BhrSdk\Model\HourEntriesRequestSchema|null $hour_entries_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEditTimesheetHourEntries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEditTimesheetHourEntriesAsyncWithHttpInfo($hour_entries_request_schema = null, string $contentType = self::CONTENT_TYPES['addEditTimesheetHourEntries'][0]) {
		$returnType = '\BhrSdk\Model\TimesheetEntryInfoApiTransformer[]';
		$request = $this->addEditTimesheetHourEntriesRequest($hour_entries_request_schema, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addEditTimesheetHourEntries'
	 *
	 * @param  \BhrSdk\Model\HourEntriesRequestSchema|null $hour_entries_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEditTimesheetHourEntries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addEditTimesheetHourEntriesRequest($hour_entries_request_schema = null, string $contentType = self::CONTENT_TYPES['addEditTimesheetHourEntries'][0]) {



		$resourcePath = '/api/v1/time_tracking/hour_entries/store';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($hour_entries_request_schema)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($hour_entries_request_schema));
			} else {
				$httpBody = $hour_entries_request_schema;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addEmployee
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function addEmployee($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		$this->addEmployeeWithHttpInfo($post_new_employee, $contentType);
	}

	/**
	 * Operation addEmployeeWithHttpInfo
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addEmployeeWithHttpInfo($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		$request = $this->addEmployeeRequest($post_new_employee, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addEmployeeAsync
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeAsync($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		return $this->addEmployeeAsyncWithHttpInfo($post_new_employee, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addEmployeeAsyncWithHttpInfo
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeAsyncWithHttpInfo($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		$returnType = '';
		$request = $this->addEmployeeRequest($post_new_employee, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addEmployee'
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addEmployeeRequest($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {

		// verify the required parameter 'post_new_employee' is set
		if ($post_new_employee === null || (is_array($post_new_employee) && count($post_new_employee) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $post_new_employee when calling addEmployee'
			);
		}


		$resourcePath = '/api/v1/employees';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($post_new_employee)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_new_employee));
			} else {
				$httpBody = $post_new_employee;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addEmployeeDependent
	 *
	 * Add an employee dependent
	 *
	 * @param  \BhrSdk\Model\EmployeeDependent $employee_dependent employee_dependent (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function addEmployeeDependent($employee_dependent, string $contentType = self::CONTENT_TYPES['addEmployeeDependent'][0]) {
		$this->addEmployeeDependentWithHttpInfo($employee_dependent, $contentType);
	}

	/**
	 * Operation addEmployeeDependentWithHttpInfo
	 *
	 * Add an employee dependent
	 *
	 * @param  \BhrSdk\Model\EmployeeDependent $employee_dependent (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addEmployeeDependentWithHttpInfo($employee_dependent, string $contentType = self::CONTENT_TYPES['addEmployeeDependent'][0]) {
		$request = $this->addEmployeeDependentRequest($employee_dependent, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addEmployeeDependentAsync
	 *
	 * Add an employee dependent
	 *
	 * @param  \BhrSdk\Model\EmployeeDependent $employee_dependent (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeDependentAsync($employee_dependent, string $contentType = self::CONTENT_TYPES['addEmployeeDependent'][0]) {
		return $this->addEmployeeDependentAsyncWithHttpInfo($employee_dependent, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addEmployeeDependentAsyncWithHttpInfo
	 *
	 * Add an employee dependent
	 *
	 * @param  \BhrSdk\Model\EmployeeDependent $employee_dependent (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeDependentAsyncWithHttpInfo($employee_dependent, string $contentType = self::CONTENT_TYPES['addEmployeeDependent'][0]) {
		$returnType = '';
		$request = $this->addEmployeeDependentRequest($employee_dependent, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addEmployeeDependent'
	 *
	 * @param  \BhrSdk\Model\EmployeeDependent $employee_dependent (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addEmployeeDependentRequest($employee_dependent, string $contentType = self::CONTENT_TYPES['addEmployeeDependent'][0]) {

		// verify the required parameter 'employee_dependent' is set
		if ($employee_dependent === null || (is_array($employee_dependent) && count($employee_dependent) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_dependent when calling addEmployeeDependent'
			);
		}


		$resourcePath = '/api/v1/employeedependents';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($employee_dependent)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($employee_dependent));
			} else {
				$httpBody = $employee_dependent;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addEmployeeFileCategory
	 *
	 * Add Employee File Category
	 *
	 * @param  string[] $request_body request_body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeFileCategory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function addEmployeeFileCategory($request_body, string $contentType = self::CONTENT_TYPES['addEmployeeFileCategory'][0]) {
		$this->addEmployeeFileCategoryWithHttpInfo($request_body, $contentType);
	}

	/**
	 * Operation addEmployeeFileCategoryWithHttpInfo
	 *
	 * Add Employee File Category
	 *
	 * @param  string[] $request_body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeFileCategory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addEmployeeFileCategoryWithHttpInfo($request_body, string $contentType = self::CONTENT_TYPES['addEmployeeFileCategory'][0]) {
		$request = $this->addEmployeeFileCategoryRequest($request_body, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addEmployeeFileCategoryAsync
	 *
	 * Add Employee File Category
	 *
	 * @param  string[] $request_body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeFileCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeFileCategoryAsync($request_body, string $contentType = self::CONTENT_TYPES['addEmployeeFileCategory'][0]) {
		return $this->addEmployeeFileCategoryAsyncWithHttpInfo($request_body, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addEmployeeFileCategoryAsyncWithHttpInfo
	 *
	 * Add Employee File Category
	 *
	 * @param  string[] $request_body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeFileCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeFileCategoryAsyncWithHttpInfo($request_body, string $contentType = self::CONTENT_TYPES['addEmployeeFileCategory'][0]) {
		$returnType = '';
		$request = $this->addEmployeeFileCategoryRequest($request_body, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addEmployeeFileCategory'
	 *
	 * @param  string[] $request_body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeFileCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addEmployeeFileCategoryRequest($request_body, string $contentType = self::CONTENT_TYPES['addEmployeeFileCategory'][0]) {

		// verify the required parameter 'request_body' is set
		if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $request_body when calling addEmployeeFileCategory'
			);
		}


		$resourcePath = '/api/v1/employees/files/categories';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($request_body)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
			} else {
				$httpBody = $request_body;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addEmployeeTableRow
	 *
	 * Adds a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function addEmployeeTableRow($id, $table, $table_row_update, string $contentType = self::CONTENT_TYPES['addEmployeeTableRow'][0]) {
		$this->addEmployeeTableRowWithHttpInfo($id, $table, $table_row_update, $contentType);
	}

	/**
	 * Operation addEmployeeTableRowWithHttpInfo
	 *
	 * Adds a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addEmployeeTableRowWithHttpInfo($id, $table, $table_row_update, string $contentType = self::CONTENT_TYPES['addEmployeeTableRow'][0]) {
		$request = $this->addEmployeeTableRowRequest($id, $table, $table_row_update, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addEmployeeTableRowAsync
	 *
	 * Adds a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeTableRowAsync($id, $table, $table_row_update, string $contentType = self::CONTENT_TYPES['addEmployeeTableRow'][0]) {
		return $this->addEmployeeTableRowAsyncWithHttpInfo($id, $table, $table_row_update, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addEmployeeTableRowAsyncWithHttpInfo
	 *
	 * Adds a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeTableRowAsyncWithHttpInfo($id, $table, $table_row_update, string $contentType = self::CONTENT_TYPES['addEmployeeTableRow'][0]) {
		$returnType = '';
		$request = $this->addEmployeeTableRowRequest($id, $table, $table_row_update, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addEmployeeTableRow'
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addEmployeeTableRowRequest($id, $table, $table_row_update, string $contentType = self::CONTENT_TYPES['addEmployeeTableRow'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling addEmployeeTableRow'
			);
		}

		// verify the required parameter 'table' is set
		if ($table === null || (is_array($table) && count($table) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table when calling addEmployeeTableRow'
			);
		}

		// verify the required parameter 'table_row_update' is set
		if ($table_row_update === null || (is_array($table_row_update) && count($table_row_update) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table_row_update when calling addEmployeeTableRow'
			);
		}


		$resourcePath = '/api/v1/employees/{id}/tables/{table}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}
		// path params
		if ($table !== null) {
			$resourcePath = str_replace(
				'{' . 'table' . '}',
				ObjectSerializer::toPathValue($table),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/xml', 'application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($table_row_update)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($table_row_update));
			} else {
				$httpBody = $table_row_update;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addEmployeeTableRowV1
	 *
	 * Adds a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeTableRowV1'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function addEmployeeTableRowV1($id, $table, $table_row_update, string $contentType = self::CONTENT_TYPES['addEmployeeTableRowV1'][0]) {
		$this->addEmployeeTableRowV1WithHttpInfo($id, $table, $table_row_update, $contentType);
	}

	/**
	 * Operation addEmployeeTableRowV1WithHttpInfo
	 *
	 * Adds a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeTableRowV1'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addEmployeeTableRowV1WithHttpInfo($id, $table, $table_row_update, string $contentType = self::CONTENT_TYPES['addEmployeeTableRowV1'][0]) {
		$request = $this->addEmployeeTableRowV1Request($id, $table, $table_row_update, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addEmployeeTableRowV1Async
	 *
	 * Adds a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeTableRowV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeTableRowV1Async($id, $table, $table_row_update, string $contentType = self::CONTENT_TYPES['addEmployeeTableRowV1'][0]) {
		return $this->addEmployeeTableRowV1AsyncWithHttpInfo($id, $table, $table_row_update, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addEmployeeTableRowV1AsyncWithHttpInfo
	 *
	 * Adds a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeTableRowV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeTableRowV1AsyncWithHttpInfo($id, $table, $table_row_update, string $contentType = self::CONTENT_TYPES['addEmployeeTableRowV1'][0]) {
		$returnType = '';
		$request = $this->addEmployeeTableRowV1Request($id, $table, $table_row_update, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addEmployeeTableRowV1'
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployeeTableRowV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addEmployeeTableRowV1Request($id, $table, $table_row_update, string $contentType = self::CONTENT_TYPES['addEmployeeTableRowV1'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling addEmployeeTableRowV1'
			);
		}

		// verify the required parameter 'table' is set
		if ($table === null || (is_array($table) && count($table) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table when calling addEmployeeTableRowV1'
			);
		}

		// verify the required parameter 'table_row_update' is set
		if ($table_row_update === null || (is_array($table_row_update) && count($table_row_update) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table_row_update when calling addEmployeeTableRowV1'
			);
		}


		$resourcePath = '/api/v1_1/employees/{id}/tables/{table}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}
		// path params
		if ($table !== null) {
			$resourcePath = str_replace(
				'{' . 'table' . '}',
				ObjectSerializer::toPathValue($table),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($table_row_update)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($table_row_update));
			} else {
				$httpBody = $table_row_update;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addNewCandidate
	 *
	 * Add New Candidate
	 *
	 * @param  string $first_name The first name of the candidate. (required)
	 * @param  string $last_name The last name of the candidate. (required)
	 * @param  int $job_id The id of the job opening for the candidate application. (required)
	 * @param  string|null $email The email address of the candidate. (optional)
	 * @param  string|null $phone_number The phone number of the candidate. (optional)
	 * @param  string|null $source The source of the candidate application, e.g. LinkedIn, Indeed, etc. (optional)
	 * @param  string|null $address The street address of the candidate. (optional)
	 * @param  string|null $city The city of the candidate. (optional)
	 * @param  string|null $state The state or province of the candidate. Accepts state name, abbreviation, or ISO code. (optional)
	 * @param  string|null $zip The zip code or postal code of the candidate. (optional)
	 * @param  string|null $country The country of the candidate. Accepts country name or ISO code. (optional)
	 * @param  string|null $linkedin_url The LinkedIn profile url of the candidate. (optional)
	 * @param  string|null $date_available The available start date of the candidate with the format YYYY-MM-DD. (optional)
	 * @param  string|null $desired_salary The desired salary of the candidate. (optional)
	 * @param  string|null $referred_by The person or entity that referred the candidate. (optional)
	 * @param  string|null $website_url The personal website, blog, or online portfolio of the candidate. (optional)
	 * @param  string|null $highest_education The highest completed education level of the candidate. (optional)
	 * @param  string|null $college_name The college or university of the candidate. (optional)
	 * @param  string|null $references A list of references supplied by the candidate. (optional)
	 * @param  string|null $resume Resume of the candidate. (optional)
	 * @param  string|null $cover_letter Cover letter of the candidate. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewCandidate'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function addNewCandidate($first_name, $last_name, $job_id, $email = null, $phone_number = null, $source = null, $address = null, $city = null, $state = null, $zip = null, $country = null, $linkedin_url = null, $date_available = null, $desired_salary = null, $referred_by = null, $website_url = null, $highest_education = null, $college_name = null, $references = null, $resume = null, $cover_letter = null, string $contentType = self::CONTENT_TYPES['addNewCandidate'][0]) {
		$this->addNewCandidateWithHttpInfo($first_name, $last_name, $job_id, $email, $phone_number, $source, $address, $city, $state, $zip, $country, $linkedin_url, $date_available, $desired_salary, $referred_by, $website_url, $highest_education, $college_name, $references, $resume, $cover_letter, $contentType);
	}

	/**
	 * Operation addNewCandidateWithHttpInfo
	 *
	 * Add New Candidate
	 *
	 * @param  string $first_name The first name of the candidate. (required)
	 * @param  string $last_name The last name of the candidate. (required)
	 * @param  int $job_id The id of the job opening for the candidate application. (required)
	 * @param  string|null $email The email address of the candidate. (optional)
	 * @param  string|null $phone_number The phone number of the candidate. (optional)
	 * @param  string|null $source The source of the candidate application, e.g. LinkedIn, Indeed, etc. (optional)
	 * @param  string|null $address The street address of the candidate. (optional)
	 * @param  string|null $city The city of the candidate. (optional)
	 * @param  string|null $state The state or province of the candidate. Accepts state name, abbreviation, or ISO code. (optional)
	 * @param  string|null $zip The zip code or postal code of the candidate. (optional)
	 * @param  string|null $country The country of the candidate. Accepts country name or ISO code. (optional)
	 * @param  string|null $linkedin_url The LinkedIn profile url of the candidate. (optional)
	 * @param  string|null $date_available The available start date of the candidate with the format YYYY-MM-DD. (optional)
	 * @param  string|null $desired_salary The desired salary of the candidate. (optional)
	 * @param  string|null $referred_by The person or entity that referred the candidate. (optional)
	 * @param  string|null $website_url The personal website, blog, or online portfolio of the candidate. (optional)
	 * @param  string|null $highest_education The highest completed education level of the candidate. (optional)
	 * @param  string|null $college_name The college or university of the candidate. (optional)
	 * @param  string|null $references A list of references supplied by the candidate. (optional)
	 * @param  string|null $resume Resume of the candidate. (optional)
	 * @param  string|null $cover_letter Cover letter of the candidate. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewCandidate'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addNewCandidateWithHttpInfo($first_name, $last_name, $job_id, $email = null, $phone_number = null, $source = null, $address = null, $city = null, $state = null, $zip = null, $country = null, $linkedin_url = null, $date_available = null, $desired_salary = null, $referred_by = null, $website_url = null, $highest_education = null, $college_name = null, $references = null, $resume = null, $cover_letter = null, string $contentType = self::CONTENT_TYPES['addNewCandidate'][0]) {
		$request = $this->addNewCandidateRequest($first_name, $last_name, $job_id, $email, $phone_number, $source, $address, $city, $state, $zip, $country, $linkedin_url, $date_available, $desired_salary, $referred_by, $website_url, $highest_education, $college_name, $references, $resume, $cover_letter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addNewCandidateAsync
	 *
	 * Add New Candidate
	 *
	 * @param  string $first_name The first name of the candidate. (required)
	 * @param  string $last_name The last name of the candidate. (required)
	 * @param  int $job_id The id of the job opening for the candidate application. (required)
	 * @param  string|null $email The email address of the candidate. (optional)
	 * @param  string|null $phone_number The phone number of the candidate. (optional)
	 * @param  string|null $source The source of the candidate application, e.g. LinkedIn, Indeed, etc. (optional)
	 * @param  string|null $address The street address of the candidate. (optional)
	 * @param  string|null $city The city of the candidate. (optional)
	 * @param  string|null $state The state or province of the candidate. Accepts state name, abbreviation, or ISO code. (optional)
	 * @param  string|null $zip The zip code or postal code of the candidate. (optional)
	 * @param  string|null $country The country of the candidate. Accepts country name or ISO code. (optional)
	 * @param  string|null $linkedin_url The LinkedIn profile url of the candidate. (optional)
	 * @param  string|null $date_available The available start date of the candidate with the format YYYY-MM-DD. (optional)
	 * @param  string|null $desired_salary The desired salary of the candidate. (optional)
	 * @param  string|null $referred_by The person or entity that referred the candidate. (optional)
	 * @param  string|null $website_url The personal website, blog, or online portfolio of the candidate. (optional)
	 * @param  string|null $highest_education The highest completed education level of the candidate. (optional)
	 * @param  string|null $college_name The college or university of the candidate. (optional)
	 * @param  string|null $references A list of references supplied by the candidate. (optional)
	 * @param  string|null $resume Resume of the candidate. (optional)
	 * @param  string|null $cover_letter Cover letter of the candidate. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewCandidate'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addNewCandidateAsync($first_name, $last_name, $job_id, $email = null, $phone_number = null, $source = null, $address = null, $city = null, $state = null, $zip = null, $country = null, $linkedin_url = null, $date_available = null, $desired_salary = null, $referred_by = null, $website_url = null, $highest_education = null, $college_name = null, $references = null, $resume = null, $cover_letter = null, string $contentType = self::CONTENT_TYPES['addNewCandidate'][0]) {
		return $this->addNewCandidateAsyncWithHttpInfo($first_name, $last_name, $job_id, $email, $phone_number, $source, $address, $city, $state, $zip, $country, $linkedin_url, $date_available, $desired_salary, $referred_by, $website_url, $highest_education, $college_name, $references, $resume, $cover_letter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addNewCandidateAsyncWithHttpInfo
	 *
	 * Add New Candidate
	 *
	 * @param  string $first_name The first name of the candidate. (required)
	 * @param  string $last_name The last name of the candidate. (required)
	 * @param  int $job_id The id of the job opening for the candidate application. (required)
	 * @param  string|null $email The email address of the candidate. (optional)
	 * @param  string|null $phone_number The phone number of the candidate. (optional)
	 * @param  string|null $source The source of the candidate application, e.g. LinkedIn, Indeed, etc. (optional)
	 * @param  string|null $address The street address of the candidate. (optional)
	 * @param  string|null $city The city of the candidate. (optional)
	 * @param  string|null $state The state or province of the candidate. Accepts state name, abbreviation, or ISO code. (optional)
	 * @param  string|null $zip The zip code or postal code of the candidate. (optional)
	 * @param  string|null $country The country of the candidate. Accepts country name or ISO code. (optional)
	 * @param  string|null $linkedin_url The LinkedIn profile url of the candidate. (optional)
	 * @param  string|null $date_available The available start date of the candidate with the format YYYY-MM-DD. (optional)
	 * @param  string|null $desired_salary The desired salary of the candidate. (optional)
	 * @param  string|null $referred_by The person or entity that referred the candidate. (optional)
	 * @param  string|null $website_url The personal website, blog, or online portfolio of the candidate. (optional)
	 * @param  string|null $highest_education The highest completed education level of the candidate. (optional)
	 * @param  string|null $college_name The college or university of the candidate. (optional)
	 * @param  string|null $references A list of references supplied by the candidate. (optional)
	 * @param  string|null $resume Resume of the candidate. (optional)
	 * @param  string|null $cover_letter Cover letter of the candidate. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewCandidate'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addNewCandidateAsyncWithHttpInfo($first_name, $last_name, $job_id, $email = null, $phone_number = null, $source = null, $address = null, $city = null, $state = null, $zip = null, $country = null, $linkedin_url = null, $date_available = null, $desired_salary = null, $referred_by = null, $website_url = null, $highest_education = null, $college_name = null, $references = null, $resume = null, $cover_letter = null, string $contentType = self::CONTENT_TYPES['addNewCandidate'][0]) {
		$returnType = '';
		$request = $this->addNewCandidateRequest($first_name, $last_name, $job_id, $email, $phone_number, $source, $address, $city, $state, $zip, $country, $linkedin_url, $date_available, $desired_salary, $referred_by, $website_url, $highest_education, $college_name, $references, $resume, $cover_letter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addNewCandidate'
	 *
	 * @param  string $first_name The first name of the candidate. (required)
	 * @param  string $last_name The last name of the candidate. (required)
	 * @param  int $job_id The id of the job opening for the candidate application. (required)
	 * @param  string|null $email The email address of the candidate. (optional)
	 * @param  string|null $phone_number The phone number of the candidate. (optional)
	 * @param  string|null $source The source of the candidate application, e.g. LinkedIn, Indeed, etc. (optional)
	 * @param  string|null $address The street address of the candidate. (optional)
	 * @param  string|null $city The city of the candidate. (optional)
	 * @param  string|null $state The state or province of the candidate. Accepts state name, abbreviation, or ISO code. (optional)
	 * @param  string|null $zip The zip code or postal code of the candidate. (optional)
	 * @param  string|null $country The country of the candidate. Accepts country name or ISO code. (optional)
	 * @param  string|null $linkedin_url The LinkedIn profile url of the candidate. (optional)
	 * @param  string|null $date_available The available start date of the candidate with the format YYYY-MM-DD. (optional)
	 * @param  string|null $desired_salary The desired salary of the candidate. (optional)
	 * @param  string|null $referred_by The person or entity that referred the candidate. (optional)
	 * @param  string|null $website_url The personal website, blog, or online portfolio of the candidate. (optional)
	 * @param  string|null $highest_education The highest completed education level of the candidate. (optional)
	 * @param  string|null $college_name The college or university of the candidate. (optional)
	 * @param  string|null $references A list of references supplied by the candidate. (optional)
	 * @param  string|null $resume Resume of the candidate. (optional)
	 * @param  string|null $cover_letter Cover letter of the candidate. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewCandidate'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addNewCandidateRequest($first_name, $last_name, $job_id, $email = null, $phone_number = null, $source = null, $address = null, $city = null, $state = null, $zip = null, $country = null, $linkedin_url = null, $date_available = null, $desired_salary = null, $referred_by = null, $website_url = null, $highest_education = null, $college_name = null, $references = null, $resume = null, $cover_letter = null, string $contentType = self::CONTENT_TYPES['addNewCandidate'][0]) {

		// verify the required parameter 'first_name' is set
		if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $first_name when calling addNewCandidate'
			);
		}

		// verify the required parameter 'last_name' is set
		if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $last_name when calling addNewCandidate'
			);
		}

		// verify the required parameter 'job_id' is set
		if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $job_id when calling addNewCandidate'
			);
		}




















		$resourcePath = '/api/v1/applicant_tracking/application';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;




		// form params
		$formDataProcessor = new FormDataProcessor();

		$formData = $formDataProcessor->prepare([
			'first_name' => $first_name,
			'last_name' => $last_name,
			'email' => $email,
			'phone_number' => $phone_number,
			'source' => $source,
			'job_id' => $job_id,
			'address' => $address,
			'city' => $city,
			'state' => $state,
			'zip' => $zip,
			'country' => $country,
			'linkedin_url' => $linkedin_url,
			'date_available' => $date_available,
			'desired_salary' => $desired_salary,
			'referred_by' => $referred_by,
			'website_url' => $website_url,
			'highest_education' => $highest_education,
			'college_name' => $college_name,
			'references' => $references,
			'resume' => $resume,
			'cover_letter' => $cover_letter,
		]);

		$formParams = $formDataProcessor->flatten($formData);
		$multipart = $formDataProcessor->has_file;

		$multipart = true;
		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addNewEmployeeTrainingRecord
	 *
	 * Add New Employee Training Record
	 *
	 * @param  int $employee_id The ID of the employee to add a training record to. (required)
	 * @param  \BhrSdk\Model\AddNewEmployeeTrainingRecordRequest $add_new_employee_training_record_request Training object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TrainingRecord
	 */
	public function addNewEmployeeTrainingRecord($employee_id, $add_new_employee_training_record_request, string $contentType = self::CONTENT_TYPES['addNewEmployeeTrainingRecord'][0]) {
		list($response) = $this->addNewEmployeeTrainingRecordWithHttpInfo($employee_id, $add_new_employee_training_record_request, $contentType);
		return $response;
	}

	/**
	 * Operation addNewEmployeeTrainingRecordWithHttpInfo
	 *
	 * Add New Employee Training Record
	 *
	 * @param  int $employee_id The ID of the employee to add a training record to. (required)
	 * @param  \BhrSdk\Model\AddNewEmployeeTrainingRecordRequest $add_new_employee_training_record_request Training object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TrainingRecord, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addNewEmployeeTrainingRecordWithHttpInfo($employee_id, $add_new_employee_training_record_request, string $contentType = self::CONTENT_TYPES['addNewEmployeeTrainingRecord'][0]) {
		$request = $this->addNewEmployeeTrainingRecordRequest($employee_id, $add_new_employee_training_record_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TrainingRecord',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TrainingRecord',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TrainingRecord',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addNewEmployeeTrainingRecordAsync
	 *
	 * Add New Employee Training Record
	 *
	 * @param  int $employee_id The ID of the employee to add a training record to. (required)
	 * @param  \BhrSdk\Model\AddNewEmployeeTrainingRecordRequest $add_new_employee_training_record_request Training object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addNewEmployeeTrainingRecordAsync($employee_id, $add_new_employee_training_record_request, string $contentType = self::CONTENT_TYPES['addNewEmployeeTrainingRecord'][0]) {
		return $this->addNewEmployeeTrainingRecordAsyncWithHttpInfo($employee_id, $add_new_employee_training_record_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addNewEmployeeTrainingRecordAsyncWithHttpInfo
	 *
	 * Add New Employee Training Record
	 *
	 * @param  int $employee_id The ID of the employee to add a training record to. (required)
	 * @param  \BhrSdk\Model\AddNewEmployeeTrainingRecordRequest $add_new_employee_training_record_request Training object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addNewEmployeeTrainingRecordAsyncWithHttpInfo($employee_id, $add_new_employee_training_record_request, string $contentType = self::CONTENT_TYPES['addNewEmployeeTrainingRecord'][0]) {
		$returnType = '\BhrSdk\Model\TrainingRecord';
		$request = $this->addNewEmployeeTrainingRecordRequest($employee_id, $add_new_employee_training_record_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addNewEmployeeTrainingRecord'
	 *
	 * @param  int $employee_id The ID of the employee to add a training record to. (required)
	 * @param  \BhrSdk\Model\AddNewEmployeeTrainingRecordRequest $add_new_employee_training_record_request Training object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addNewEmployeeTrainingRecordRequest($employee_id, $add_new_employee_training_record_request, string $contentType = self::CONTENT_TYPES['addNewEmployeeTrainingRecord'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling addNewEmployeeTrainingRecord'
			);
		}

		// verify the required parameter 'add_new_employee_training_record_request' is set
		if ($add_new_employee_training_record_request === null || (is_array($add_new_employee_training_record_request) && count($add_new_employee_training_record_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $add_new_employee_training_record_request when calling addNewEmployeeTrainingRecord'
			);
		}


		$resourcePath = '/api/v1/training/record/employee/{employeeId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($add_new_employee_training_record_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_new_employee_training_record_request));
			} else {
				$httpBody = $add_new_employee_training_record_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addNewJobOpening
	 *
	 * Add New Job Opening
	 *
	 * @param  string $posting_title The posting title of the job opening. (required)
	 * @param  string $job_status The status of the job opening. (required)
	 * @param  int $hiring_lead The employee id (from the v1/applicant_tracking/hiring_leads endpoint) of the hiring lead for the job opening. (required)
	 * @param  string $employment_type The type of employment offered in the job opening, e.g. Full-Time, Part-Time, Contractor, etc. (required)
	 * @param  string $job_description The long-form text description of the job opening. (required)
	 * @param  string|null $department The department of the job opening. (optional)
	 * @param  string|null $minimum_experience The minimum experience level that qualifies a candidate for the job opening. (optional)
	 * @param  string|null $compensation The pay rate or compensation for the job opening. (optional)
	 * @param  int|null $job_location The location id (from the v1/applicant_tracking/locations endpoint) of the job opening. Omit this parameter for a remote job location. (optional)
	 * @param  string|null $application_question_resume Whether the job opening application has a standard question for resume (true) or not (false) or if uploading a resume is mandatory (required). (optional)
	 * @param  string|null $application_question_address Whether the job opening application has a standard question for address (true) or not (false) or if entering an address is mandatory (required). (optional)
	 * @param  string|null $application_question_linkedin_url Whether the job opening application has a standard question for LinkedIn profile url (true) or not (false) or if entering a LinkedIn profile url is mandatory (required). (optional)
	 * @param  string|null $application_question_date_available Whether the job opening application has a standard question for availability date (true) or not (false) or if entering an availability date is mandatory (required). (optional)
	 * @param  string|null $application_question_desired_salary Whether the job opening application has a standard question for desired salary (true) or not (false) or if entering a desired salary is mandatory (required). (optional)
	 * @param  string|null $application_question_cover_letter Whether the job opening application has a standard question for cover letter (true) or not (false) or if uploading a cover letter is mandatory (required). (optional)
	 * @param  string|null $application_question_referred_by Whether the job opening application has a standard question for referred by (true) or not (false) or if entering referred by is mandatory (required). (optional)
	 * @param  string|null $application_question_website_url Whether the job opening application has a standard question for website url (true) or not (false) or if entering a website url is mandatory (required). (optional)
	 * @param  string|null $application_question_highest_education Whether the job opening application has a standard question for highest education (true) or not (false) or if entering highest education is mandatory (required). (optional)
	 * @param  string|null $application_question_college Whether the job opening application has a standard question for college (true) or not (false) or if entering a college is mandatory (required). (optional)
	 * @param  string|null $application_question_references Whether the job opening application has a standard question for references (true) or not (false) or if entering references is mandatory (required). (optional)
	 * @param  string|null $internal_job_code The internal job code for the job opening. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewJobOpening'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function addNewJobOpening($posting_title, $job_status, $hiring_lead, $employment_type, $job_description, $department = null, $minimum_experience = null, $compensation = null, $job_location = null, $application_question_resume = null, $application_question_address = null, $application_question_linkedin_url = null, $application_question_date_available = null, $application_question_desired_salary = null, $application_question_cover_letter = null, $application_question_referred_by = null, $application_question_website_url = null, $application_question_highest_education = null, $application_question_college = null, $application_question_references = null, $internal_job_code = null, string $contentType = self::CONTENT_TYPES['addNewJobOpening'][0]) {
		$this->addNewJobOpeningWithHttpInfo($posting_title, $job_status, $hiring_lead, $employment_type, $job_description, $department, $minimum_experience, $compensation, $job_location, $application_question_resume, $application_question_address, $application_question_linkedin_url, $application_question_date_available, $application_question_desired_salary, $application_question_cover_letter, $application_question_referred_by, $application_question_website_url, $application_question_highest_education, $application_question_college, $application_question_references, $internal_job_code, $contentType);
	}

	/**
	 * Operation addNewJobOpeningWithHttpInfo
	 *
	 * Add New Job Opening
	 *
	 * @param  string $posting_title The posting title of the job opening. (required)
	 * @param  string $job_status The status of the job opening. (required)
	 * @param  int $hiring_lead The employee id (from the v1/applicant_tracking/hiring_leads endpoint) of the hiring lead for the job opening. (required)
	 * @param  string $employment_type The type of employment offered in the job opening, e.g. Full-Time, Part-Time, Contractor, etc. (required)
	 * @param  string $job_description The long-form text description of the job opening. (required)
	 * @param  string|null $department The department of the job opening. (optional)
	 * @param  string|null $minimum_experience The minimum experience level that qualifies a candidate for the job opening. (optional)
	 * @param  string|null $compensation The pay rate or compensation for the job opening. (optional)
	 * @param  int|null $job_location The location id (from the v1/applicant_tracking/locations endpoint) of the job opening. Omit this parameter for a remote job location. (optional)
	 * @param  string|null $application_question_resume Whether the job opening application has a standard question for resume (true) or not (false) or if uploading a resume is mandatory (required). (optional)
	 * @param  string|null $application_question_address Whether the job opening application has a standard question for address (true) or not (false) or if entering an address is mandatory (required). (optional)
	 * @param  string|null $application_question_linkedin_url Whether the job opening application has a standard question for LinkedIn profile url (true) or not (false) or if entering a LinkedIn profile url is mandatory (required). (optional)
	 * @param  string|null $application_question_date_available Whether the job opening application has a standard question for availability date (true) or not (false) or if entering an availability date is mandatory (required). (optional)
	 * @param  string|null $application_question_desired_salary Whether the job opening application has a standard question for desired salary (true) or not (false) or if entering a desired salary is mandatory (required). (optional)
	 * @param  string|null $application_question_cover_letter Whether the job opening application has a standard question for cover letter (true) or not (false) or if uploading a cover letter is mandatory (required). (optional)
	 * @param  string|null $application_question_referred_by Whether the job opening application has a standard question for referred by (true) or not (false) or if entering referred by is mandatory (required). (optional)
	 * @param  string|null $application_question_website_url Whether the job opening application has a standard question for website url (true) or not (false) or if entering a website url is mandatory (required). (optional)
	 * @param  string|null $application_question_highest_education Whether the job opening application has a standard question for highest education (true) or not (false) or if entering highest education is mandatory (required). (optional)
	 * @param  string|null $application_question_college Whether the job opening application has a standard question for college (true) or not (false) or if entering a college is mandatory (required). (optional)
	 * @param  string|null $application_question_references Whether the job opening application has a standard question for references (true) or not (false) or if entering references is mandatory (required). (optional)
	 * @param  string|null $internal_job_code The internal job code for the job opening. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewJobOpening'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addNewJobOpeningWithHttpInfo($posting_title, $job_status, $hiring_lead, $employment_type, $job_description, $department = null, $minimum_experience = null, $compensation = null, $job_location = null, $application_question_resume = null, $application_question_address = null, $application_question_linkedin_url = null, $application_question_date_available = null, $application_question_desired_salary = null, $application_question_cover_letter = null, $application_question_referred_by = null, $application_question_website_url = null, $application_question_highest_education = null, $application_question_college = null, $application_question_references = null, $internal_job_code = null, string $contentType = self::CONTENT_TYPES['addNewJobOpening'][0]) {
		$request = $this->addNewJobOpeningRequest($posting_title, $job_status, $hiring_lead, $employment_type, $job_description, $department, $minimum_experience, $compensation, $job_location, $application_question_resume, $application_question_address, $application_question_linkedin_url, $application_question_date_available, $application_question_desired_salary, $application_question_cover_letter, $application_question_referred_by, $application_question_website_url, $application_question_highest_education, $application_question_college, $application_question_references, $internal_job_code, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addNewJobOpeningAsync
	 *
	 * Add New Job Opening
	 *
	 * @param  string $posting_title The posting title of the job opening. (required)
	 * @param  string $job_status The status of the job opening. (required)
	 * @param  int $hiring_lead The employee id (from the v1/applicant_tracking/hiring_leads endpoint) of the hiring lead for the job opening. (required)
	 * @param  string $employment_type The type of employment offered in the job opening, e.g. Full-Time, Part-Time, Contractor, etc. (required)
	 * @param  string $job_description The long-form text description of the job opening. (required)
	 * @param  string|null $department The department of the job opening. (optional)
	 * @param  string|null $minimum_experience The minimum experience level that qualifies a candidate for the job opening. (optional)
	 * @param  string|null $compensation The pay rate or compensation for the job opening. (optional)
	 * @param  int|null $job_location The location id (from the v1/applicant_tracking/locations endpoint) of the job opening. Omit this parameter for a remote job location. (optional)
	 * @param  string|null $application_question_resume Whether the job opening application has a standard question for resume (true) or not (false) or if uploading a resume is mandatory (required). (optional)
	 * @param  string|null $application_question_address Whether the job opening application has a standard question for address (true) or not (false) or if entering an address is mandatory (required). (optional)
	 * @param  string|null $application_question_linkedin_url Whether the job opening application has a standard question for LinkedIn profile url (true) or not (false) or if entering a LinkedIn profile url is mandatory (required). (optional)
	 * @param  string|null $application_question_date_available Whether the job opening application has a standard question for availability date (true) or not (false) or if entering an availability date is mandatory (required). (optional)
	 * @param  string|null $application_question_desired_salary Whether the job opening application has a standard question for desired salary (true) or not (false) or if entering a desired salary is mandatory (required). (optional)
	 * @param  string|null $application_question_cover_letter Whether the job opening application has a standard question for cover letter (true) or not (false) or if uploading a cover letter is mandatory (required). (optional)
	 * @param  string|null $application_question_referred_by Whether the job opening application has a standard question for referred by (true) or not (false) or if entering referred by is mandatory (required). (optional)
	 * @param  string|null $application_question_website_url Whether the job opening application has a standard question for website url (true) or not (false) or if entering a website url is mandatory (required). (optional)
	 * @param  string|null $application_question_highest_education Whether the job opening application has a standard question for highest education (true) or not (false) or if entering highest education is mandatory (required). (optional)
	 * @param  string|null $application_question_college Whether the job opening application has a standard question for college (true) or not (false) or if entering a college is mandatory (required). (optional)
	 * @param  string|null $application_question_references Whether the job opening application has a standard question for references (true) or not (false) or if entering references is mandatory (required). (optional)
	 * @param  string|null $internal_job_code The internal job code for the job opening. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewJobOpening'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addNewJobOpeningAsync($posting_title, $job_status, $hiring_lead, $employment_type, $job_description, $department = null, $minimum_experience = null, $compensation = null, $job_location = null, $application_question_resume = null, $application_question_address = null, $application_question_linkedin_url = null, $application_question_date_available = null, $application_question_desired_salary = null, $application_question_cover_letter = null, $application_question_referred_by = null, $application_question_website_url = null, $application_question_highest_education = null, $application_question_college = null, $application_question_references = null, $internal_job_code = null, string $contentType = self::CONTENT_TYPES['addNewJobOpening'][0]) {
		return $this->addNewJobOpeningAsyncWithHttpInfo($posting_title, $job_status, $hiring_lead, $employment_type, $job_description, $department, $minimum_experience, $compensation, $job_location, $application_question_resume, $application_question_address, $application_question_linkedin_url, $application_question_date_available, $application_question_desired_salary, $application_question_cover_letter, $application_question_referred_by, $application_question_website_url, $application_question_highest_education, $application_question_college, $application_question_references, $internal_job_code, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addNewJobOpeningAsyncWithHttpInfo
	 *
	 * Add New Job Opening
	 *
	 * @param  string $posting_title The posting title of the job opening. (required)
	 * @param  string $job_status The status of the job opening. (required)
	 * @param  int $hiring_lead The employee id (from the v1/applicant_tracking/hiring_leads endpoint) of the hiring lead for the job opening. (required)
	 * @param  string $employment_type The type of employment offered in the job opening, e.g. Full-Time, Part-Time, Contractor, etc. (required)
	 * @param  string $job_description The long-form text description of the job opening. (required)
	 * @param  string|null $department The department of the job opening. (optional)
	 * @param  string|null $minimum_experience The minimum experience level that qualifies a candidate for the job opening. (optional)
	 * @param  string|null $compensation The pay rate or compensation for the job opening. (optional)
	 * @param  int|null $job_location The location id (from the v1/applicant_tracking/locations endpoint) of the job opening. Omit this parameter for a remote job location. (optional)
	 * @param  string|null $application_question_resume Whether the job opening application has a standard question for resume (true) or not (false) or if uploading a resume is mandatory (required). (optional)
	 * @param  string|null $application_question_address Whether the job opening application has a standard question for address (true) or not (false) or if entering an address is mandatory (required). (optional)
	 * @param  string|null $application_question_linkedin_url Whether the job opening application has a standard question for LinkedIn profile url (true) or not (false) or if entering a LinkedIn profile url is mandatory (required). (optional)
	 * @param  string|null $application_question_date_available Whether the job opening application has a standard question for availability date (true) or not (false) or if entering an availability date is mandatory (required). (optional)
	 * @param  string|null $application_question_desired_salary Whether the job opening application has a standard question for desired salary (true) or not (false) or if entering a desired salary is mandatory (required). (optional)
	 * @param  string|null $application_question_cover_letter Whether the job opening application has a standard question for cover letter (true) or not (false) or if uploading a cover letter is mandatory (required). (optional)
	 * @param  string|null $application_question_referred_by Whether the job opening application has a standard question for referred by (true) or not (false) or if entering referred by is mandatory (required). (optional)
	 * @param  string|null $application_question_website_url Whether the job opening application has a standard question for website url (true) or not (false) or if entering a website url is mandatory (required). (optional)
	 * @param  string|null $application_question_highest_education Whether the job opening application has a standard question for highest education (true) or not (false) or if entering highest education is mandatory (required). (optional)
	 * @param  string|null $application_question_college Whether the job opening application has a standard question for college (true) or not (false) or if entering a college is mandatory (required). (optional)
	 * @param  string|null $application_question_references Whether the job opening application has a standard question for references (true) or not (false) or if entering references is mandatory (required). (optional)
	 * @param  string|null $internal_job_code The internal job code for the job opening. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewJobOpening'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addNewJobOpeningAsyncWithHttpInfo($posting_title, $job_status, $hiring_lead, $employment_type, $job_description, $department = null, $minimum_experience = null, $compensation = null, $job_location = null, $application_question_resume = null, $application_question_address = null, $application_question_linkedin_url = null, $application_question_date_available = null, $application_question_desired_salary = null, $application_question_cover_letter = null, $application_question_referred_by = null, $application_question_website_url = null, $application_question_highest_education = null, $application_question_college = null, $application_question_references = null, $internal_job_code = null, string $contentType = self::CONTENT_TYPES['addNewJobOpening'][0]) {
		$returnType = '';
		$request = $this->addNewJobOpeningRequest($posting_title, $job_status, $hiring_lead, $employment_type, $job_description, $department, $minimum_experience, $compensation, $job_location, $application_question_resume, $application_question_address, $application_question_linkedin_url, $application_question_date_available, $application_question_desired_salary, $application_question_cover_letter, $application_question_referred_by, $application_question_website_url, $application_question_highest_education, $application_question_college, $application_question_references, $internal_job_code, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addNewJobOpening'
	 *
	 * @param  string $posting_title The posting title of the job opening. (required)
	 * @param  string $job_status The status of the job opening. (required)
	 * @param  int $hiring_lead The employee id (from the v1/applicant_tracking/hiring_leads endpoint) of the hiring lead for the job opening. (required)
	 * @param  string $employment_type The type of employment offered in the job opening, e.g. Full-Time, Part-Time, Contractor, etc. (required)
	 * @param  string $job_description The long-form text description of the job opening. (required)
	 * @param  string|null $department The department of the job opening. (optional)
	 * @param  string|null $minimum_experience The minimum experience level that qualifies a candidate for the job opening. (optional)
	 * @param  string|null $compensation The pay rate or compensation for the job opening. (optional)
	 * @param  int|null $job_location The location id (from the v1/applicant_tracking/locations endpoint) of the job opening. Omit this parameter for a remote job location. (optional)
	 * @param  string|null $application_question_resume Whether the job opening application has a standard question for resume (true) or not (false) or if uploading a resume is mandatory (required). (optional)
	 * @param  string|null $application_question_address Whether the job opening application has a standard question for address (true) or not (false) or if entering an address is mandatory (required). (optional)
	 * @param  string|null $application_question_linkedin_url Whether the job opening application has a standard question for LinkedIn profile url (true) or not (false) or if entering a LinkedIn profile url is mandatory (required). (optional)
	 * @param  string|null $application_question_date_available Whether the job opening application has a standard question for availability date (true) or not (false) or if entering an availability date is mandatory (required). (optional)
	 * @param  string|null $application_question_desired_salary Whether the job opening application has a standard question for desired salary (true) or not (false) or if entering a desired salary is mandatory (required). (optional)
	 * @param  string|null $application_question_cover_letter Whether the job opening application has a standard question for cover letter (true) or not (false) or if uploading a cover letter is mandatory (required). (optional)
	 * @param  string|null $application_question_referred_by Whether the job opening application has a standard question for referred by (true) or not (false) or if entering referred by is mandatory (required). (optional)
	 * @param  string|null $application_question_website_url Whether the job opening application has a standard question for website url (true) or not (false) or if entering a website url is mandatory (required). (optional)
	 * @param  string|null $application_question_highest_education Whether the job opening application has a standard question for highest education (true) or not (false) or if entering highest education is mandatory (required). (optional)
	 * @param  string|null $application_question_college Whether the job opening application has a standard question for college (true) or not (false) or if entering a college is mandatory (required). (optional)
	 * @param  string|null $application_question_references Whether the job opening application has a standard question for references (true) or not (false) or if entering references is mandatory (required). (optional)
	 * @param  string|null $internal_job_code The internal job code for the job opening. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addNewJobOpening'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addNewJobOpeningRequest($posting_title, $job_status, $hiring_lead, $employment_type, $job_description, $department = null, $minimum_experience = null, $compensation = null, $job_location = null, $application_question_resume = null, $application_question_address = null, $application_question_linkedin_url = null, $application_question_date_available = null, $application_question_desired_salary = null, $application_question_cover_letter = null, $application_question_referred_by = null, $application_question_website_url = null, $application_question_highest_education = null, $application_question_college = null, $application_question_references = null, $internal_job_code = null, string $contentType = self::CONTENT_TYPES['addNewJobOpening'][0]) {

		// verify the required parameter 'posting_title' is set
		if ($posting_title === null || (is_array($posting_title) && count($posting_title) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $posting_title when calling addNewJobOpening'
			);
		}

		// verify the required parameter 'job_status' is set
		if ($job_status === null || (is_array($job_status) && count($job_status) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $job_status when calling addNewJobOpening'
			);
		}

		// verify the required parameter 'hiring_lead' is set
		if ($hiring_lead === null || (is_array($hiring_lead) && count($hiring_lead) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $hiring_lead when calling addNewJobOpening'
			);
		}

		// verify the required parameter 'employment_type' is set
		if ($employment_type === null || (is_array($employment_type) && count($employment_type) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employment_type when calling addNewJobOpening'
			);
		}

		// verify the required parameter 'job_description' is set
		if ($job_description === null || (is_array($job_description) && count($job_description) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $job_description when calling addNewJobOpening'
			);
		}


















		$resourcePath = '/api/v1/applicant_tracking/job_opening';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;




		// form params
		$formDataProcessor = new FormDataProcessor();

		$formData = $formDataProcessor->prepare([
			'posting_title' => $posting_title,
			'job_status' => $job_status,
			'hiring_lead' => $hiring_lead,
			'department' => $department,
			'employment_type' => $employment_type,
			'minimum_experience' => $minimum_experience,
			'compensation' => $compensation,
			'job_location' => $job_location,
			'job_description' => $job_description,
			'application_question_resume' => $application_question_resume,
			'application_question_address' => $application_question_address,
			'application_question_linkedin_url' => $application_question_linkedin_url,
			'application_question_date_available' => $application_question_date_available,
			'application_question_desired_salary' => $application_question_desired_salary,
			'application_question_cover_letter' => $application_question_cover_letter,
			'application_question_referred_by' => $application_question_referred_by,
			'application_question_website_url' => $application_question_website_url,
			'application_question_highest_education' => $application_question_highest_education,
			'application_question_college' => $application_question_college,
			'application_question_references' => $application_question_references,
			'internal_job_code' => $internal_job_code,
		]);

		$formParams = $formDataProcessor->flatten($formData);
		$multipart = $formDataProcessor->has_file;

		$multipart = true;
		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addTimeTrackingBulk
	 *
	 * Add/Edit Hour Records
	 *
	 * @param  \BhrSdk\Model\TimeTrackingRecord[] $time_tracking_record time_tracking_record (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimeTrackingBulk'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TimeTrackingBulkResponseSchema
	 */
	public function addTimeTrackingBulk($time_tracking_record, string $contentType = self::CONTENT_TYPES['addTimeTrackingBulk'][0]) {
		list($response) = $this->addTimeTrackingBulkWithHttpInfo($time_tracking_record, $contentType);
		return $response;
	}

	/**
	 * Operation addTimeTrackingBulkWithHttpInfo
	 *
	 * Add/Edit Hour Records
	 *
	 * @param  \BhrSdk\Model\TimeTrackingRecord[] $time_tracking_record (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimeTrackingBulk'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TimeTrackingBulkResponseSchema, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addTimeTrackingBulkWithHttpInfo($time_tracking_record, string $contentType = self::CONTENT_TYPES['addTimeTrackingBulk'][0]) {
		$request = $this->addTimeTrackingBulkRequest($time_tracking_record, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TimeTrackingBulkResponseSchema',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TimeTrackingBulkResponseSchema',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TimeTrackingBulkResponseSchema',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addTimeTrackingBulkAsync
	 *
	 * Add/Edit Hour Records
	 *
	 * @param  \BhrSdk\Model\TimeTrackingRecord[] $time_tracking_record (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimeTrackingBulk'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTimeTrackingBulkAsync($time_tracking_record, string $contentType = self::CONTENT_TYPES['addTimeTrackingBulk'][0]) {
		return $this->addTimeTrackingBulkAsyncWithHttpInfo($time_tracking_record, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addTimeTrackingBulkAsyncWithHttpInfo
	 *
	 * Add/Edit Hour Records
	 *
	 * @param  \BhrSdk\Model\TimeTrackingRecord[] $time_tracking_record (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimeTrackingBulk'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTimeTrackingBulkAsyncWithHttpInfo($time_tracking_record, string $contentType = self::CONTENT_TYPES['addTimeTrackingBulk'][0]) {
		$returnType = '\BhrSdk\Model\TimeTrackingBulkResponseSchema';
		$request = $this->addTimeTrackingBulkRequest($time_tracking_record, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addTimeTrackingBulk'
	 *
	 * @param  \BhrSdk\Model\TimeTrackingRecord[] $time_tracking_record (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimeTrackingBulk'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addTimeTrackingBulkRequest($time_tracking_record, string $contentType = self::CONTENT_TYPES['addTimeTrackingBulk'][0]) {

		// verify the required parameter 'time_tracking_record' is set
		if ($time_tracking_record === null || (is_array($time_tracking_record) && count($time_tracking_record) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $time_tracking_record when calling addTimeTrackingBulk'
			);
		}


		$resourcePath = '/api/v1/timetracking/record';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($time_tracking_record)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($time_tracking_record));
			} else {
				$httpBody = $time_tracking_record;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addTimeTrackingHourRecord
	 *
	 * Add Hour Record
	 *
	 * @param  \BhrSdk\Model\TimeTrackingRecord $time_tracking_record time_tracking_record (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimeTrackingHourRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TimeTrackingIdResponseSchema|mixed
	 */
	public function addTimeTrackingHourRecord($time_tracking_record, string $contentType = self::CONTENT_TYPES['addTimeTrackingHourRecord'][0]) {
		list($response) = $this->addTimeTrackingHourRecordWithHttpInfo($time_tracking_record, $contentType);
		return $response;
	}

	/**
	 * Operation addTimeTrackingHourRecordWithHttpInfo
	 *
	 * Add Hour Record
	 *
	 * @param  \BhrSdk\Model\TimeTrackingRecord $time_tracking_record (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimeTrackingHourRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TimeTrackingIdResponseSchema|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addTimeTrackingHourRecordWithHttpInfo($time_tracking_record, string $contentType = self::CONTENT_TYPES['addTimeTrackingHourRecord'][0]) {
		$request = $this->addTimeTrackingHourRecordRequest($time_tracking_record, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TimeTrackingIdResponseSchema',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TimeTrackingIdResponseSchema',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TimeTrackingIdResponseSchema',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addTimeTrackingHourRecordAsync
	 *
	 * Add Hour Record
	 *
	 * @param  \BhrSdk\Model\TimeTrackingRecord $time_tracking_record (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimeTrackingHourRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTimeTrackingHourRecordAsync($time_tracking_record, string $contentType = self::CONTENT_TYPES['addTimeTrackingHourRecord'][0]) {
		return $this->addTimeTrackingHourRecordAsyncWithHttpInfo($time_tracking_record, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addTimeTrackingHourRecordAsyncWithHttpInfo
	 *
	 * Add Hour Record
	 *
	 * @param  \BhrSdk\Model\TimeTrackingRecord $time_tracking_record (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimeTrackingHourRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTimeTrackingHourRecordAsyncWithHttpInfo($time_tracking_record, string $contentType = self::CONTENT_TYPES['addTimeTrackingHourRecord'][0]) {
		$returnType = '\BhrSdk\Model\TimeTrackingIdResponseSchema';
		$request = $this->addTimeTrackingHourRecordRequest($time_tracking_record, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addTimeTrackingHourRecord'
	 *
	 * @param  \BhrSdk\Model\TimeTrackingRecord $time_tracking_record (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimeTrackingHourRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addTimeTrackingHourRecordRequest($time_tracking_record, string $contentType = self::CONTENT_TYPES['addTimeTrackingHourRecord'][0]) {

		// verify the required parameter 'time_tracking_record' is set
		if ($time_tracking_record === null || (is_array($time_tracking_record) && count($time_tracking_record) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $time_tracking_record when calling addTimeTrackingHourRecord'
			);
		}


		$resourcePath = '/api/v1/timetracking/add';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($time_tracking_record)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($time_tracking_record));
			} else {
				$httpBody = $time_tracking_record;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addTimesheetClockInEntry
	 *
	 * Add Timesheet Clock-In Entry
	 *
	 * @param  int $employee_id ID of the employee to clock in. (required)
	 * @param  \BhrSdk\Model\ClockInRequestSchema|null $clock_in_request_schema clock_in_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimesheetClockInEntry'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TimesheetEntryInfoApiTransformer|mixed|mixed|mixed|mixed|mixed
	 */
	public function addTimesheetClockInEntry($employee_id, $clock_in_request_schema = null, string $contentType = self::CONTENT_TYPES['addTimesheetClockInEntry'][0]) {
		list($response) = $this->addTimesheetClockInEntryWithHttpInfo($employee_id, $clock_in_request_schema, $contentType);
		return $response;
	}

	/**
	 * Operation addTimesheetClockInEntryWithHttpInfo
	 *
	 * Add Timesheet Clock-In Entry
	 *
	 * @param  int $employee_id ID of the employee to clock in. (required)
	 * @param  \BhrSdk\Model\ClockInRequestSchema|null $clock_in_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimesheetClockInEntry'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TimesheetEntryInfoApiTransformer|mixed|mixed|mixed|mixed|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addTimesheetClockInEntryWithHttpInfo($employee_id, $clock_in_request_schema = null, string $contentType = self::CONTENT_TYPES['addTimesheetClockInEntry'][0]) {
		$request = $this->addTimesheetClockInEntryRequest($employee_id, $clock_in_request_schema, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TimesheetEntryInfoApiTransformer',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 401:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 406:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 409:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TimesheetEntryInfoApiTransformer',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TimesheetEntryInfoApiTransformer',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 401:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 406:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 409:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addTimesheetClockInEntryAsync
	 *
	 * Add Timesheet Clock-In Entry
	 *
	 * @param  int $employee_id ID of the employee to clock in. (required)
	 * @param  \BhrSdk\Model\ClockInRequestSchema|null $clock_in_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimesheetClockInEntry'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTimesheetClockInEntryAsync($employee_id, $clock_in_request_schema = null, string $contentType = self::CONTENT_TYPES['addTimesheetClockInEntry'][0]) {
		return $this->addTimesheetClockInEntryAsyncWithHttpInfo($employee_id, $clock_in_request_schema, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addTimesheetClockInEntryAsyncWithHttpInfo
	 *
	 * Add Timesheet Clock-In Entry
	 *
	 * @param  int $employee_id ID of the employee to clock in. (required)
	 * @param  \BhrSdk\Model\ClockInRequestSchema|null $clock_in_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimesheetClockInEntry'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTimesheetClockInEntryAsyncWithHttpInfo($employee_id, $clock_in_request_schema = null, string $contentType = self::CONTENT_TYPES['addTimesheetClockInEntry'][0]) {
		$returnType = '\BhrSdk\Model\TimesheetEntryInfoApiTransformer';
		$request = $this->addTimesheetClockInEntryRequest($employee_id, $clock_in_request_schema, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addTimesheetClockInEntry'
	 *
	 * @param  int $employee_id ID of the employee to clock in. (required)
	 * @param  \BhrSdk\Model\ClockInRequestSchema|null $clock_in_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimesheetClockInEntry'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addTimesheetClockInEntryRequest($employee_id, $clock_in_request_schema = null, string $contentType = self::CONTENT_TYPES['addTimesheetClockInEntry'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling addTimesheetClockInEntry'
			);
		}



		$resourcePath = '/api/v1/time_tracking/employees/{employeeId}/clock_in';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($clock_in_request_schema)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($clock_in_request_schema));
			} else {
				$httpBody = $clock_in_request_schema;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addTimesheetClockOutEntry
	 *
	 * Add Timesheet Clock-Out Entry
	 *
	 * @param  int $employee_id ID of the employee to clock out. (required)
	 * @param  \BhrSdk\Model\ClockOutRequestSchema|null $clock_out_request_schema clock_out_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimesheetClockOutEntry'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TimesheetEntryInfoApiTransformer|mixed|mixed|mixed|mixed|mixed|mixed
	 */
	public function addTimesheetClockOutEntry($employee_id, $clock_out_request_schema = null, string $contentType = self::CONTENT_TYPES['addTimesheetClockOutEntry'][0]) {
		list($response) = $this->addTimesheetClockOutEntryWithHttpInfo($employee_id, $clock_out_request_schema, $contentType);
		return $response;
	}

	/**
	 * Operation addTimesheetClockOutEntryWithHttpInfo
	 *
	 * Add Timesheet Clock-Out Entry
	 *
	 * @param  int $employee_id ID of the employee to clock out. (required)
	 * @param  \BhrSdk\Model\ClockOutRequestSchema|null $clock_out_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimesheetClockOutEntry'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TimesheetEntryInfoApiTransformer|mixed|mixed|mixed|mixed|mixed|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addTimesheetClockOutEntryWithHttpInfo($employee_id, $clock_out_request_schema = null, string $contentType = self::CONTENT_TYPES['addTimesheetClockOutEntry'][0]) {
		$request = $this->addTimesheetClockOutEntryRequest($employee_id, $clock_out_request_schema, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TimesheetEntryInfoApiTransformer',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 401:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 406:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 409:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TimesheetEntryInfoApiTransformer',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TimesheetEntryInfoApiTransformer',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 401:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 406:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 409:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addTimesheetClockOutEntryAsync
	 *
	 * Add Timesheet Clock-Out Entry
	 *
	 * @param  int $employee_id ID of the employee to clock out. (required)
	 * @param  \BhrSdk\Model\ClockOutRequestSchema|null $clock_out_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimesheetClockOutEntry'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTimesheetClockOutEntryAsync($employee_id, $clock_out_request_schema = null, string $contentType = self::CONTENT_TYPES['addTimesheetClockOutEntry'][0]) {
		return $this->addTimesheetClockOutEntryAsyncWithHttpInfo($employee_id, $clock_out_request_schema, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addTimesheetClockOutEntryAsyncWithHttpInfo
	 *
	 * Add Timesheet Clock-Out Entry
	 *
	 * @param  int $employee_id ID of the employee to clock out. (required)
	 * @param  \BhrSdk\Model\ClockOutRequestSchema|null $clock_out_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimesheetClockOutEntry'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTimesheetClockOutEntryAsyncWithHttpInfo($employee_id, $clock_out_request_schema = null, string $contentType = self::CONTENT_TYPES['addTimesheetClockOutEntry'][0]) {
		$returnType = '\BhrSdk\Model\TimesheetEntryInfoApiTransformer';
		$request = $this->addTimesheetClockOutEntryRequest($employee_id, $clock_out_request_schema, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addTimesheetClockOutEntry'
	 *
	 * @param  int $employee_id ID of the employee to clock out. (required)
	 * @param  \BhrSdk\Model\ClockOutRequestSchema|null $clock_out_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTimesheetClockOutEntry'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addTimesheetClockOutEntryRequest($employee_id, $clock_out_request_schema = null, string $contentType = self::CONTENT_TYPES['addTimesheetClockOutEntry'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling addTimesheetClockOutEntry'
			);
		}



		$resourcePath = '/api/v1/time_tracking/employees/{employeeId}/clock_out';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($clock_out_request_schema)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($clock_out_request_schema));
			} else {
				$httpBody = $clock_out_request_schema;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addTrainingCategory
	 *
	 * Add Training Category
	 *
	 * @param  \BhrSdk\Model\AddTrainingCategoryRequest $add_training_category_request Training category to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TrainingCategory
	 */
	public function addTrainingCategory($add_training_category_request, string $contentType = self::CONTENT_TYPES['addTrainingCategory'][0]) {
		list($response) = $this->addTrainingCategoryWithHttpInfo($add_training_category_request, $contentType);
		return $response;
	}

	/**
	 * Operation addTrainingCategoryWithHttpInfo
	 *
	 * Add Training Category
	 *
	 * @param  \BhrSdk\Model\AddTrainingCategoryRequest $add_training_category_request Training category to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TrainingCategory, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addTrainingCategoryWithHttpInfo($add_training_category_request, string $contentType = self::CONTENT_TYPES['addTrainingCategory'][0]) {
		$request = $this->addTrainingCategoryRequest($add_training_category_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TrainingCategory',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TrainingCategory',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TrainingCategory',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addTrainingCategoryAsync
	 *
	 * Add Training Category
	 *
	 * @param  \BhrSdk\Model\AddTrainingCategoryRequest $add_training_category_request Training category to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTrainingCategoryAsync($add_training_category_request, string $contentType = self::CONTENT_TYPES['addTrainingCategory'][0]) {
		return $this->addTrainingCategoryAsyncWithHttpInfo($add_training_category_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addTrainingCategoryAsyncWithHttpInfo
	 *
	 * Add Training Category
	 *
	 * @param  \BhrSdk\Model\AddTrainingCategoryRequest $add_training_category_request Training category to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTrainingCategoryAsyncWithHttpInfo($add_training_category_request, string $contentType = self::CONTENT_TYPES['addTrainingCategory'][0]) {
		$returnType = '\BhrSdk\Model\TrainingCategory';
		$request = $this->addTrainingCategoryRequest($add_training_category_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addTrainingCategory'
	 *
	 * @param  \BhrSdk\Model\AddTrainingCategoryRequest $add_training_category_request Training category to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addTrainingCategoryRequest($add_training_category_request, string $contentType = self::CONTENT_TYPES['addTrainingCategory'][0]) {

		// verify the required parameter 'add_training_category_request' is set
		if ($add_training_category_request === null || (is_array($add_training_category_request) && count($add_training_category_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $add_training_category_request when calling addTrainingCategory'
			);
		}


		$resourcePath = '/api/v1/training/category';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($add_training_category_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_training_category_request));
			} else {
				$httpBody = $add_training_category_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation addTrainingType
	 *
	 * Add Training Type
	 *
	 * @param  \BhrSdk\Model\AddTrainingTypeRequest $add_training_type_request Training object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTrainingType'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TrainingType
	 */
	public function addTrainingType($add_training_type_request, string $contentType = self::CONTENT_TYPES['addTrainingType'][0]) {
		list($response) = $this->addTrainingTypeWithHttpInfo($add_training_type_request, $contentType);
		return $response;
	}

	/**
	 * Operation addTrainingTypeWithHttpInfo
	 *
	 * Add Training Type
	 *
	 * @param  \BhrSdk\Model\AddTrainingTypeRequest $add_training_type_request Training object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTrainingType'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TrainingType, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addTrainingTypeWithHttpInfo($add_training_type_request, string $contentType = self::CONTENT_TYPES['addTrainingType'][0]) {
		$request = $this->addTrainingTypeRequest($add_training_type_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TrainingType',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TrainingType',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TrainingType',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation addTrainingTypeAsync
	 *
	 * Add Training Type
	 *
	 * @param  \BhrSdk\Model\AddTrainingTypeRequest $add_training_type_request Training object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTrainingType'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTrainingTypeAsync($add_training_type_request, string $contentType = self::CONTENT_TYPES['addTrainingType'][0]) {
		return $this->addTrainingTypeAsyncWithHttpInfo($add_training_type_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addTrainingTypeAsyncWithHttpInfo
	 *
	 * Add Training Type
	 *
	 * @param  \BhrSdk\Model\AddTrainingTypeRequest $add_training_type_request Training object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTrainingType'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addTrainingTypeAsyncWithHttpInfo($add_training_type_request, string $contentType = self::CONTENT_TYPES['addTrainingType'][0]) {
		$returnType = '\BhrSdk\Model\TrainingType';
		$request = $this->addTrainingTypeRequest($add_training_type_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addTrainingType'
	 *
	 * @param  \BhrSdk\Model\AddTrainingTypeRequest $add_training_type_request Training object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addTrainingType'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addTrainingTypeRequest($add_training_type_request, string $contentType = self::CONTENT_TYPES['addTrainingType'][0]) {

		// verify the required parameter 'add_training_type_request' is set
		if ($add_training_type_request === null || (is_array($add_training_type_request) && count($add_training_type_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $add_training_type_request when calling addTrainingType'
			);
		}


		$resourcePath = '/api/v1/training/type';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($add_training_type_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_training_type_request));
			} else {
				$httpBody = $add_training_type_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation createTimeTrackingProject
	 *
	 * Create Time Tracking Project
	 *
	 * @param  \BhrSdk\Model\ProjectCreateRequestSchema|null $project_create_request_schema project_create_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['createTimeTrackingProject'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TimeTrackingProjectWithTasksAndEmployeeIds
	 */
	public function createTimeTrackingProject($project_create_request_schema = null, string $contentType = self::CONTENT_TYPES['createTimeTrackingProject'][0]) {
		list($response) = $this->createTimeTrackingProjectWithHttpInfo($project_create_request_schema, $contentType);
		return $response;
	}

	/**
	 * Operation createTimeTrackingProjectWithHttpInfo
	 *
	 * Create Time Tracking Project
	 *
	 * @param  \BhrSdk\Model\ProjectCreateRequestSchema|null $project_create_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['createTimeTrackingProject'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TimeTrackingProjectWithTasksAndEmployeeIds, HTTP status code, HTTP response headers (array of strings)
	 */
	public function createTimeTrackingProjectWithHttpInfo($project_create_request_schema = null, string $contentType = self::CONTENT_TYPES['createTimeTrackingProject'][0]) {
		$request = $this->createTimeTrackingProjectRequest($project_create_request_schema, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TimeTrackingProjectWithTasksAndEmployeeIds',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TimeTrackingProjectWithTasksAndEmployeeIds',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TimeTrackingProjectWithTasksAndEmployeeIds',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation createTimeTrackingProjectAsync
	 *
	 * Create Time Tracking Project
	 *
	 * @param  \BhrSdk\Model\ProjectCreateRequestSchema|null $project_create_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['createTimeTrackingProject'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function createTimeTrackingProjectAsync($project_create_request_schema = null, string $contentType = self::CONTENT_TYPES['createTimeTrackingProject'][0]) {
		return $this->createTimeTrackingProjectAsyncWithHttpInfo($project_create_request_schema, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation createTimeTrackingProjectAsyncWithHttpInfo
	 *
	 * Create Time Tracking Project
	 *
	 * @param  \BhrSdk\Model\ProjectCreateRequestSchema|null $project_create_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['createTimeTrackingProject'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function createTimeTrackingProjectAsyncWithHttpInfo($project_create_request_schema = null, string $contentType = self::CONTENT_TYPES['createTimeTrackingProject'][0]) {
		$returnType = '\BhrSdk\Model\TimeTrackingProjectWithTasksAndEmployeeIds';
		$request = $this->createTimeTrackingProjectRequest($project_create_request_schema, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'createTimeTrackingProject'
	 *
	 * @param  \BhrSdk\Model\ProjectCreateRequestSchema|null $project_create_request_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['createTimeTrackingProject'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function createTimeTrackingProjectRequest($project_create_request_schema = null, string $contentType = self::CONTENT_TYPES['createTimeTrackingProject'][0]) {



		$resourcePath = '/api/v1/time_tracking/projects';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($project_create_request_schema)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($project_create_request_schema));
			} else {
				$httpBody = $project_create_request_schema;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteCompanyFile
	 *
	 * Delete Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the company file being deleted. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function deleteCompanyFile($file_id, string $contentType = self::CONTENT_TYPES['deleteCompanyFile'][0]) {
		$this->deleteCompanyFileWithHttpInfo($file_id, $contentType);
	}

	/**
	 * Operation deleteCompanyFileWithHttpInfo
	 *
	 * Delete Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the company file being deleted. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteCompanyFileWithHttpInfo($file_id, string $contentType = self::CONTENT_TYPES['deleteCompanyFile'][0]) {
		$request = $this->deleteCompanyFileRequest($file_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteCompanyFileAsync
	 *
	 * Delete Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the company file being deleted. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteCompanyFileAsync($file_id, string $contentType = self::CONTENT_TYPES['deleteCompanyFile'][0]) {
		return $this->deleteCompanyFileAsyncWithHttpInfo($file_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteCompanyFileAsyncWithHttpInfo
	 *
	 * Delete Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the company file being deleted. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteCompanyFileAsyncWithHttpInfo($file_id, string $contentType = self::CONTENT_TYPES['deleteCompanyFile'][0]) {
		$returnType = '';
		$request = $this->deleteCompanyFileRequest($file_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteCompanyFile'
	 *
	 * @param  string $file_id {fileId} is the ID of the company file being deleted. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteCompanyFileRequest($file_id, string $contentType = self::CONTENT_TYPES['deleteCompanyFile'][0]) {

		// verify the required parameter 'file_id' is set
		if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $file_id when calling deleteCompanyFile'
			);
		}


		$resourcePath = '/api/v1/files/{fileId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($file_id !== null) {
			$resourcePath = str_replace(
				'{' . 'fileId' . '}',
				ObjectSerializer::toPathValue($file_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'DELETE',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteEmployeeFile
	 *
	 * Delete Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being deleted. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function deleteEmployeeFile($id, $file_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeFile'][0]) {
		$this->deleteEmployeeFileWithHttpInfo($id, $file_id, $contentType);
	}

	/**
	 * Operation deleteEmployeeFileWithHttpInfo
	 *
	 * Delete Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being deleted. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteEmployeeFileWithHttpInfo($id, $file_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeFile'][0]) {
		$request = $this->deleteEmployeeFileRequest($id, $file_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteEmployeeFileAsync
	 *
	 * Delete Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being deleted. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteEmployeeFileAsync($id, $file_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeFile'][0]) {
		return $this->deleteEmployeeFileAsyncWithHttpInfo($id, $file_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteEmployeeFileAsyncWithHttpInfo
	 *
	 * Delete Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being deleted. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteEmployeeFileAsyncWithHttpInfo($id, $file_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeFile'][0]) {
		$returnType = '';
		$request = $this->deleteEmployeeFileRequest($id, $file_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteEmployeeFile'
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being deleted. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteEmployeeFileRequest($id, $file_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeFile'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling deleteEmployeeFile'
			);
		}

		// verify the required parameter 'file_id' is set
		if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $file_id when calling deleteEmployeeFile'
			);
		}


		$resourcePath = '/api/v1/employees/{id}/files/{fileId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}
		// path params
		if ($file_id !== null) {
			$resourcePath = str_replace(
				'{' . 'fileId' . '}',
				ObjectSerializer::toPathValue($file_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'DELETE',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteEmployeeTableRowV1
	 *
	 * Deletes a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeTableRowV1'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\DeleteEmployeeTableRowV1200Response
	 */
	public function deleteEmployeeTableRowV1($id, $table, $row_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeTableRowV1'][0]) {
		list($response) = $this->deleteEmployeeTableRowV1WithHttpInfo($id, $table, $row_id, $contentType);
		return $response;
	}

	/**
	 * Operation deleteEmployeeTableRowV1WithHttpInfo
	 *
	 * Deletes a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeTableRowV1'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\DeleteEmployeeTableRowV1200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteEmployeeTableRowV1WithHttpInfo($id, $table, $row_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeTableRowV1'][0]) {
		$request = $this->deleteEmployeeTableRowV1Request($id, $table, $row_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\DeleteEmployeeTableRowV1200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\DeleteEmployeeTableRowV1200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\DeleteEmployeeTableRowV1200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteEmployeeTableRowV1Async
	 *
	 * Deletes a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeTableRowV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteEmployeeTableRowV1Async($id, $table, $row_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeTableRowV1'][0]) {
		return $this->deleteEmployeeTableRowV1AsyncWithHttpInfo($id, $table, $row_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteEmployeeTableRowV1AsyncWithHttpInfo
	 *
	 * Deletes a table row
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeTableRowV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteEmployeeTableRowV1AsyncWithHttpInfo($id, $table, $row_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeTableRowV1'][0]) {
		$returnType = '\BhrSdk\Model\DeleteEmployeeTableRowV1200Response';
		$request = $this->deleteEmployeeTableRowV1Request($id, $table, $row_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteEmployeeTableRowV1'
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeTableRowV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteEmployeeTableRowV1Request($id, $table, $row_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeTableRowV1'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling deleteEmployeeTableRowV1'
			);
		}

		// verify the required parameter 'table' is set
		if ($table === null || (is_array($table) && count($table) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table when calling deleteEmployeeTableRowV1'
			);
		}

		// verify the required parameter 'row_id' is set
		if ($row_id === null || (is_array($row_id) && count($row_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $row_id when calling deleteEmployeeTableRowV1'
			);
		}


		$resourcePath = '/api/v1/employees/{id}/tables/{table}/{rowId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}
		// path params
		if ($table !== null) {
			$resourcePath = str_replace(
				'{' . 'table' . '}',
				ObjectSerializer::toPathValue($table),
				$resourcePath
			);
		}
		// path params
		if ($row_id !== null) {
			$resourcePath = str_replace(
				'{' . 'rowId' . '}',
				ObjectSerializer::toPathValue($row_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'DELETE',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteEmployeeTrainingRecord
	 *
	 * Delete Employee Training Record
	 *
	 * @param  int $employee_training_record_id The ID of the training record to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function deleteEmployeeTrainingRecord($employee_training_record_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeTrainingRecord'][0]) {
		$this->deleteEmployeeTrainingRecordWithHttpInfo($employee_training_record_id, $contentType);
	}

	/**
	 * Operation deleteEmployeeTrainingRecordWithHttpInfo
	 *
	 * Delete Employee Training Record
	 *
	 * @param  int $employee_training_record_id The ID of the training record to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteEmployeeTrainingRecordWithHttpInfo($employee_training_record_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeTrainingRecord'][0]) {
		$request = $this->deleteEmployeeTrainingRecordRequest($employee_training_record_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteEmployeeTrainingRecordAsync
	 *
	 * Delete Employee Training Record
	 *
	 * @param  int $employee_training_record_id The ID of the training record to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteEmployeeTrainingRecordAsync($employee_training_record_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeTrainingRecord'][0]) {
		return $this->deleteEmployeeTrainingRecordAsyncWithHttpInfo($employee_training_record_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteEmployeeTrainingRecordAsyncWithHttpInfo
	 *
	 * Delete Employee Training Record
	 *
	 * @param  int $employee_training_record_id The ID of the training record to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteEmployeeTrainingRecordAsyncWithHttpInfo($employee_training_record_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeTrainingRecord'][0]) {
		$returnType = '';
		$request = $this->deleteEmployeeTrainingRecordRequest($employee_training_record_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteEmployeeTrainingRecord'
	 *
	 * @param  int $employee_training_record_id The ID of the training record to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteEmployeeTrainingRecordRequest($employee_training_record_id, string $contentType = self::CONTENT_TYPES['deleteEmployeeTrainingRecord'][0]) {

		// verify the required parameter 'employee_training_record_id' is set
		if ($employee_training_record_id === null || (is_array($employee_training_record_id) && count($employee_training_record_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_training_record_id when calling deleteEmployeeTrainingRecord'
			);
		}


		$resourcePath = '/api/v1/training/record/{employeeTrainingRecordId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_training_record_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeTrainingRecordId' . '}',
				ObjectSerializer::toPathValue($employee_training_record_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'DELETE',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteGoal
	 *
	 * Delete Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteGoal'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function deleteGoal($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['deleteGoal'][0]) {
		$this->deleteGoalWithHttpInfo($employee_id, $goal_id, $contentType);
	}

	/**
	 * Operation deleteGoalWithHttpInfo
	 *
	 * Delete Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteGoal'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteGoalWithHttpInfo($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['deleteGoal'][0]) {
		$request = $this->deleteGoalRequest($employee_id, $goal_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteGoalAsync
	 *
	 * Delete Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteGoalAsync($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['deleteGoal'][0]) {
		return $this->deleteGoalAsyncWithHttpInfo($employee_id, $goal_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteGoalAsyncWithHttpInfo
	 *
	 * Delete Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteGoalAsyncWithHttpInfo($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['deleteGoal'][0]) {
		$returnType = '';
		$request = $this->deleteGoalRequest($employee_id, $goal_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteGoal'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteGoalRequest($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['deleteGoal'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling deleteGoal'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling deleteGoal'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'DELETE',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteGoalComment
	 *
	 * Delete Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $comment_id commentId is the ID of a specific comment for the specified goal. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteGoalComment'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function deleteGoalComment($employee_id, $goal_id, $comment_id, string $contentType = self::CONTENT_TYPES['deleteGoalComment'][0]) {
		$this->deleteGoalCommentWithHttpInfo($employee_id, $goal_id, $comment_id, $contentType);
	}

	/**
	 * Operation deleteGoalCommentWithHttpInfo
	 *
	 * Delete Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $comment_id commentId is the ID of a specific comment for the specified goal. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteGoalComment'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteGoalCommentWithHttpInfo($employee_id, $goal_id, $comment_id, string $contentType = self::CONTENT_TYPES['deleteGoalComment'][0]) {
		$request = $this->deleteGoalCommentRequest($employee_id, $goal_id, $comment_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteGoalCommentAsync
	 *
	 * Delete Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $comment_id commentId is the ID of a specific comment for the specified goal. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteGoalComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteGoalCommentAsync($employee_id, $goal_id, $comment_id, string $contentType = self::CONTENT_TYPES['deleteGoalComment'][0]) {
		return $this->deleteGoalCommentAsyncWithHttpInfo($employee_id, $goal_id, $comment_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteGoalCommentAsyncWithHttpInfo
	 *
	 * Delete Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $comment_id commentId is the ID of a specific comment for the specified goal. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteGoalComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteGoalCommentAsyncWithHttpInfo($employee_id, $goal_id, $comment_id, string $contentType = self::CONTENT_TYPES['deleteGoalComment'][0]) {
		$returnType = '';
		$request = $this->deleteGoalCommentRequest($employee_id, $goal_id, $comment_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteGoalComment'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $comment_id commentId is the ID of a specific comment for the specified goal. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteGoalComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteGoalCommentRequest($employee_id, $goal_id, $comment_id, string $contentType = self::CONTENT_TYPES['deleteGoalComment'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling deleteGoalComment'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling deleteGoalComment'
			);
		}

		// verify the required parameter 'comment_id' is set
		if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $comment_id when calling deleteGoalComment'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}/comments/{commentId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}
		// path params
		if ($comment_id !== null) {
			$resourcePath = str_replace(
				'{' . 'commentId' . '}',
				ObjectSerializer::toPathValue($comment_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'DELETE',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteTimeTrackingById
	 *
	 * Delete Hour Record
	 *
	 * @param  string $id The time tracking id is the id that was used to track the record up to 36 characters in length. (i.e. UUID). (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimeTrackingById'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TimeTrackingDeleteResponseSchema|mixed
	 */
	public function deleteTimeTrackingById($id, string $contentType = self::CONTENT_TYPES['deleteTimeTrackingById'][0]) {
		list($response) = $this->deleteTimeTrackingByIdWithHttpInfo($id, $contentType);
		return $response;
	}

	/**
	 * Operation deleteTimeTrackingByIdWithHttpInfo
	 *
	 * Delete Hour Record
	 *
	 * @param  string $id The time tracking id is the id that was used to track the record up to 36 characters in length. (i.e. UUID). (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimeTrackingById'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TimeTrackingDeleteResponseSchema|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteTimeTrackingByIdWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['deleteTimeTrackingById'][0]) {
		$request = $this->deleteTimeTrackingByIdRequest($id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TimeTrackingDeleteResponseSchema',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TimeTrackingDeleteResponseSchema',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TimeTrackingDeleteResponseSchema',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteTimeTrackingByIdAsync
	 *
	 * Delete Hour Record
	 *
	 * @param  string $id The time tracking id is the id that was used to track the record up to 36 characters in length. (i.e. UUID). (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimeTrackingById'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteTimeTrackingByIdAsync($id, string $contentType = self::CONTENT_TYPES['deleteTimeTrackingById'][0]) {
		return $this->deleteTimeTrackingByIdAsyncWithHttpInfo($id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteTimeTrackingByIdAsyncWithHttpInfo
	 *
	 * Delete Hour Record
	 *
	 * @param  string $id The time tracking id is the id that was used to track the record up to 36 characters in length. (i.e. UUID). (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimeTrackingById'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteTimeTrackingByIdAsyncWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['deleteTimeTrackingById'][0]) {
		$returnType = '\BhrSdk\Model\TimeTrackingDeleteResponseSchema';
		$request = $this->deleteTimeTrackingByIdRequest($id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteTimeTrackingById'
	 *
	 * @param  string $id The time tracking id is the id that was used to track the record up to 36 characters in length. (i.e. UUID). (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimeTrackingById'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteTimeTrackingByIdRequest($id, string $contentType = self::CONTENT_TYPES['deleteTimeTrackingById'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling deleteTimeTrackingById'
			);
		}


		$resourcePath = '/api/v1/timetracking/delete/{id}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'DELETE',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteTimesheetClockEntriesViaPost
	 *
	 * Delete Timesheet Clock Entries
	 *
	 * @param  \BhrSdk\Model\ClockEntryIdsSchema $clock_entry_ids_schema clock_entry_ids_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimesheetClockEntriesViaPost'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return mixed|mixed|mixed|mixed|mixed|mixed|mixed
	 */
	public function deleteTimesheetClockEntriesViaPost($clock_entry_ids_schema, string $contentType = self::CONTENT_TYPES['deleteTimesheetClockEntriesViaPost'][0]) {
		list($response) = $this->deleteTimesheetClockEntriesViaPostWithHttpInfo($clock_entry_ids_schema, $contentType);
		return $response;
	}

	/**
	 * Operation deleteTimesheetClockEntriesViaPostWithHttpInfo
	 *
	 * Delete Timesheet Clock Entries
	 *
	 * @param  \BhrSdk\Model\ClockEntryIdsSchema $clock_entry_ids_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimesheetClockEntriesViaPost'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of mixed|mixed|mixed|mixed|mixed|mixed|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteTimesheetClockEntriesViaPostWithHttpInfo($clock_entry_ids_schema, string $contentType = self::CONTENT_TYPES['deleteTimesheetClockEntriesViaPost'][0]) {
		$request = $this->deleteTimesheetClockEntriesViaPostRequest($clock_entry_ids_schema, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 204:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 404:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 409:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 412:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'mixed',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 204:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 404:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 409:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 412:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteTimesheetClockEntriesViaPostAsync
	 *
	 * Delete Timesheet Clock Entries
	 *
	 * @param  \BhrSdk\Model\ClockEntryIdsSchema $clock_entry_ids_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimesheetClockEntriesViaPost'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteTimesheetClockEntriesViaPostAsync($clock_entry_ids_schema, string $contentType = self::CONTENT_TYPES['deleteTimesheetClockEntriesViaPost'][0]) {
		return $this->deleteTimesheetClockEntriesViaPostAsyncWithHttpInfo($clock_entry_ids_schema, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteTimesheetClockEntriesViaPostAsyncWithHttpInfo
	 *
	 * Delete Timesheet Clock Entries
	 *
	 * @param  \BhrSdk\Model\ClockEntryIdsSchema $clock_entry_ids_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimesheetClockEntriesViaPost'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteTimesheetClockEntriesViaPostAsyncWithHttpInfo($clock_entry_ids_schema, string $contentType = self::CONTENT_TYPES['deleteTimesheetClockEntriesViaPost'][0]) {
		$returnType = 'mixed';
		$request = $this->deleteTimesheetClockEntriesViaPostRequest($clock_entry_ids_schema, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteTimesheetClockEntriesViaPost'
	 *
	 * @param  \BhrSdk\Model\ClockEntryIdsSchema $clock_entry_ids_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimesheetClockEntriesViaPost'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteTimesheetClockEntriesViaPostRequest($clock_entry_ids_schema, string $contentType = self::CONTENT_TYPES['deleteTimesheetClockEntriesViaPost'][0]) {

		// verify the required parameter 'clock_entry_ids_schema' is set
		if ($clock_entry_ids_schema === null || (is_array($clock_entry_ids_schema) && count($clock_entry_ids_schema) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $clock_entry_ids_schema when calling deleteTimesheetClockEntriesViaPost'
			);
		}


		$resourcePath = '/api/v1/time_tracking/clock_entries/delete';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($clock_entry_ids_schema)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($clock_entry_ids_schema));
			} else {
				$httpBody = $clock_entry_ids_schema;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteTimesheetHourEntriesViaPost
	 *
	 * Delete Timesheet Hour Entries
	 *
	 * @param  \BhrSdk\Model\HourEntryIdsSchema|null $hour_entry_ids_schema hour_entry_ids_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimesheetHourEntriesViaPost'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return mixed|mixed|mixed|mixed|mixed|mixed|mixed|mixed
	 */
	public function deleteTimesheetHourEntriesViaPost($hour_entry_ids_schema = null, string $contentType = self::CONTENT_TYPES['deleteTimesheetHourEntriesViaPost'][0]) {
		list($response) = $this->deleteTimesheetHourEntriesViaPostWithHttpInfo($hour_entry_ids_schema, $contentType);
		return $response;
	}

	/**
	 * Operation deleteTimesheetHourEntriesViaPostWithHttpInfo
	 *
	 * Delete Timesheet Hour Entries
	 *
	 * @param  \BhrSdk\Model\HourEntryIdsSchema|null $hour_entry_ids_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimesheetHourEntriesViaPost'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of mixed|mixed|mixed|mixed|mixed|mixed|mixed|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteTimesheetHourEntriesViaPostWithHttpInfo($hour_entry_ids_schema = null, string $contentType = self::CONTENT_TYPES['deleteTimesheetHourEntriesViaPost'][0]) {
		$request = $this->deleteTimesheetHourEntriesViaPostRequest($hour_entry_ids_schema, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 204:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 401:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 406:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 409:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 412:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'mixed',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 204:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 401:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 406:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 409:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 412:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteTimesheetHourEntriesViaPostAsync
	 *
	 * Delete Timesheet Hour Entries
	 *
	 * @param  \BhrSdk\Model\HourEntryIdsSchema|null $hour_entry_ids_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimesheetHourEntriesViaPost'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteTimesheetHourEntriesViaPostAsync($hour_entry_ids_schema = null, string $contentType = self::CONTENT_TYPES['deleteTimesheetHourEntriesViaPost'][0]) {
		return $this->deleteTimesheetHourEntriesViaPostAsyncWithHttpInfo($hour_entry_ids_schema, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteTimesheetHourEntriesViaPostAsyncWithHttpInfo
	 *
	 * Delete Timesheet Hour Entries
	 *
	 * @param  \BhrSdk\Model\HourEntryIdsSchema|null $hour_entry_ids_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimesheetHourEntriesViaPost'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteTimesheetHourEntriesViaPostAsyncWithHttpInfo($hour_entry_ids_schema = null, string $contentType = self::CONTENT_TYPES['deleteTimesheetHourEntriesViaPost'][0]) {
		$returnType = 'mixed';
		$request = $this->deleteTimesheetHourEntriesViaPostRequest($hour_entry_ids_schema, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteTimesheetHourEntriesViaPost'
	 *
	 * @param  \BhrSdk\Model\HourEntryIdsSchema|null $hour_entry_ids_schema (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTimesheetHourEntriesViaPost'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteTimesheetHourEntriesViaPostRequest($hour_entry_ids_schema = null, string $contentType = self::CONTENT_TYPES['deleteTimesheetHourEntriesViaPost'][0]) {



		$resourcePath = '/api/v1/time_tracking/hour_entries/delete';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($hour_entry_ids_schema)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($hour_entry_ids_schema));
			} else {
				$httpBody = $hour_entry_ids_schema;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteTrainingCategory
	 *
	 * Delete Training Category
	 *
	 * @param  int $training_category_id The ID of the training category to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function deleteTrainingCategory($training_category_id, string $contentType = self::CONTENT_TYPES['deleteTrainingCategory'][0]) {
		$this->deleteTrainingCategoryWithHttpInfo($training_category_id, $contentType);
	}

	/**
	 * Operation deleteTrainingCategoryWithHttpInfo
	 *
	 * Delete Training Category
	 *
	 * @param  int $training_category_id The ID of the training category to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteTrainingCategoryWithHttpInfo($training_category_id, string $contentType = self::CONTENT_TYPES['deleteTrainingCategory'][0]) {
		$request = $this->deleteTrainingCategoryRequest($training_category_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteTrainingCategoryAsync
	 *
	 * Delete Training Category
	 *
	 * @param  int $training_category_id The ID of the training category to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteTrainingCategoryAsync($training_category_id, string $contentType = self::CONTENT_TYPES['deleteTrainingCategory'][0]) {
		return $this->deleteTrainingCategoryAsyncWithHttpInfo($training_category_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteTrainingCategoryAsyncWithHttpInfo
	 *
	 * Delete Training Category
	 *
	 * @param  int $training_category_id The ID of the training category to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteTrainingCategoryAsyncWithHttpInfo($training_category_id, string $contentType = self::CONTENT_TYPES['deleteTrainingCategory'][0]) {
		$returnType = '';
		$request = $this->deleteTrainingCategoryRequest($training_category_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteTrainingCategory'
	 *
	 * @param  int $training_category_id The ID of the training category to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteTrainingCategoryRequest($training_category_id, string $contentType = self::CONTENT_TYPES['deleteTrainingCategory'][0]) {

		// verify the required parameter 'training_category_id' is set
		if ($training_category_id === null || (is_array($training_category_id) && count($training_category_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $training_category_id when calling deleteTrainingCategory'
			);
		}


		$resourcePath = '/api/v1/training/category/{trainingCategoryId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($training_category_id !== null) {
			$resourcePath = str_replace(
				'{' . 'trainingCategoryId' . '}',
				ObjectSerializer::toPathValue($training_category_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'DELETE',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteTrainingType
	 *
	 * Delete Training Type
	 *
	 * @param  int $training_type_id The ID of the training type to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTrainingType'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function deleteTrainingType($training_type_id, string $contentType = self::CONTENT_TYPES['deleteTrainingType'][0]) {
		$this->deleteTrainingTypeWithHttpInfo($training_type_id, $contentType);
	}

	/**
	 * Operation deleteTrainingTypeWithHttpInfo
	 *
	 * Delete Training Type
	 *
	 * @param  int $training_type_id The ID of the training type to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTrainingType'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteTrainingTypeWithHttpInfo($training_type_id, string $contentType = self::CONTENT_TYPES['deleteTrainingType'][0]) {
		$request = $this->deleteTrainingTypeRequest($training_type_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteTrainingTypeAsync
	 *
	 * Delete Training Type
	 *
	 * @param  int $training_type_id The ID of the training type to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTrainingType'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteTrainingTypeAsync($training_type_id, string $contentType = self::CONTENT_TYPES['deleteTrainingType'][0]) {
		return $this->deleteTrainingTypeAsyncWithHttpInfo($training_type_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteTrainingTypeAsyncWithHttpInfo
	 *
	 * Delete Training Type
	 *
	 * @param  int $training_type_id The ID of the training type to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTrainingType'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteTrainingTypeAsyncWithHttpInfo($training_type_id, string $contentType = self::CONTENT_TYPES['deleteTrainingType'][0]) {
		$returnType = '';
		$request = $this->deleteTrainingTypeRequest($training_type_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteTrainingType'
	 *
	 * @param  int $training_type_id The ID of the training type to delete. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteTrainingType'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteTrainingTypeRequest($training_type_id, string $contentType = self::CONTENT_TYPES['deleteTrainingType'][0]) {

		// verify the required parameter 'training_type_id' is set
		if ($training_type_id === null || (is_array($training_type_id) && count($training_type_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $training_type_id when calling deleteTrainingType'
			);
		}


		$resourcePath = '/api/v1/training/type/{trainingTypeId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($training_type_id !== null) {
			$resourcePath = str_replace(
				'{' . 'trainingTypeId' . '}',
				ObjectSerializer::toPathValue($training_type_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'DELETE',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteWebhook
	 *
	 * Delete Webhook
	 *
	 * @param  string $id {id} is an webhook ID that is associated with the User API key. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteWebhook'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function deleteWebhook($id, string $contentType = self::CONTENT_TYPES['deleteWebhook'][0]) {
		$this->deleteWebhookWithHttpInfo($id, $contentType);
	}

	/**
	 * Operation deleteWebhookWithHttpInfo
	 *
	 * Delete Webhook
	 *
	 * @param  string $id {id} is an webhook ID that is associated with the User API key. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteWebhook'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteWebhookWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['deleteWebhook'][0]) {
		$request = $this->deleteWebhookRequest($id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 404:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation deleteWebhookAsync
	 *
	 * Delete Webhook
	 *
	 * @param  string $id {id} is an webhook ID that is associated with the User API key. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteWebhookAsync($id, string $contentType = self::CONTENT_TYPES['deleteWebhook'][0]) {
		return $this->deleteWebhookAsyncWithHttpInfo($id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteWebhookAsyncWithHttpInfo
	 *
	 * Delete Webhook
	 *
	 * @param  string $id {id} is an webhook ID that is associated with the User API key. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteWebhookAsyncWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['deleteWebhook'][0]) {
		$returnType = '';
		$request = $this->deleteWebhookRequest($id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteWebhook'
	 *
	 * @param  string $id {id} is an webhook ID that is associated with the User API key. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['deleteWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function deleteWebhookRequest($id, string $contentType = self::CONTENT_TYPES['deleteWebhook'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling deleteWebhook'
			);
		}


		$resourcePath = '/api/v1/webhooks/{id}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'DELETE',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation editTimeTrackingRecord
	 *
	 * Edit Hour Record
	 *
	 * @param  \BhrSdk\Model\AdjustTimeTrackingRequestSchema $adjust_time_tracking_request_schema adjust_time_tracking_request_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['editTimeTrackingRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TimeTrackingIdResponseSchema|mixed
	 */
	public function editTimeTrackingRecord($adjust_time_tracking_request_schema, string $contentType = self::CONTENT_TYPES['editTimeTrackingRecord'][0]) {
		list($response) = $this->editTimeTrackingRecordWithHttpInfo($adjust_time_tracking_request_schema, $contentType);
		return $response;
	}

	/**
	 * Operation editTimeTrackingRecordWithHttpInfo
	 *
	 * Edit Hour Record
	 *
	 * @param  \BhrSdk\Model\AdjustTimeTrackingRequestSchema $adjust_time_tracking_request_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['editTimeTrackingRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TimeTrackingIdResponseSchema|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function editTimeTrackingRecordWithHttpInfo($adjust_time_tracking_request_schema, string $contentType = self::CONTENT_TYPES['editTimeTrackingRecord'][0]) {
		$request = $this->editTimeTrackingRecordRequest($adjust_time_tracking_request_schema, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TimeTrackingIdResponseSchema',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TimeTrackingIdResponseSchema',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TimeTrackingIdResponseSchema',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation editTimeTrackingRecordAsync
	 *
	 * Edit Hour Record
	 *
	 * @param  \BhrSdk\Model\AdjustTimeTrackingRequestSchema $adjust_time_tracking_request_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['editTimeTrackingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function editTimeTrackingRecordAsync($adjust_time_tracking_request_schema, string $contentType = self::CONTENT_TYPES['editTimeTrackingRecord'][0]) {
		return $this->editTimeTrackingRecordAsyncWithHttpInfo($adjust_time_tracking_request_schema, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation editTimeTrackingRecordAsyncWithHttpInfo
	 *
	 * Edit Hour Record
	 *
	 * @param  \BhrSdk\Model\AdjustTimeTrackingRequestSchema $adjust_time_tracking_request_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['editTimeTrackingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function editTimeTrackingRecordAsyncWithHttpInfo($adjust_time_tracking_request_schema, string $contentType = self::CONTENT_TYPES['editTimeTrackingRecord'][0]) {
		$returnType = '\BhrSdk\Model\TimeTrackingIdResponseSchema';
		$request = $this->editTimeTrackingRecordRequest($adjust_time_tracking_request_schema, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'editTimeTrackingRecord'
	 *
	 * @param  \BhrSdk\Model\AdjustTimeTrackingRequestSchema $adjust_time_tracking_request_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['editTimeTrackingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function editTimeTrackingRecordRequest($adjust_time_tracking_request_schema, string $contentType = self::CONTENT_TYPES['editTimeTrackingRecord'][0]) {

		// verify the required parameter 'adjust_time_tracking_request_schema' is set
		if ($adjust_time_tracking_request_schema === null || (is_array($adjust_time_tracking_request_schema) && count($adjust_time_tracking_request_schema) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $adjust_time_tracking_request_schema when calling editTimeTrackingRecord'
			);
		}


		$resourcePath = '/api/v1/timetracking/adjust';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($adjust_time_tracking_request_schema)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($adjust_time_tracking_request_schema));
			} else {
				$httpBody = $adjust_time_tracking_request_schema;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getAListOfWhoIsOut
	 *
	 * Get a list of Who&#39;s Out
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $start A date in the form YYYY-MM-DD - defaults to the current date. (optional)
	 * @param  string|null $end A date in the form YYYY-MM-DD - defaults to 14 days from the start date. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getAListOfWhoIsOut'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getAListOfWhoIsOut($accept_header_parameter = null, $start = null, $end = null, string $contentType = self::CONTENT_TYPES['getAListOfWhoIsOut'][0]) {
		$this->getAListOfWhoIsOutWithHttpInfo($accept_header_parameter, $start, $end, $contentType);
	}

	/**
	 * Operation getAListOfWhoIsOutWithHttpInfo
	 *
	 * Get a list of Who&#39;s Out
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $start A date in the form YYYY-MM-DD - defaults to the current date. (optional)
	 * @param  string|null $end A date in the form YYYY-MM-DD - defaults to 14 days from the start date. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getAListOfWhoIsOut'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getAListOfWhoIsOutWithHttpInfo($accept_header_parameter = null, $start = null, $end = null, string $contentType = self::CONTENT_TYPES['getAListOfWhoIsOut'][0]) {
		$request = $this->getAListOfWhoIsOutRequest($accept_header_parameter, $start, $end, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getAListOfWhoIsOutAsync
	 *
	 * Get a list of Who&#39;s Out
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $start A date in the form YYYY-MM-DD - defaults to the current date. (optional)
	 * @param  string|null $end A date in the form YYYY-MM-DD - defaults to 14 days from the start date. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getAListOfWhoIsOut'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getAListOfWhoIsOutAsync($accept_header_parameter = null, $start = null, $end = null, string $contentType = self::CONTENT_TYPES['getAListOfWhoIsOut'][0]) {
		return $this->getAListOfWhoIsOutAsyncWithHttpInfo($accept_header_parameter, $start, $end, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getAListOfWhoIsOutAsyncWithHttpInfo
	 *
	 * Get a list of Who&#39;s Out
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $start A date in the form YYYY-MM-DD - defaults to the current date. (optional)
	 * @param  string|null $end A date in the form YYYY-MM-DD - defaults to 14 days from the start date. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getAListOfWhoIsOut'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getAListOfWhoIsOutAsyncWithHttpInfo($accept_header_parameter = null, $start = null, $end = null, string $contentType = self::CONTENT_TYPES['getAListOfWhoIsOut'][0]) {
		$returnType = '';
		$request = $this->getAListOfWhoIsOutRequest($accept_header_parameter, $start, $end, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getAListOfWhoIsOut'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $start A date in the form YYYY-MM-DD - defaults to the current date. (optional)
	 * @param  string|null $end A date in the form YYYY-MM-DD - defaults to 14 days from the start date. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getAListOfWhoIsOut'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getAListOfWhoIsOutRequest($accept_header_parameter = null, $start = null, $end = null, string $contentType = self::CONTENT_TYPES['getAListOfWhoIsOut'][0]) {





		$resourcePath = '/api/v1/time_off/whos_out';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$start,
			'start', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$end,
			'end', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);

		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getApplicationDetails
	 *
	 * Get Application Details
	 *
	 * @param  int $application_id The ID of the application to look up details. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getApplicationDetails'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetApplicationDetails200Response
	 */
	public function getApplicationDetails($application_id, string $contentType = self::CONTENT_TYPES['getApplicationDetails'][0]) {
		list($response) = $this->getApplicationDetailsWithHttpInfo($application_id, $contentType);
		return $response;
	}

	/**
	 * Operation getApplicationDetailsWithHttpInfo
	 *
	 * Get Application Details
	 *
	 * @param  int $application_id The ID of the application to look up details. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getApplicationDetails'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetApplicationDetails200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getApplicationDetailsWithHttpInfo($application_id, string $contentType = self::CONTENT_TYPES['getApplicationDetails'][0]) {
		$request = $this->getApplicationDetailsRequest($application_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetApplicationDetails200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetApplicationDetails200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetApplicationDetails200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getApplicationDetailsAsync
	 *
	 * Get Application Details
	 *
	 * @param  int $application_id The ID of the application to look up details. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getApplicationDetails'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getApplicationDetailsAsync($application_id, string $contentType = self::CONTENT_TYPES['getApplicationDetails'][0]) {
		return $this->getApplicationDetailsAsyncWithHttpInfo($application_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getApplicationDetailsAsyncWithHttpInfo
	 *
	 * Get Application Details
	 *
	 * @param  int $application_id The ID of the application to look up details. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getApplicationDetails'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getApplicationDetailsAsyncWithHttpInfo($application_id, string $contentType = self::CONTENT_TYPES['getApplicationDetails'][0]) {
		$returnType = '\BhrSdk\Model\GetApplicationDetails200Response';
		$request = $this->getApplicationDetailsRequest($application_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getApplicationDetails'
	 *
	 * @param  int $application_id The ID of the application to look up details. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getApplicationDetails'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getApplicationDetailsRequest($application_id, string $contentType = self::CONTENT_TYPES['getApplicationDetails'][0]) {

		// verify the required parameter 'application_id' is set
		if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $application_id when calling getApplicationDetails'
			);
		}


		$resourcePath = '/api/v1/applicant_tracking/applications/{applicationId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($application_id !== null) {
			$resourcePath = str_replace(
				'{' . 'applicationId' . '}',
				ObjectSerializer::toPathValue($application_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getApplications
	 *
	 * Get Applications
	 *
	 * @param  int|null $page The page number (optional)
	 * @param  int|null $job_id A Job Id to limit results to (optional)
	 * @param  int|null $application_status_id Application status id to filter by. (optional)
	 * @param  string|null $application_status A list of application status groups to filter by. (optional)
	 * @param  string|null $job_status_groups A list of position status groups to filter by. (optional)
	 * @param  string|null $search_string A general search criteria by which to find applications. (optional)
	 * @param  string|null $sort_by A specific field to sort the results by. (optional)
	 * @param  string|null $sort_order Order by which to sort results. (optional)
	 * @param  \DateTime|null $new_since Only get applications newer than a given UTC timestamp, for example 2024-01-01 13:00:00 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getApplications'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetApplications200Response
	 */
	public function getApplications($page = null, $job_id = null, $application_status_id = null, $application_status = null, $job_status_groups = null, $search_string = null, $sort_by = null, $sort_order = null, $new_since = null, string $contentType = self::CONTENT_TYPES['getApplications'][0]) {
		list($response) = $this->getApplicationsWithHttpInfo($page, $job_id, $application_status_id, $application_status, $job_status_groups, $search_string, $sort_by, $sort_order, $new_since, $contentType);
		return $response;
	}

	/**
	 * Operation getApplicationsWithHttpInfo
	 *
	 * Get Applications
	 *
	 * @param  int|null $page The page number (optional)
	 * @param  int|null $job_id A Job Id to limit results to (optional)
	 * @param  int|null $application_status_id Application status id to filter by. (optional)
	 * @param  string|null $application_status A list of application status groups to filter by. (optional)
	 * @param  string|null $job_status_groups A list of position status groups to filter by. (optional)
	 * @param  string|null $search_string A general search criteria by which to find applications. (optional)
	 * @param  string|null $sort_by A specific field to sort the results by. (optional)
	 * @param  string|null $sort_order Order by which to sort results. (optional)
	 * @param  \DateTime|null $new_since Only get applications newer than a given UTC timestamp, for example 2024-01-01 13:00:00 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getApplications'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetApplications200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getApplicationsWithHttpInfo($page = null, $job_id = null, $application_status_id = null, $application_status = null, $job_status_groups = null, $search_string = null, $sort_by = null, $sort_order = null, $new_since = null, string $contentType = self::CONTENT_TYPES['getApplications'][0]) {
		$request = $this->getApplicationsRequest($page, $job_id, $application_status_id, $application_status, $job_status_groups, $search_string, $sort_by, $sort_order, $new_since, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetApplications200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetApplications200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetApplications200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getApplicationsAsync
	 *
	 * Get Applications
	 *
	 * @param  int|null $page The page number (optional)
	 * @param  int|null $job_id A Job Id to limit results to (optional)
	 * @param  int|null $application_status_id Application status id to filter by. (optional)
	 * @param  string|null $application_status A list of application status groups to filter by. (optional)
	 * @param  string|null $job_status_groups A list of position status groups to filter by. (optional)
	 * @param  string|null $search_string A general search criteria by which to find applications. (optional)
	 * @param  string|null $sort_by A specific field to sort the results by. (optional)
	 * @param  string|null $sort_order Order by which to sort results. (optional)
	 * @param  \DateTime|null $new_since Only get applications newer than a given UTC timestamp, for example 2024-01-01 13:00:00 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getApplications'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getApplicationsAsync($page = null, $job_id = null, $application_status_id = null, $application_status = null, $job_status_groups = null, $search_string = null, $sort_by = null, $sort_order = null, $new_since = null, string $contentType = self::CONTENT_TYPES['getApplications'][0]) {
		return $this->getApplicationsAsyncWithHttpInfo($page, $job_id, $application_status_id, $application_status, $job_status_groups, $search_string, $sort_by, $sort_order, $new_since, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getApplicationsAsyncWithHttpInfo
	 *
	 * Get Applications
	 *
	 * @param  int|null $page The page number (optional)
	 * @param  int|null $job_id A Job Id to limit results to (optional)
	 * @param  int|null $application_status_id Application status id to filter by. (optional)
	 * @param  string|null $application_status A list of application status groups to filter by. (optional)
	 * @param  string|null $job_status_groups A list of position status groups to filter by. (optional)
	 * @param  string|null $search_string A general search criteria by which to find applications. (optional)
	 * @param  string|null $sort_by A specific field to sort the results by. (optional)
	 * @param  string|null $sort_order Order by which to sort results. (optional)
	 * @param  \DateTime|null $new_since Only get applications newer than a given UTC timestamp, for example 2024-01-01 13:00:00 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getApplications'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getApplicationsAsyncWithHttpInfo($page = null, $job_id = null, $application_status_id = null, $application_status = null, $job_status_groups = null, $search_string = null, $sort_by = null, $sort_order = null, $new_since = null, string $contentType = self::CONTENT_TYPES['getApplications'][0]) {
		$returnType = '\BhrSdk\Model\GetApplications200Response';
		$request = $this->getApplicationsRequest($page, $job_id, $application_status_id, $application_status, $job_status_groups, $search_string, $sort_by, $sort_order, $new_since, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getApplications'
	 *
	 * @param  int|null $page The page number (optional)
	 * @param  int|null $job_id A Job Id to limit results to (optional)
	 * @param  int|null $application_status_id Application status id to filter by. (optional)
	 * @param  string|null $application_status A list of application status groups to filter by. (optional)
	 * @param  string|null $job_status_groups A list of position status groups to filter by. (optional)
	 * @param  string|null $search_string A general search criteria by which to find applications. (optional)
	 * @param  string|null $sort_by A specific field to sort the results by. (optional)
	 * @param  string|null $sort_order Order by which to sort results. (optional)
	 * @param  \DateTime|null $new_since Only get applications newer than a given UTC timestamp, for example 2024-01-01 13:00:00 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getApplications'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getApplicationsRequest($page = null, $job_id = null, $application_status_id = null, $application_status = null, $job_status_groups = null, $search_string = null, $sort_by = null, $sort_order = null, $new_since = null, string $contentType = self::CONTENT_TYPES['getApplications'][0]) {











		$resourcePath = '/api/v1/applicant_tracking/applications';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$page,
			'page', // param base name
			'integer', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$job_id,
			'jobId', // param base name
			'integer', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$application_status_id,
			'applicationStatusId', // param base name
			'integer', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$application_status,
			'applicationStatus', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$job_status_groups,
			'jobStatusGroups', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$search_string,
			'searchString', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$sort_by,
			'sortBy', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$sort_order,
			'sortOrder', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$new_since,
			'newSince', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);




		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getBenefitCoverages
	 *
	 * Get benefit coverages
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getBenefitCoverages'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getBenefitCoverages($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getBenefitCoverages'][0]) {
		$this->getBenefitCoveragesWithHttpInfo($accept_header_parameter, $contentType);
	}

	/**
	 * Operation getBenefitCoveragesWithHttpInfo
	 *
	 * Get benefit coverages
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getBenefitCoverages'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getBenefitCoveragesWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getBenefitCoverages'][0]) {
		$request = $this->getBenefitCoveragesRequest($accept_header_parameter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getBenefitCoveragesAsync
	 *
	 * Get benefit coverages
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getBenefitCoverages'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getBenefitCoveragesAsync($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getBenefitCoverages'][0]) {
		return $this->getBenefitCoveragesAsyncWithHttpInfo($accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getBenefitCoveragesAsyncWithHttpInfo
	 *
	 * Get benefit coverages
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getBenefitCoverages'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getBenefitCoveragesAsyncWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getBenefitCoverages'][0]) {
		$returnType = '';
		$request = $this->getBenefitCoveragesRequest($accept_header_parameter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getBenefitCoverages'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getBenefitCoverages'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getBenefitCoveragesRequest($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getBenefitCoverages'][0]) {



		$resourcePath = '/api/v1/benefitcoverages';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;


		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getBenefitDeductionTypes
	 *
	 * Get benefit deduction types
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getBenefitDeductionTypes'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getBenefitDeductionTypes(string $contentType = self::CONTENT_TYPES['getBenefitDeductionTypes'][0]) {
		$this->getBenefitDeductionTypesWithHttpInfo($contentType);
	}

	/**
	 * Operation getBenefitDeductionTypesWithHttpInfo
	 *
	 * Get benefit deduction types
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getBenefitDeductionTypes'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getBenefitDeductionTypesWithHttpInfo(string $contentType = self::CONTENT_TYPES['getBenefitDeductionTypes'][0]) {
		$request = $this->getBenefitDeductionTypesRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getBenefitDeductionTypesAsync
	 *
	 * Get benefit deduction types
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getBenefitDeductionTypes'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getBenefitDeductionTypesAsync(string $contentType = self::CONTENT_TYPES['getBenefitDeductionTypes'][0]) {
		return $this->getBenefitDeductionTypesAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getBenefitDeductionTypesAsyncWithHttpInfo
	 *
	 * Get benefit deduction types
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getBenefitDeductionTypes'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getBenefitDeductionTypesAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getBenefitDeductionTypes'][0]) {
		$returnType = '';
		$request = $this->getBenefitDeductionTypesRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getBenefitDeductionTypes'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getBenefitDeductionTypes'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getBenefitDeductionTypesRequest(string $contentType = self::CONTENT_TYPES['getBenefitDeductionTypes'][0]) {


		$resourcePath = '/api/v1/benefits/settings/deduction_types/all';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getByReportId
	 *
	 * Get Report by ID
	 *
	 * @param  int $report_id report_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getByReportId'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\EmployeeResponse
	 */
	public function getByReportId($report_id, string $contentType = self::CONTENT_TYPES['getByReportId'][0]) {
		list($response) = $this->getByReportIdWithHttpInfo($report_id, $contentType);
		return $response;
	}

	/**
	 * Operation getByReportIdWithHttpInfo
	 *
	 * Get Report by ID
	 *
	 * @param  int $report_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getByReportId'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\EmployeeResponse, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getByReportIdWithHttpInfo($report_id, string $contentType = self::CONTENT_TYPES['getByReportId'][0]) {
		$request = $this->getByReportIdRequest($report_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\EmployeeResponse',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\EmployeeResponse',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\EmployeeResponse',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getByReportIdAsync
	 *
	 * Get Report by ID
	 *
	 * @param  int $report_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getByReportId'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getByReportIdAsync($report_id, string $contentType = self::CONTENT_TYPES['getByReportId'][0]) {
		return $this->getByReportIdAsyncWithHttpInfo($report_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getByReportIdAsyncWithHttpInfo
	 *
	 * Get Report by ID
	 *
	 * @param  int $report_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getByReportId'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getByReportIdAsyncWithHttpInfo($report_id, string $contentType = self::CONTENT_TYPES['getByReportId'][0]) {
		$returnType = '\BhrSdk\Model\EmployeeResponse';
		$request = $this->getByReportIdRequest($report_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getByReportId'
	 *
	 * @param  int $report_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getByReportId'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getByReportIdRequest($report_id, string $contentType = self::CONTENT_TYPES['getByReportId'][0]) {

		// verify the required parameter 'report_id' is set
		if ($report_id === null || (is_array($report_id) && count($report_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $report_id when calling getByReportId'
			);
		}


		$resourcePath = '/api/v1/custom-reports/{reportId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($report_id !== null) {
			$resourcePath = str_replace(
				'{' . 'reportId' . '}',
				ObjectSerializer::toPathValue($report_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getCanCreateGoal
	 *
	 * Can Create a Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCanCreateGoal'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getCanCreateGoal($employee_id, string $contentType = self::CONTENT_TYPES['getCanCreateGoal'][0]) {
		$this->getCanCreateGoalWithHttpInfo($employee_id, $contentType);
	}

	/**
	 * Operation getCanCreateGoalWithHttpInfo
	 *
	 * Can Create a Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCanCreateGoal'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getCanCreateGoalWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getCanCreateGoal'][0]) {
		$request = $this->getCanCreateGoalRequest($employee_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getCanCreateGoalAsync
	 *
	 * Can Create a Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCanCreateGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCanCreateGoalAsync($employee_id, string $contentType = self::CONTENT_TYPES['getCanCreateGoal'][0]) {
		return $this->getCanCreateGoalAsyncWithHttpInfo($employee_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getCanCreateGoalAsyncWithHttpInfo
	 *
	 * Can Create a Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCanCreateGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCanCreateGoalAsyncWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getCanCreateGoal'][0]) {
		$returnType = '';
		$request = $this->getCanCreateGoalRequest($employee_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getCanCreateGoal'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCanCreateGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getCanCreateGoalRequest($employee_id, string $contentType = self::CONTENT_TYPES['getCanCreateGoal'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getCanCreateGoal'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/canCreateGoals';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getChangedEmployeeIds
	 *
	 * Gets all updated employee IDs
	 *
	 * @param  string $since URL encoded iso8601 timestamp (required)
	 * @param  string|null $type Use one of these in the {type} variable in the URL: \&quot;inserted\&quot;, \&quot;updated\&quot;, \&quot;deleted\&quot; (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getChangedEmployeeIds'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getChangedEmployeeIds($since, $type = null, string $contentType = self::CONTENT_TYPES['getChangedEmployeeIds'][0]) {
		$this->getChangedEmployeeIdsWithHttpInfo($since, $type, $contentType);
	}

	/**
	 * Operation getChangedEmployeeIdsWithHttpInfo
	 *
	 * Gets all updated employee IDs
	 *
	 * @param  string $since URL encoded iso8601 timestamp (required)
	 * @param  string|null $type Use one of these in the {type} variable in the URL: \&quot;inserted\&quot;, \&quot;updated\&quot;, \&quot;deleted\&quot; (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getChangedEmployeeIds'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getChangedEmployeeIdsWithHttpInfo($since, $type = null, string $contentType = self::CONTENT_TYPES['getChangedEmployeeIds'][0]) {
		$request = $this->getChangedEmployeeIdsRequest($since, $type, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getChangedEmployeeIdsAsync
	 *
	 * Gets all updated employee IDs
	 *
	 * @param  string $since URL encoded iso8601 timestamp (required)
	 * @param  string|null $type Use one of these in the {type} variable in the URL: \&quot;inserted\&quot;, \&quot;updated\&quot;, \&quot;deleted\&quot; (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getChangedEmployeeIds'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getChangedEmployeeIdsAsync($since, $type = null, string $contentType = self::CONTENT_TYPES['getChangedEmployeeIds'][0]) {
		return $this->getChangedEmployeeIdsAsyncWithHttpInfo($since, $type, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getChangedEmployeeIdsAsyncWithHttpInfo
	 *
	 * Gets all updated employee IDs
	 *
	 * @param  string $since URL encoded iso8601 timestamp (required)
	 * @param  string|null $type Use one of these in the {type} variable in the URL: \&quot;inserted\&quot;, \&quot;updated\&quot;, \&quot;deleted\&quot; (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getChangedEmployeeIds'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getChangedEmployeeIdsAsyncWithHttpInfo($since, $type = null, string $contentType = self::CONTENT_TYPES['getChangedEmployeeIds'][0]) {
		$returnType = '';
		$request = $this->getChangedEmployeeIdsRequest($since, $type, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getChangedEmployeeIds'
	 *
	 * @param  string $since URL encoded iso8601 timestamp (required)
	 * @param  string|null $type Use one of these in the {type} variable in the URL: \&quot;inserted\&quot;, \&quot;updated\&quot;, \&quot;deleted\&quot; (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getChangedEmployeeIds'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getChangedEmployeeIdsRequest($since, $type = null, string $contentType = self::CONTENT_TYPES['getChangedEmployeeIds'][0]) {

		// verify the required parameter 'since' is set
		if ($since === null || (is_array($since) && count($since) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $since when calling getChangedEmployeeIds'
			);
		}



		$resourcePath = '/api/v1/employees/changed';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$since,
			'since', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$type,
			'type', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);




		$headers = $this->headerSelector->selectHeaders(
			['application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getChangedEmployeeTableData
	 *
	 * Gets all updated employee table data
	 *
	 * @param  string $table Table name (required)
	 * @param  string $since URL encoded iso8601 timestamp (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getChangedEmployeeTableData'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getChangedEmployeeTableData($table, $since, string $contentType = self::CONTENT_TYPES['getChangedEmployeeTableData'][0]) {
		$this->getChangedEmployeeTableDataWithHttpInfo($table, $since, $contentType);
	}

	/**
	 * Operation getChangedEmployeeTableDataWithHttpInfo
	 *
	 * Gets all updated employee table data
	 *
	 * @param  string $table Table name (required)
	 * @param  string $since URL encoded iso8601 timestamp (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getChangedEmployeeTableData'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getChangedEmployeeTableDataWithHttpInfo($table, $since, string $contentType = self::CONTENT_TYPES['getChangedEmployeeTableData'][0]) {
		$request = $this->getChangedEmployeeTableDataRequest($table, $since, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getChangedEmployeeTableDataAsync
	 *
	 * Gets all updated employee table data
	 *
	 * @param  string $table Table name (required)
	 * @param  string $since URL encoded iso8601 timestamp (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getChangedEmployeeTableData'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getChangedEmployeeTableDataAsync($table, $since, string $contentType = self::CONTENT_TYPES['getChangedEmployeeTableData'][0]) {
		return $this->getChangedEmployeeTableDataAsyncWithHttpInfo($table, $since, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getChangedEmployeeTableDataAsyncWithHttpInfo
	 *
	 * Gets all updated employee table data
	 *
	 * @param  string $table Table name (required)
	 * @param  string $since URL encoded iso8601 timestamp (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getChangedEmployeeTableData'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getChangedEmployeeTableDataAsyncWithHttpInfo($table, $since, string $contentType = self::CONTENT_TYPES['getChangedEmployeeTableData'][0]) {
		$returnType = '';
		$request = $this->getChangedEmployeeTableDataRequest($table, $since, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getChangedEmployeeTableData'
	 *
	 * @param  string $table Table name (required)
	 * @param  string $since URL encoded iso8601 timestamp (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getChangedEmployeeTableData'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getChangedEmployeeTableDataRequest($table, $since, string $contentType = self::CONTENT_TYPES['getChangedEmployeeTableData'][0]) {

		// verify the required parameter 'table' is set
		if ($table === null || (is_array($table) && count($table) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table when calling getChangedEmployeeTableData'
			);
		}

		// verify the required parameter 'since' is set
		if ($since === null || (is_array($since) && count($since) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $since when calling getChangedEmployeeTableData'
			);
		}


		$resourcePath = '/api/v1/employees/changed/tables/{table}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$since,
			'since', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);


		// path params
		if ($table !== null) {
			$resourcePath = str_replace(
				'{' . 'table' . '}',
				ObjectSerializer::toPathValue($table),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getCompanyFile
	 *
	 * Get an Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the company file being retrieved. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getCompanyFile($file_id, string $contentType = self::CONTENT_TYPES['getCompanyFile'][0]) {
		$this->getCompanyFileWithHttpInfo($file_id, $contentType);
	}

	/**
	 * Operation getCompanyFileWithHttpInfo
	 *
	 * Get an Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the company file being retrieved. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getCompanyFileWithHttpInfo($file_id, string $contentType = self::CONTENT_TYPES['getCompanyFile'][0]) {
		$request = $this->getCompanyFileRequest($file_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getCompanyFileAsync
	 *
	 * Get an Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the company file being retrieved. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyFileAsync($file_id, string $contentType = self::CONTENT_TYPES['getCompanyFile'][0]) {
		return $this->getCompanyFileAsyncWithHttpInfo($file_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getCompanyFileAsyncWithHttpInfo
	 *
	 * Get an Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the company file being retrieved. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyFileAsyncWithHttpInfo($file_id, string $contentType = self::CONTENT_TYPES['getCompanyFile'][0]) {
		$returnType = '';
		$request = $this->getCompanyFileRequest($file_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getCompanyFile'
	 *
	 * @param  string $file_id {fileId} is the ID of the company file being retrieved. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getCompanyFileRequest($file_id, string $contentType = self::CONTENT_TYPES['getCompanyFile'][0]) {

		// verify the required parameter 'file_id' is set
		if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $file_id when calling getCompanyFile'
			);
		}


		$resourcePath = '/api/v1/files/{fileId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($file_id !== null) {
			$resourcePath = str_replace(
				'{' . 'fileId' . '}',
				ObjectSerializer::toPathValue($file_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getCompanyInformation
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetCompanyInformation200Response
	 */
	public function getCompanyInformation(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		list($response) = $this->getCompanyInformationWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation getCompanyInformationWithHttpInfo
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetCompanyInformation200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getCompanyInformationWithHttpInfo(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		$request = $this->getCompanyInformationRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetCompanyInformation200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetCompanyInformation200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetCompanyInformation200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getCompanyInformationAsync
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyInformationAsync(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		return $this->getCompanyInformationAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getCompanyInformationAsyncWithHttpInfo
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyInformationAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		$returnType = '\BhrSdk\Model\GetCompanyInformation200Response';
		$request = $this->getCompanyInformationRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getCompanyInformation'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getCompanyInformationRequest(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {


		$resourcePath = '/api/v1/company_information';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getCompanyLocations
	 *
	 * Get Company Locations
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyLocations'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetCompanyLocations200ResponseInner[]
	 */
	public function getCompanyLocations(string $contentType = self::CONTENT_TYPES['getCompanyLocations'][0]) {
		list($response) = $this->getCompanyLocationsWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation getCompanyLocationsWithHttpInfo
	 *
	 * Get Company Locations
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyLocations'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetCompanyLocations200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
	 */
	public function getCompanyLocationsWithHttpInfo(string $contentType = self::CONTENT_TYPES['getCompanyLocations'][0]) {
		$request = $this->getCompanyLocationsRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetCompanyLocations200ResponseInner[]',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetCompanyLocations200ResponseInner[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetCompanyLocations200ResponseInner[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getCompanyLocationsAsync
	 *
	 * Get Company Locations
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyLocations'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyLocationsAsync(string $contentType = self::CONTENT_TYPES['getCompanyLocations'][0]) {
		return $this->getCompanyLocationsAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getCompanyLocationsAsyncWithHttpInfo
	 *
	 * Get Company Locations
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyLocations'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyLocationsAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getCompanyLocations'][0]) {
		$returnType = '\BhrSdk\Model\GetCompanyLocations200ResponseInner[]';
		$request = $this->getCompanyLocationsRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getCompanyLocations'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyLocations'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getCompanyLocationsRequest(string $contentType = self::CONTENT_TYPES['getCompanyLocations'][0]) {


		$resourcePath = '/api/v1/applicant_tracking/locations';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getCompanyReport
	 *
	 * Get company report
	 *
	 * @param  string $id {id} is a report ID. (required)
	 * @param  string $format The output format for the report. Supported formats: CSV, PDF, XLS, XML, JSON (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $fd yes&#x3D;apply standard duplicate field filtering, no&#x3D;return the raw results with no duplicate filtering. Default value is \&quot;yes\&quot; (optional)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyReport'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getCompanyReport($id, $format, $accept_header_parameter = null, $fd = null, $only_current = false, string $contentType = self::CONTENT_TYPES['getCompanyReport'][0]) {
		$this->getCompanyReportWithHttpInfo($id, $format, $accept_header_parameter, $fd, $only_current, $contentType);
	}

	/**
	 * Operation getCompanyReportWithHttpInfo
	 *
	 * Get company report
	 *
	 * @param  string $id {id} is a report ID. (required)
	 * @param  string $format The output format for the report. Supported formats: CSV, PDF, XLS, XML, JSON (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $fd yes&#x3D;apply standard duplicate field filtering, no&#x3D;return the raw results with no duplicate filtering. Default value is \&quot;yes\&quot; (optional)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyReport'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getCompanyReportWithHttpInfo($id, $format, $accept_header_parameter = null, $fd = null, $only_current = false, string $contentType = self::CONTENT_TYPES['getCompanyReport'][0]) {
		$request = $this->getCompanyReportRequest($id, $format, $accept_header_parameter, $fd, $only_current, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getCompanyReportAsync
	 *
	 * Get company report
	 *
	 * @param  string $id {id} is a report ID. (required)
	 * @param  string $format The output format for the report. Supported formats: CSV, PDF, XLS, XML, JSON (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $fd yes&#x3D;apply standard duplicate field filtering, no&#x3D;return the raw results with no duplicate filtering. Default value is \&quot;yes\&quot; (optional)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyReport'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyReportAsync($id, $format, $accept_header_parameter = null, $fd = null, $only_current = false, string $contentType = self::CONTENT_TYPES['getCompanyReport'][0]) {
		return $this->getCompanyReportAsyncWithHttpInfo($id, $format, $accept_header_parameter, $fd, $only_current, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getCompanyReportAsyncWithHttpInfo
	 *
	 * Get company report
	 *
	 * @param  string $id {id} is a report ID. (required)
	 * @param  string $format The output format for the report. Supported formats: CSV, PDF, XLS, XML, JSON (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $fd yes&#x3D;apply standard duplicate field filtering, no&#x3D;return the raw results with no duplicate filtering. Default value is \&quot;yes\&quot; (optional)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyReport'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyReportAsyncWithHttpInfo($id, $format, $accept_header_parameter = null, $fd = null, $only_current = false, string $contentType = self::CONTENT_TYPES['getCompanyReport'][0]) {
		$returnType = '';
		$request = $this->getCompanyReportRequest($id, $format, $accept_header_parameter, $fd, $only_current, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getCompanyReport'
	 *
	 * @param  string $id {id} is a report ID. (required)
	 * @param  string $format The output format for the report. Supported formats: CSV, PDF, XLS, XML, JSON (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $fd yes&#x3D;apply standard duplicate field filtering, no&#x3D;return the raw results with no duplicate filtering. Default value is \&quot;yes\&quot; (optional)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyReport'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getCompanyReportRequest($id, $format, $accept_header_parameter = null, $fd = null, $only_current = false, string $contentType = self::CONTENT_TYPES['getCompanyReport'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling getCompanyReport'
			);
		}

		// verify the required parameter 'format' is set
		if ($format === null || (is_array($format) && count($format) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $format when calling getCompanyReport'
			);
		}





		$resourcePath = '/api/v1/reports/{id}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$format,
			'format', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$fd,
			'fd', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$only_current,
			'onlyCurrent', // param base name
			'boolean', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);

		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getCountriesOptions
	 *
	 * Get all countries
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCountriesOptions'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\CountrySchema[]
	 */
	public function getCountriesOptions(string $contentType = self::CONTENT_TYPES['getCountriesOptions'][0]) {
		list($response) = $this->getCountriesOptionsWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation getCountriesOptionsWithHttpInfo
	 *
	 * Get all countries
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCountriesOptions'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\CountrySchema[], HTTP status code, HTTP response headers (array of strings)
	 */
	public function getCountriesOptionsWithHttpInfo(string $contentType = self::CONTENT_TYPES['getCountriesOptions'][0]) {
		$request = $this->getCountriesOptionsRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\CountrySchema[]',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\CountrySchema[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\CountrySchema[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getCountriesOptionsAsync
	 *
	 * Get all countries
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCountriesOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCountriesOptionsAsync(string $contentType = self::CONTENT_TYPES['getCountriesOptions'][0]) {
		return $this->getCountriesOptionsAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getCountriesOptionsAsyncWithHttpInfo
	 *
	 * Get all countries
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCountriesOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCountriesOptionsAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getCountriesOptions'][0]) {
		$returnType = '\BhrSdk\Model\CountrySchema[]';
		$request = $this->getCountriesOptionsRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getCountriesOptions'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCountriesOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getCountriesOptionsRequest(string $contentType = self::CONTENT_TYPES['getCountriesOptions'][0]) {


		$resourcePath = '/api/v1/meta/countries/options';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getDataFromDataset
	 *
	 * Get Data from Dataset
	 *
	 * @param  string $dataset_name The name of the dataset you want data from (required)
	 * @param  \BhrSdk\Model\DataRequest $data_request data_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getDataFromDataset'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\EmployeeResponse
	 */
	public function getDataFromDataset($dataset_name, $data_request, string $contentType = self::CONTENT_TYPES['getDataFromDataset'][0]) {
		list($response) = $this->getDataFromDatasetWithHttpInfo($dataset_name, $data_request, $contentType);
		return $response;
	}

	/**
	 * Operation getDataFromDatasetWithHttpInfo
	 *
	 * Get Data from Dataset
	 *
	 * @param  string $dataset_name The name of the dataset you want data from (required)
	 * @param  \BhrSdk\Model\DataRequest $data_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getDataFromDataset'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\EmployeeResponse, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getDataFromDatasetWithHttpInfo($dataset_name, $data_request, string $contentType = self::CONTENT_TYPES['getDataFromDataset'][0]) {
		$request = $this->getDataFromDatasetRequest($dataset_name, $data_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\EmployeeResponse',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\EmployeeResponse',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\EmployeeResponse',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getDataFromDatasetAsync
	 *
	 * Get Data from Dataset
	 *
	 * @param  string $dataset_name The name of the dataset you want data from (required)
	 * @param  \BhrSdk\Model\DataRequest $data_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getDataFromDataset'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getDataFromDatasetAsync($dataset_name, $data_request, string $contentType = self::CONTENT_TYPES['getDataFromDataset'][0]) {
		return $this->getDataFromDatasetAsyncWithHttpInfo($dataset_name, $data_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getDataFromDatasetAsyncWithHttpInfo
	 *
	 * Get Data from Dataset
	 *
	 * @param  string $dataset_name The name of the dataset you want data from (required)
	 * @param  \BhrSdk\Model\DataRequest $data_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getDataFromDataset'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getDataFromDatasetAsyncWithHttpInfo($dataset_name, $data_request, string $contentType = self::CONTENT_TYPES['getDataFromDataset'][0]) {
		$returnType = '\BhrSdk\Model\EmployeeResponse';
		$request = $this->getDataFromDatasetRequest($dataset_name, $data_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getDataFromDataset'
	 *
	 * @param  string $dataset_name The name of the dataset you want data from (required)
	 * @param  \BhrSdk\Model\DataRequest $data_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getDataFromDataset'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getDataFromDatasetRequest($dataset_name, $data_request, string $contentType = self::CONTENT_TYPES['getDataFromDataset'][0]) {

		// verify the required parameter 'dataset_name' is set
		if ($dataset_name === null || (is_array($dataset_name) && count($dataset_name) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $dataset_name when calling getDataFromDataset'
			);
		}

		// verify the required parameter 'data_request' is set
		if ($data_request === null || (is_array($data_request) && count($data_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $data_request when calling getDataFromDataset'
			);
		}


		$resourcePath = '/api/v1/datasets/{datasetName}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($dataset_name !== null) {
			$resourcePath = str_replace(
				'{' . 'datasetName' . '}',
				ObjectSerializer::toPathValue($dataset_name),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($data_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data_request));
			} else {
				$httpBody = $data_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getDataSets
	 *
	 * Get Data Sets
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getDataSets'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\DatasetResponse
	 */
	public function getDataSets(string $contentType = self::CONTENT_TYPES['getDataSets'][0]) {
		list($response) = $this->getDataSetsWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation getDataSetsWithHttpInfo
	 *
	 * Get Data Sets
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getDataSets'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\DatasetResponse, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getDataSetsWithHttpInfo(string $contentType = self::CONTENT_TYPES['getDataSets'][0]) {
		$request = $this->getDataSetsRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\DatasetResponse',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\DatasetResponse',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\DatasetResponse',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getDataSetsAsync
	 *
	 * Get Data Sets
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getDataSets'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getDataSetsAsync(string $contentType = self::CONTENT_TYPES['getDataSets'][0]) {
		return $this->getDataSetsAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getDataSetsAsyncWithHttpInfo
	 *
	 * Get Data Sets
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getDataSets'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getDataSetsAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getDataSets'][0]) {
		$returnType = '\BhrSdk\Model\DatasetResponse';
		$request = $this->getDataSetsRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getDataSets'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getDataSets'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getDataSetsRequest(string $contentType = self::CONTENT_TYPES['getDataSets'][0]) {


		$resourcePath = '/api/v1/datasets';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getEmployee
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetEmployee200Response
	 */
	public function getEmployee($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		list($response) = $this->getEmployeeWithHttpInfo($fields, $id, $only_current, $accept_header_parameter, $contentType);
		return $response;
	}

	/**
	 * Operation getEmployeeWithHttpInfo
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetEmployee200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeeWithHttpInfo($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		$request = $this->getEmployeeRequest($fields, $id, $only_current, $accept_header_parameter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetEmployee200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetEmployee200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetEmployee200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getEmployeeAsync
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeAsync($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		return $this->getEmployeeAsyncWithHttpInfo($fields, $id, $only_current, $accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeeAsyncWithHttpInfo
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeAsyncWithHttpInfo($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		$returnType = '\BhrSdk\Model\GetEmployee200Response';
		$request = $this->getEmployeeRequest($fields, $id, $only_current, $accept_header_parameter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployee'
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeeRequest($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {

		// verify the required parameter 'fields' is set
		if ($fields === null || (is_array($fields) && count($fields) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $fields when calling getEmployee'
			);
		}

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling getEmployee'
			);
		}




		$resourcePath = '/api/v1/employees/{id}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$fields,
			'fields', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$only_current,
			'onlyCurrent', // param base name
			'boolean', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);

		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getEmployeeDependent
	 *
	 * Get employee dependent
	 *
	 * @param  string $id {id} is the employee dependent ID. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getEmployeeDependent($id, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeeDependent'][0]) {
		$this->getEmployeeDependentWithHttpInfo($id, $accept_header_parameter, $contentType);
	}

	/**
	 * Operation getEmployeeDependentWithHttpInfo
	 *
	 * Get employee dependent
	 *
	 * @param  string $id {id} is the employee dependent ID. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeeDependentWithHttpInfo($id, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeeDependent'][0]) {
		$request = $this->getEmployeeDependentRequest($id, $accept_header_parameter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getEmployeeDependentAsync
	 *
	 * Get employee dependent
	 *
	 * @param  string $id {id} is the employee dependent ID. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeDependentAsync($id, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeeDependent'][0]) {
		return $this->getEmployeeDependentAsyncWithHttpInfo($id, $accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeeDependentAsyncWithHttpInfo
	 *
	 * Get employee dependent
	 *
	 * @param  string $id {id} is the employee dependent ID. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeDependentAsyncWithHttpInfo($id, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeeDependent'][0]) {
		$returnType = '';
		$request = $this->getEmployeeDependentRequest($id, $accept_header_parameter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployeeDependent'
	 *
	 * @param  string $id {id} is the employee dependent ID. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeeDependentRequest($id, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeeDependent'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling getEmployeeDependent'
			);
		}



		$resourcePath = '/api/v1/employeedependents/{id}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;


		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getEmployeeDependents
	 *
	 * Get all employee dependents
	 *
	 * @param  string $employeeid {employeeid} is the employee ID. Supplying this ID limits the response to the specific employee. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeDependents'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getEmployeeDependents($employeeid, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeeDependents'][0]) {
		$this->getEmployeeDependentsWithHttpInfo($employeeid, $accept_header_parameter, $contentType);
	}

	/**
	 * Operation getEmployeeDependentsWithHttpInfo
	 *
	 * Get all employee dependents
	 *
	 * @param  string $employeeid {employeeid} is the employee ID. Supplying this ID limits the response to the specific employee. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeDependents'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeeDependentsWithHttpInfo($employeeid, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeeDependents'][0]) {
		$request = $this->getEmployeeDependentsRequest($employeeid, $accept_header_parameter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getEmployeeDependentsAsync
	 *
	 * Get all employee dependents
	 *
	 * @param  string $employeeid {employeeid} is the employee ID. Supplying this ID limits the response to the specific employee. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeDependents'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeDependentsAsync($employeeid, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeeDependents'][0]) {
		return $this->getEmployeeDependentsAsyncWithHttpInfo($employeeid, $accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeeDependentsAsyncWithHttpInfo
	 *
	 * Get all employee dependents
	 *
	 * @param  string $employeeid {employeeid} is the employee ID. Supplying this ID limits the response to the specific employee. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeDependents'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeDependentsAsyncWithHttpInfo($employeeid, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeeDependents'][0]) {
		$returnType = '';
		$request = $this->getEmployeeDependentsRequest($employeeid, $accept_header_parameter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployeeDependents'
	 *
	 * @param  string $employeeid {employeeid} is the employee ID. Supplying this ID limits the response to the specific employee. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeDependents'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeeDependentsRequest($employeeid, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeeDependents'][0]) {

		// verify the required parameter 'employeeid' is set
		if ($employeeid === null || (is_array($employeeid) && count($employeeid) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employeeid when calling getEmployeeDependents'
			);
		}



		$resourcePath = '/api/v1/employeedependents';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$employeeid,
			'employeeid', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);

		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getEmployeeFile
	 *
	 * Get an Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being retrieved. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getEmployeeFile($id, $file_id, string $contentType = self::CONTENT_TYPES['getEmployeeFile'][0]) {
		$this->getEmployeeFileWithHttpInfo($id, $file_id, $contentType);
	}

	/**
	 * Operation getEmployeeFileWithHttpInfo
	 *
	 * Get an Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being retrieved. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeeFileWithHttpInfo($id, $file_id, string $contentType = self::CONTENT_TYPES['getEmployeeFile'][0]) {
		$request = $this->getEmployeeFileRequest($id, $file_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getEmployeeFileAsync
	 *
	 * Get an Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being retrieved. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeFileAsync($id, $file_id, string $contentType = self::CONTENT_TYPES['getEmployeeFile'][0]) {
		return $this->getEmployeeFileAsyncWithHttpInfo($id, $file_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeeFileAsyncWithHttpInfo
	 *
	 * Get an Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being retrieved. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeFileAsyncWithHttpInfo($id, $file_id, string $contentType = self::CONTENT_TYPES['getEmployeeFile'][0]) {
		$returnType = '';
		$request = $this->getEmployeeFileRequest($id, $file_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployeeFile'
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being retrieved. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeeFileRequest($id, $file_id, string $contentType = self::CONTENT_TYPES['getEmployeeFile'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling getEmployeeFile'
			);
		}

		// verify the required parameter 'file_id' is set
		if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $file_id when calling getEmployeeFile'
			);
		}


		$resourcePath = '/api/v1/employees/{id}/files/{fileId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}
		// path params
		if ($file_id !== null) {
			$resourcePath = str_replace(
				'{' . 'fileId' . '}',
				ObjectSerializer::toPathValue($file_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getEmployeePhoto
	 *
	 * Get an employee photo
	 *
	 * @param  string $employee_id The ID for the employee you are getting the photo for. (required)
	 * @param  string $size Photo size (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeePhoto'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getEmployeePhoto($employee_id, $size, string $contentType = self::CONTENT_TYPES['getEmployeePhoto'][0]) {
		$this->getEmployeePhotoWithHttpInfo($employee_id, $size, $contentType);
	}

	/**
	 * Operation getEmployeePhotoWithHttpInfo
	 *
	 * Get an employee photo
	 *
	 * @param  string $employee_id The ID for the employee you are getting the photo for. (required)
	 * @param  string $size Photo size (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeePhoto'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeePhotoWithHttpInfo($employee_id, $size, string $contentType = self::CONTENT_TYPES['getEmployeePhoto'][0]) {
		$request = $this->getEmployeePhotoRequest($employee_id, $size, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getEmployeePhotoAsync
	 *
	 * Get an employee photo
	 *
	 * @param  string $employee_id The ID for the employee you are getting the photo for. (required)
	 * @param  string $size Photo size (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeePhoto'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeePhotoAsync($employee_id, $size, string $contentType = self::CONTENT_TYPES['getEmployeePhoto'][0]) {
		return $this->getEmployeePhotoAsyncWithHttpInfo($employee_id, $size, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeePhotoAsyncWithHttpInfo
	 *
	 * Get an employee photo
	 *
	 * @param  string $employee_id The ID for the employee you are getting the photo for. (required)
	 * @param  string $size Photo size (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeePhoto'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeePhotoAsyncWithHttpInfo($employee_id, $size, string $contentType = self::CONTENT_TYPES['getEmployeePhoto'][0]) {
		$returnType = '';
		$request = $this->getEmployeePhotoRequest($employee_id, $size, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployeePhoto'
	 *
	 * @param  string $employee_id The ID for the employee you are getting the photo for. (required)
	 * @param  string $size Photo size (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeePhoto'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeePhotoRequest($employee_id, $size, string $contentType = self::CONTENT_TYPES['getEmployeePhoto'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getEmployeePhoto'
			);
		}

		// verify the required parameter 'size' is set
		if ($size === null || (is_array($size) && count($size) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $size when calling getEmployeePhoto'
			);
		}


		$resourcePath = '/api/v1/employees/{employeeId}/photo/{size}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($size !== null) {
			$resourcePath = str_replace(
				'{' . 'size' . '}',
				ObjectSerializer::toPathValue($size),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getEmployeeTableRow
	 *
	 * Gets table rows for a given employee and table combination
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getEmployeeTableRow($id, $table, string $contentType = self::CONTENT_TYPES['getEmployeeTableRow'][0]) {
		$this->getEmployeeTableRowWithHttpInfo($id, $table, $contentType);
	}

	/**
	 * Operation getEmployeeTableRowWithHttpInfo
	 *
	 * Gets table rows for a given employee and table combination
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeeTableRowWithHttpInfo($id, $table, string $contentType = self::CONTENT_TYPES['getEmployeeTableRow'][0]) {
		$request = $this->getEmployeeTableRowRequest($id, $table, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getEmployeeTableRowAsync
	 *
	 * Gets table rows for a given employee and table combination
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeTableRowAsync($id, $table, string $contentType = self::CONTENT_TYPES['getEmployeeTableRow'][0]) {
		return $this->getEmployeeTableRowAsyncWithHttpInfo($id, $table, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeeTableRowAsyncWithHttpInfo
	 *
	 * Gets table rows for a given employee and table combination
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeTableRowAsyncWithHttpInfo($id, $table, string $contentType = self::CONTENT_TYPES['getEmployeeTableRow'][0]) {
		$returnType = '';
		$request = $this->getEmployeeTableRowRequest($id, $table, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployeeTableRow'
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeeTableRowRequest($id, $table, string $contentType = self::CONTENT_TYPES['getEmployeeTableRow'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling getEmployeeTableRow'
			);
		}

		// verify the required parameter 'table' is set
		if ($table === null || (is_array($table) && count($table) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table when calling getEmployeeTableRow'
			);
		}


		$resourcePath = '/api/v1/employees/{id}/tables/{table}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}
		// path params
		if ($table !== null) {
			$resourcePath = str_replace(
				'{' . 'table' . '}',
				ObjectSerializer::toPathValue($table),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getEmployeesDirectory
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetEmployee200Response
	 */
	public function getEmployeesDirectory($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		list($response) = $this->getEmployeesDirectoryWithHttpInfo($accept_header_parameter, $contentType);
		return $response;
	}

	/**
	 * Operation getEmployeesDirectoryWithHttpInfo
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetEmployee200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeesDirectoryWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		$request = $this->getEmployeesDirectoryRequest($accept_header_parameter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetEmployee200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetEmployee200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetEmployee200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getEmployeesDirectoryAsync
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeesDirectoryAsync($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		return $this->getEmployeesDirectoryAsyncWithHttpInfo($accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeesDirectoryAsyncWithHttpInfo
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeesDirectoryAsyncWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		$returnType = '\BhrSdk\Model\GetEmployee200Response';
		$request = $this->getEmployeesDirectoryRequest($accept_header_parameter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployeesDirectory'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeesDirectoryRequest($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {



		$resourcePath = '/api/v1/employees/directory';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;


		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getFieldOptions
	 *
	 * Get Field Options
	 *
	 * @param  string $dataset_name The name of the dataset you want to see field options for (required)
	 * @param  \BhrSdk\Model\FieldOptionsRequestSchema $field_options_request_schema field_options_request_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getFieldOptions'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\FieldOptionsTransformer[]|\BhrSdk\Model\PostWebhook403ResponseErrorsInner|\BhrSdk\Model\PostWebhook403ResponseErrorsInner
	 */
	public function getFieldOptions($dataset_name, $field_options_request_schema, string $contentType = self::CONTENT_TYPES['getFieldOptions'][0]) {
		list($response) = $this->getFieldOptionsWithHttpInfo($dataset_name, $field_options_request_schema, $contentType);
		return $response;
	}

	/**
	 * Operation getFieldOptionsWithHttpInfo
	 *
	 * Get Field Options
	 *
	 * @param  string $dataset_name The name of the dataset you want to see field options for (required)
	 * @param  \BhrSdk\Model\FieldOptionsRequestSchema $field_options_request_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getFieldOptions'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\FieldOptionsTransformer[]|\BhrSdk\Model\PostWebhook403ResponseErrorsInner|\BhrSdk\Model\PostWebhook403ResponseErrorsInner, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getFieldOptionsWithHttpInfo($dataset_name, $field_options_request_schema, string $contentType = self::CONTENT_TYPES['getFieldOptions'][0]) {
		$request = $this->getFieldOptionsRequest($dataset_name, $field_options_request_schema, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\FieldOptionsTransformer[]',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\PostWebhook403ResponseErrorsInner',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\PostWebhook403ResponseErrorsInner',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\FieldOptionsTransformer[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\FieldOptionsTransformer[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\PostWebhook403ResponseErrorsInner',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\PostWebhook403ResponseErrorsInner',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getFieldOptionsAsync
	 *
	 * Get Field Options
	 *
	 * @param  string $dataset_name The name of the dataset you want to see field options for (required)
	 * @param  \BhrSdk\Model\FieldOptionsRequestSchema $field_options_request_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getFieldOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getFieldOptionsAsync($dataset_name, $field_options_request_schema, string $contentType = self::CONTENT_TYPES['getFieldOptions'][0]) {
		return $this->getFieldOptionsAsyncWithHttpInfo($dataset_name, $field_options_request_schema, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getFieldOptionsAsyncWithHttpInfo
	 *
	 * Get Field Options
	 *
	 * @param  string $dataset_name The name of the dataset you want to see field options for (required)
	 * @param  \BhrSdk\Model\FieldOptionsRequestSchema $field_options_request_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getFieldOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getFieldOptionsAsyncWithHttpInfo($dataset_name, $field_options_request_schema, string $contentType = self::CONTENT_TYPES['getFieldOptions'][0]) {
		$returnType = '\BhrSdk\Model\FieldOptionsTransformer[]';
		$request = $this->getFieldOptionsRequest($dataset_name, $field_options_request_schema, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getFieldOptions'
	 *
	 * @param  string $dataset_name The name of the dataset you want to see field options for (required)
	 * @param  \BhrSdk\Model\FieldOptionsRequestSchema $field_options_request_schema (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getFieldOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getFieldOptionsRequest($dataset_name, $field_options_request_schema, string $contentType = self::CONTENT_TYPES['getFieldOptions'][0]) {

		// verify the required parameter 'dataset_name' is set
		if ($dataset_name === null || (is_array($dataset_name) && count($dataset_name) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $dataset_name when calling getFieldOptions'
			);
		}

		// verify the required parameter 'field_options_request_schema' is set
		if ($field_options_request_schema === null || (is_array($field_options_request_schema) && count($field_options_request_schema) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $field_options_request_schema when calling getFieldOptions'
			);
		}


		$resourcePath = '/api/v1/datasets/{datasetName}/field-options';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($dataset_name !== null) {
			$resourcePath = str_replace(
				'{' . 'datasetName' . '}',
				ObjectSerializer::toPathValue($dataset_name),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($field_options_request_schema)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($field_options_request_schema));
			} else {
				$httpBody = $field_options_request_schema;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getFieldsFromDataset
	 *
	 * Get Fields from Dataset
	 *
	 * @param  string $dataset_name The name of the dataset you want to see fields for (required)
	 * @param  int|null $page The page number to retrieve (optional)
	 * @param  int|null $page_size The number of records to retrieve per page. Default is 500 and the Max is 1000 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getFieldsFromDataset'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\DatasetFieldsResponse
	 */
	public function getFieldsFromDataset($dataset_name, $page = null, $page_size = null, string $contentType = self::CONTENT_TYPES['getFieldsFromDataset'][0]) {
		list($response) = $this->getFieldsFromDatasetWithHttpInfo($dataset_name, $page, $page_size, $contentType);
		return $response;
	}

	/**
	 * Operation getFieldsFromDatasetWithHttpInfo
	 *
	 * Get Fields from Dataset
	 *
	 * @param  string $dataset_name The name of the dataset you want to see fields for (required)
	 * @param  int|null $page The page number to retrieve (optional)
	 * @param  int|null $page_size The number of records to retrieve per page. Default is 500 and the Max is 1000 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getFieldsFromDataset'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\DatasetFieldsResponse, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getFieldsFromDatasetWithHttpInfo($dataset_name, $page = null, $page_size = null, string $contentType = self::CONTENT_TYPES['getFieldsFromDataset'][0]) {
		$request = $this->getFieldsFromDatasetRequest($dataset_name, $page, $page_size, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\DatasetFieldsResponse',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\DatasetFieldsResponse',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\DatasetFieldsResponse',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getFieldsFromDatasetAsync
	 *
	 * Get Fields from Dataset
	 *
	 * @param  string $dataset_name The name of the dataset you want to see fields for (required)
	 * @param  int|null $page The page number to retrieve (optional)
	 * @param  int|null $page_size The number of records to retrieve per page. Default is 500 and the Max is 1000 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getFieldsFromDataset'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getFieldsFromDatasetAsync($dataset_name, $page = null, $page_size = null, string $contentType = self::CONTENT_TYPES['getFieldsFromDataset'][0]) {
		return $this->getFieldsFromDatasetAsyncWithHttpInfo($dataset_name, $page, $page_size, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getFieldsFromDatasetAsyncWithHttpInfo
	 *
	 * Get Fields from Dataset
	 *
	 * @param  string $dataset_name The name of the dataset you want to see fields for (required)
	 * @param  int|null $page The page number to retrieve (optional)
	 * @param  int|null $page_size The number of records to retrieve per page. Default is 500 and the Max is 1000 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getFieldsFromDataset'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getFieldsFromDatasetAsyncWithHttpInfo($dataset_name, $page = null, $page_size = null, string $contentType = self::CONTENT_TYPES['getFieldsFromDataset'][0]) {
		$returnType = '\BhrSdk\Model\DatasetFieldsResponse';
		$request = $this->getFieldsFromDatasetRequest($dataset_name, $page, $page_size, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getFieldsFromDataset'
	 *
	 * @param  string $dataset_name The name of the dataset you want to see fields for (required)
	 * @param  int|null $page The page number to retrieve (optional)
	 * @param  int|null $page_size The number of records to retrieve per page. Default is 500 and the Max is 1000 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getFieldsFromDataset'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getFieldsFromDatasetRequest($dataset_name, $page = null, $page_size = null, string $contentType = self::CONTENT_TYPES['getFieldsFromDataset'][0]) {

		// verify the required parameter 'dataset_name' is set
		if ($dataset_name === null || (is_array($dataset_name) && count($dataset_name) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $dataset_name when calling getFieldsFromDataset'
			);
		}




		$resourcePath = '/api/v1/datasets/{datasetName}/fields';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$page,
			'page', // param base name
			'integer', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$page_size,
			'page_size', // param base name
			'integer', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);


		// path params
		if ($dataset_name !== null) {
			$resourcePath = str_replace(
				'{' . 'datasetName' . '}',
				ObjectSerializer::toPathValue($dataset_name),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoalAggregate
	 *
	 * Get Aggregate Goal Info
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the Goal ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalAggregate'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetGoalAggregate200Response
	 */
	public function getGoalAggregate($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['getGoalAggregate'][0]) {
		list($response) = $this->getGoalAggregateWithHttpInfo($employee_id, $goal_id, $contentType);
		return $response;
	}

	/**
	 * Operation getGoalAggregateWithHttpInfo
	 *
	 * Get Aggregate Goal Info
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the Goal ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalAggregate'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetGoalAggregate200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getGoalAggregateWithHttpInfo($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['getGoalAggregate'][0]) {
		$request = $this->getGoalAggregateRequest($employee_id, $goal_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetGoalAggregate200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetGoalAggregate200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetGoalAggregate200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalAggregateAsync
	 *
	 * Get Aggregate Goal Info
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the Goal ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalAggregate'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalAggregateAsync($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['getGoalAggregate'][0]) {
		return $this->getGoalAggregateAsyncWithHttpInfo($employee_id, $goal_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalAggregateAsyncWithHttpInfo
	 *
	 * Get Aggregate Goal Info
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the Goal ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalAggregate'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalAggregateAsyncWithHttpInfo($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['getGoalAggregate'][0]) {
		$returnType = '\BhrSdk\Model\GetGoalAggregate200Response';
		$request = $this->getGoalAggregateRequest($employee_id, $goal_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoalAggregate'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the Goal ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalAggregate'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getGoalAggregateRequest($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['getGoalAggregate'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoalAggregate'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling getGoalAggregate'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}/aggregate';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoalComments
	 *
	 * Get Goal Comments
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalComments'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getGoalComments($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['getGoalComments'][0]) {
		$this->getGoalCommentsWithHttpInfo($employee_id, $goal_id, $contentType);
	}

	/**
	 * Operation getGoalCommentsWithHttpInfo
	 *
	 * Get Goal Comments
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalComments'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getGoalCommentsWithHttpInfo($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['getGoalComments'][0]) {
		$request = $this->getGoalCommentsRequest($employee_id, $goal_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalCommentsAsync
	 *
	 * Get Goal Comments
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalComments'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalCommentsAsync($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['getGoalComments'][0]) {
		return $this->getGoalCommentsAsyncWithHttpInfo($employee_id, $goal_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalCommentsAsyncWithHttpInfo
	 *
	 * Get Goal Comments
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalComments'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalCommentsAsyncWithHttpInfo($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['getGoalComments'][0]) {
		$returnType = '';
		$request = $this->getGoalCommentsRequest($employee_id, $goal_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoalComments'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalComments'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getGoalCommentsRequest($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['getGoalComments'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoalComments'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling getGoalComments'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}/comments';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoals
	 *
	 * Get Goals
	 *
	 * @param  string $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string|null $filter A filter that can be applied to only show the goals that are in a certain state. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoals'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetGoals200Response
	 */
	public function getGoals($employee_id, $filter = null, string $contentType = self::CONTENT_TYPES['getGoals'][0]) {
		list($response) = $this->getGoalsWithHttpInfo($employee_id, $filter, $contentType);
		return $response;
	}

	/**
	 * Operation getGoalsWithHttpInfo
	 *
	 * Get Goals
	 *
	 * @param  string $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string|null $filter A filter that can be applied to only show the goals that are in a certain state. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoals'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetGoals200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getGoalsWithHttpInfo($employee_id, $filter = null, string $contentType = self::CONTENT_TYPES['getGoals'][0]) {
		$request = $this->getGoalsRequest($employee_id, $filter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetGoals200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetGoals200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetGoals200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalsAsync
	 *
	 * Get Goals
	 *
	 * @param  string $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string|null $filter A filter that can be applied to only show the goals that are in a certain state. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoals'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalsAsync($employee_id, $filter = null, string $contentType = self::CONTENT_TYPES['getGoals'][0]) {
		return $this->getGoalsAsyncWithHttpInfo($employee_id, $filter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalsAsyncWithHttpInfo
	 *
	 * Get Goals
	 *
	 * @param  string $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string|null $filter A filter that can be applied to only show the goals that are in a certain state. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoals'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalsAsyncWithHttpInfo($employee_id, $filter = null, string $contentType = self::CONTENT_TYPES['getGoals'][0]) {
		$returnType = '\BhrSdk\Model\GetGoals200Response';
		$request = $this->getGoalsRequest($employee_id, $filter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoals'
	 *
	 * @param  string $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string|null $filter A filter that can be applied to only show the goals that are in a certain state. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoals'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getGoalsRequest($employee_id, $filter = null, string $contentType = self::CONTENT_TYPES['getGoals'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoals'
			);
		}



		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$filter,
			'filter', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);


		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoalsAggregateV1
	 *
	 * Get All Aggregate Goal Info
	 *
	 * @param  string $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV1'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetGoalsAggregateV1200Response
	 * @deprecated
	 */
	public function getGoalsAggregateV1($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV1'][0]) {
		list($response) = $this->getGoalsAggregateV1WithHttpInfo($employee_id, $contentType);
		return $response;
	}

	/**
	 * Operation getGoalsAggregateV1WithHttpInfo
	 *
	 * Get All Aggregate Goal Info
	 *
	 * @param  string $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV1'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetGoalsAggregateV1200Response, HTTP status code, HTTP response headers (array of strings)
	 * @deprecated
	 */
	public function getGoalsAggregateV1WithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV1'][0]) {
		$request = $this->getGoalsAggregateV1Request($employee_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetGoalsAggregateV1200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetGoalsAggregateV1200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetGoalsAggregateV1200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalsAggregateV1Async
	 *
	 * Get All Aggregate Goal Info
	 *
	 * @param  string $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function getGoalsAggregateV1Async($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV1'][0]) {
		return $this->getGoalsAggregateV1AsyncWithHttpInfo($employee_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalsAggregateV1AsyncWithHttpInfo
	 *
	 * Get All Aggregate Goal Info
	 *
	 * @param  string $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function getGoalsAggregateV1AsyncWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV1'][0]) {
		$returnType = '\BhrSdk\Model\GetGoalsAggregateV1200Response';
		$request = $this->getGoalsAggregateV1Request($employee_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoalsAggregateV1'
	 *
	 * @param  string $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 * @deprecated
	 */
	public function getGoalsAggregateV1Request($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV1'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoalsAggregateV1'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/aggregate';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoalsAggregateV11
	 *
	 * Get All Aggregate Goal Info, Version 1.1
	 *
	 * @param  string $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV11'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetGoalsAggregateV11200Response
	 * @deprecated
	 */
	public function getGoalsAggregateV11($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV11'][0]) {
		list($response) = $this->getGoalsAggregateV11WithHttpInfo($employee_id, $contentType);
		return $response;
	}

	/**
	 * Operation getGoalsAggregateV11WithHttpInfo
	 *
	 * Get All Aggregate Goal Info, Version 1.1
	 *
	 * @param  string $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV11'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetGoalsAggregateV11200Response, HTTP status code, HTTP response headers (array of strings)
	 * @deprecated
	 */
	public function getGoalsAggregateV11WithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV11'][0]) {
		$request = $this->getGoalsAggregateV11Request($employee_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetGoalsAggregateV11200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetGoalsAggregateV11200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetGoalsAggregateV11200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalsAggregateV11Async
	 *
	 * Get All Aggregate Goal Info, Version 1.1
	 *
	 * @param  string $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function getGoalsAggregateV11Async($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV11'][0]) {
		return $this->getGoalsAggregateV11AsyncWithHttpInfo($employee_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalsAggregateV11AsyncWithHttpInfo
	 *
	 * Get All Aggregate Goal Info, Version 1.1
	 *
	 * @param  string $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function getGoalsAggregateV11AsyncWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV11'][0]) {
		$returnType = '\BhrSdk\Model\GetGoalsAggregateV11200Response';
		$request = $this->getGoalsAggregateV11Request($employee_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoalsAggregateV11'
	 *
	 * @param  string $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 * @deprecated
	 */
	public function getGoalsAggregateV11Request($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV11'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoalsAggregateV11'
			);
		}


		$resourcePath = '/api/v1_1/performance/employees/{employeeId}/goals/aggregate';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoalsAggregateV12
	 *
	 * Get All Aggregate Goal Info, Version 1.2
	 *
	 * @param  int $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV12'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetGoalsAggregateV12200Response
	 */
	public function getGoalsAggregateV12($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV12'][0]) {
		list($response) = $this->getGoalsAggregateV12WithHttpInfo($employee_id, $contentType);
		return $response;
	}

	/**
	 * Operation getGoalsAggregateV12WithHttpInfo
	 *
	 * Get All Aggregate Goal Info, Version 1.2
	 *
	 * @param  int $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV12'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetGoalsAggregateV12200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getGoalsAggregateV12WithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV12'][0]) {
		$request = $this->getGoalsAggregateV12Request($employee_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetGoalsAggregateV12200Response',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetGoalsAggregateV12200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetGoalsAggregateV12200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalsAggregateV12Async
	 *
	 * Get All Aggregate Goal Info, Version 1.2
	 *
	 * @param  int $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV12'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalsAggregateV12Async($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV12'][0]) {
		return $this->getGoalsAggregateV12AsyncWithHttpInfo($employee_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalsAggregateV12AsyncWithHttpInfo
	 *
	 * Get All Aggregate Goal Info, Version 1.2
	 *
	 * @param  int $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV12'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalsAggregateV12AsyncWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV12'][0]) {
		$returnType = '\BhrSdk\Model\GetGoalsAggregateV12200Response';
		$request = $this->getGoalsAggregateV12Request($employee_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoalsAggregateV12'
	 *
	 * @param  int $employee_id employeeId is the employee ID used to generate the aggregate information. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAggregateV12'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getGoalsAggregateV12Request($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsAggregateV12'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoalsAggregateV12'
			);
		}


		$resourcePath = '/api/v1_2/performance/employees/{employeeId}/goals/aggregate';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoalsAlignmentOptions
	 *
	 * Alignable Goal Options
	 *
	 * @param  string $employee_id employeeId is the employee ID to get alignable goal options for. (required)
	 * @param  string|null $body Get alignment options including the option currently aligned with this goal (if applicable). If omitted, response will be alignment options belonging to the API user. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAlignmentOptions'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getGoalsAlignmentOptions($employee_id, $body = null, string $contentType = self::CONTENT_TYPES['getGoalsAlignmentOptions'][0]) {
		$this->getGoalsAlignmentOptionsWithHttpInfo($employee_id, $body, $contentType);
	}

	/**
	 * Operation getGoalsAlignmentOptionsWithHttpInfo
	 *
	 * Alignable Goal Options
	 *
	 * @param  string $employee_id employeeId is the employee ID to get alignable goal options for. (required)
	 * @param  string|null $body Get alignment options including the option currently aligned with this goal (if applicable). If omitted, response will be alignment options belonging to the API user. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAlignmentOptions'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getGoalsAlignmentOptionsWithHttpInfo($employee_id, $body = null, string $contentType = self::CONTENT_TYPES['getGoalsAlignmentOptions'][0]) {
		$request = $this->getGoalsAlignmentOptionsRequest($employee_id, $body, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalsAlignmentOptionsAsync
	 *
	 * Alignable Goal Options
	 *
	 * @param  string $employee_id employeeId is the employee ID to get alignable goal options for. (required)
	 * @param  string|null $body Get alignment options including the option currently aligned with this goal (if applicable). If omitted, response will be alignment options belonging to the API user. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAlignmentOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalsAlignmentOptionsAsync($employee_id, $body = null, string $contentType = self::CONTENT_TYPES['getGoalsAlignmentOptions'][0]) {
		return $this->getGoalsAlignmentOptionsAsyncWithHttpInfo($employee_id, $body, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalsAlignmentOptionsAsyncWithHttpInfo
	 *
	 * Alignable Goal Options
	 *
	 * @param  string $employee_id employeeId is the employee ID to get alignable goal options for. (required)
	 * @param  string|null $body Get alignment options including the option currently aligned with this goal (if applicable). If omitted, response will be alignment options belonging to the API user. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAlignmentOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalsAlignmentOptionsAsyncWithHttpInfo($employee_id, $body = null, string $contentType = self::CONTENT_TYPES['getGoalsAlignmentOptions'][0]) {
		$returnType = '';
		$request = $this->getGoalsAlignmentOptionsRequest($employee_id, $body, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoalsAlignmentOptions'
	 *
	 * @param  string $employee_id employeeId is the employee ID to get alignable goal options for. (required)
	 * @param  string|null $body Get alignment options including the option currently aligned with this goal (if applicable). If omitted, response will be alignment options belonging to the API user. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsAlignmentOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getGoalsAlignmentOptionsRequest($employee_id, $body = null, string $contentType = self::CONTENT_TYPES['getGoalsAlignmentOptions'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoalsAlignmentOptions'
			);
		}



		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/alignmentOptions';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($body)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
			} else {
				$httpBody = $body;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoalsFiltersV1
	 *
	 * Get Goals Filters
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV1'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GoalFiltersV1
	 * @deprecated
	 */
	public function getGoalsFiltersV1($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV1'][0]) {
		list($response) = $this->getGoalsFiltersV1WithHttpInfo($employee_id, $contentType);
		return $response;
	}

	/**
	 * Operation getGoalsFiltersV1WithHttpInfo
	 *
	 * Get Goals Filters
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV1'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GoalFiltersV1, HTTP status code, HTTP response headers (array of strings)
	 * @deprecated
	 */
	public function getGoalsFiltersV1WithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV1'][0]) {
		$request = $this->getGoalsFiltersV1Request($employee_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GoalFiltersV1',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GoalFiltersV1',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GoalFiltersV1',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalsFiltersV1Async
	 *
	 * Get Goals Filters
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function getGoalsFiltersV1Async($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV1'][0]) {
		return $this->getGoalsFiltersV1AsyncWithHttpInfo($employee_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalsFiltersV1AsyncWithHttpInfo
	 *
	 * Get Goals Filters
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function getGoalsFiltersV1AsyncWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV1'][0]) {
		$returnType = '\BhrSdk\Model\GoalFiltersV1';
		$request = $this->getGoalsFiltersV1Request($employee_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoalsFiltersV1'
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 * @deprecated
	 */
	public function getGoalsFiltersV1Request($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV1'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoalsFiltersV1'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/filters';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoalsFiltersV11
	 *
	 * Get Goals Filters
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV11'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GoalFiltersV11
	 * @deprecated
	 */
	public function getGoalsFiltersV11($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV11'][0]) {
		list($response) = $this->getGoalsFiltersV11WithHttpInfo($employee_id, $contentType);
		return $response;
	}

	/**
	 * Operation getGoalsFiltersV11WithHttpInfo
	 *
	 * Get Goals Filters
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV11'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GoalFiltersV11, HTTP status code, HTTP response headers (array of strings)
	 * @deprecated
	 */
	public function getGoalsFiltersV11WithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV11'][0]) {
		$request = $this->getGoalsFiltersV11Request($employee_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GoalFiltersV11',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GoalFiltersV11',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GoalFiltersV11',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalsFiltersV11Async
	 *
	 * Get Goals Filters
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function getGoalsFiltersV11Async($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV11'][0]) {
		return $this->getGoalsFiltersV11AsyncWithHttpInfo($employee_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalsFiltersV11AsyncWithHttpInfo
	 *
	 * Get Goals Filters
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function getGoalsFiltersV11AsyncWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV11'][0]) {
		$returnType = '\BhrSdk\Model\GoalFiltersV11';
		$request = $this->getGoalsFiltersV11Request($employee_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoalsFiltersV11'
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 * @deprecated
	 */
	public function getGoalsFiltersV11Request($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV11'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoalsFiltersV11'
			);
		}


		$resourcePath = '/api/v1_1/performance/employees/{employeeId}/goals/filters';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoalsFiltersV12
	 *
	 * Get Goal Status Counts, Version 1.2
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV12'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GoalFiltersV11
	 */
	public function getGoalsFiltersV12($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV12'][0]) {
		list($response) = $this->getGoalsFiltersV12WithHttpInfo($employee_id, $contentType);
		return $response;
	}

	/**
	 * Operation getGoalsFiltersV12WithHttpInfo
	 *
	 * Get Goal Status Counts, Version 1.2
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV12'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GoalFiltersV11, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getGoalsFiltersV12WithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV12'][0]) {
		$request = $this->getGoalsFiltersV12Request($employee_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GoalFiltersV11',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GoalFiltersV11',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GoalFiltersV11',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalsFiltersV12Async
	 *
	 * Get Goal Status Counts, Version 1.2
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV12'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalsFiltersV12Async($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV12'][0]) {
		return $this->getGoalsFiltersV12AsyncWithHttpInfo($employee_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalsFiltersV12AsyncWithHttpInfo
	 *
	 * Get Goal Status Counts, Version 1.2
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV12'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalsFiltersV12AsyncWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV12'][0]) {
		$returnType = '\BhrSdk\Model\GoalFiltersV11';
		$request = $this->getGoalsFiltersV12Request($employee_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoalsFiltersV12'
	 *
	 * @param  int $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsFiltersV12'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getGoalsFiltersV12Request($employee_id, string $contentType = self::CONTENT_TYPES['getGoalsFiltersV12'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoalsFiltersV12'
			);
		}


		$resourcePath = '/api/v1_2/performance/employees/{employeeId}/goals/filters';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getGoalsShareOptions
	 *
	 * Available Goal Sharing Options
	 *
	 * @param  string $employee_id employeeId is the employee ID to get sharing options for. (required)
	 * @param  string|null $search The search term used to filter employees returned. Will search name, employee ID and email. (optional)
	 * @param  string|null $limit Limit will restrict results to specified number. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsShareOptions'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getGoalsShareOptions($employee_id, $search = null, $limit = null, string $contentType = self::CONTENT_TYPES['getGoalsShareOptions'][0]) {
		$this->getGoalsShareOptionsWithHttpInfo($employee_id, $search, $limit, $contentType);
	}

	/**
	 * Operation getGoalsShareOptionsWithHttpInfo
	 *
	 * Available Goal Sharing Options
	 *
	 * @param  string $employee_id employeeId is the employee ID to get sharing options for. (required)
	 * @param  string|null $search The search term used to filter employees returned. Will search name, employee ID and email. (optional)
	 * @param  string|null $limit Limit will restrict results to specified number. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsShareOptions'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getGoalsShareOptionsWithHttpInfo($employee_id, $search = null, $limit = null, string $contentType = self::CONTENT_TYPES['getGoalsShareOptions'][0]) {
		$request = $this->getGoalsShareOptionsRequest($employee_id, $search, $limit, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getGoalsShareOptionsAsync
	 *
	 * Available Goal Sharing Options
	 *
	 * @param  string $employee_id employeeId is the employee ID to get sharing options for. (required)
	 * @param  string|null $search The search term used to filter employees returned. Will search name, employee ID and email. (optional)
	 * @param  string|null $limit Limit will restrict results to specified number. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsShareOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalsShareOptionsAsync($employee_id, $search = null, $limit = null, string $contentType = self::CONTENT_TYPES['getGoalsShareOptions'][0]) {
		return $this->getGoalsShareOptionsAsyncWithHttpInfo($employee_id, $search, $limit, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getGoalsShareOptionsAsyncWithHttpInfo
	 *
	 * Available Goal Sharing Options
	 *
	 * @param  string $employee_id employeeId is the employee ID to get sharing options for. (required)
	 * @param  string|null $search The search term used to filter employees returned. Will search name, employee ID and email. (optional)
	 * @param  string|null $limit Limit will restrict results to specified number. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsShareOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getGoalsShareOptionsAsyncWithHttpInfo($employee_id, $search = null, $limit = null, string $contentType = self::CONTENT_TYPES['getGoalsShareOptions'][0]) {
		$returnType = '';
		$request = $this->getGoalsShareOptionsRequest($employee_id, $search, $limit, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getGoalsShareOptions'
	 *
	 * @param  string $employee_id employeeId is the employee ID to get sharing options for. (required)
	 * @param  string|null $search The search term used to filter employees returned. Will search name, employee ID and email. (optional)
	 * @param  string|null $limit Limit will restrict results to specified number. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getGoalsShareOptions'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getGoalsShareOptionsRequest($employee_id, $search = null, $limit = null, string $contentType = self::CONTENT_TYPES['getGoalsShareOptions'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling getGoalsShareOptions'
			);
		}




		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/shareOptions';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$search,
			'search', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$limit,
			'limit', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);


		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getHiringLeads
	 *
	 * Get Hiring Leads
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getHiringLeads'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetHiringLeads200ResponseInner[]
	 */
	public function getHiringLeads(string $contentType = self::CONTENT_TYPES['getHiringLeads'][0]) {
		list($response) = $this->getHiringLeadsWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation getHiringLeadsWithHttpInfo
	 *
	 * Get Hiring Leads
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getHiringLeads'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetHiringLeads200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
	 */
	public function getHiringLeadsWithHttpInfo(string $contentType = self::CONTENT_TYPES['getHiringLeads'][0]) {
		$request = $this->getHiringLeadsRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetHiringLeads200ResponseInner[]',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetHiringLeads200ResponseInner[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetHiringLeads200ResponseInner[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getHiringLeadsAsync
	 *
	 * Get Hiring Leads
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getHiringLeads'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getHiringLeadsAsync(string $contentType = self::CONTENT_TYPES['getHiringLeads'][0]) {
		return $this->getHiringLeadsAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getHiringLeadsAsyncWithHttpInfo
	 *
	 * Get Hiring Leads
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getHiringLeads'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getHiringLeadsAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getHiringLeads'][0]) {
		$returnType = '\BhrSdk\Model\GetHiringLeads200ResponseInner[]';
		$request = $this->getHiringLeadsRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getHiringLeads'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getHiringLeads'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getHiringLeadsRequest(string $contentType = self::CONTENT_TYPES['getHiringLeads'][0]) {


		$resourcePath = '/api/v1/applicant_tracking/hiring_leads';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getJobSummaries
	 *
	 * Get Job Summaries
	 *
	 * @param  string|null $status_groups A list of status groups to filter positions by. (optional)
	 * @param  string|null $sort_by A specific field to sort the results by. (optional)
	 * @param  string|null $sort_order Order by which to sort results. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getJobSummaries'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getJobSummaries($status_groups = null, $sort_by = null, $sort_order = null, string $contentType = self::CONTENT_TYPES['getJobSummaries'][0]) {
		$this->getJobSummariesWithHttpInfo($status_groups, $sort_by, $sort_order, $contentType);
	}

	/**
	 * Operation getJobSummariesWithHttpInfo
	 *
	 * Get Job Summaries
	 *
	 * @param  string|null $status_groups A list of status groups to filter positions by. (optional)
	 * @param  string|null $sort_by A specific field to sort the results by. (optional)
	 * @param  string|null $sort_order Order by which to sort results. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getJobSummaries'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getJobSummariesWithHttpInfo($status_groups = null, $sort_by = null, $sort_order = null, string $contentType = self::CONTENT_TYPES['getJobSummaries'][0]) {
		$request = $this->getJobSummariesRequest($status_groups, $sort_by, $sort_order, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getJobSummariesAsync
	 *
	 * Get Job Summaries
	 *
	 * @param  string|null $status_groups A list of status groups to filter positions by. (optional)
	 * @param  string|null $sort_by A specific field to sort the results by. (optional)
	 * @param  string|null $sort_order Order by which to sort results. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getJobSummaries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getJobSummariesAsync($status_groups = null, $sort_by = null, $sort_order = null, string $contentType = self::CONTENT_TYPES['getJobSummaries'][0]) {
		return $this->getJobSummariesAsyncWithHttpInfo($status_groups, $sort_by, $sort_order, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getJobSummariesAsyncWithHttpInfo
	 *
	 * Get Job Summaries
	 *
	 * @param  string|null $status_groups A list of status groups to filter positions by. (optional)
	 * @param  string|null $sort_by A specific field to sort the results by. (optional)
	 * @param  string|null $sort_order Order by which to sort results. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getJobSummaries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getJobSummariesAsyncWithHttpInfo($status_groups = null, $sort_by = null, $sort_order = null, string $contentType = self::CONTENT_TYPES['getJobSummaries'][0]) {
		$returnType = '';
		$request = $this->getJobSummariesRequest($status_groups, $sort_by, $sort_order, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getJobSummaries'
	 *
	 * @param  string|null $status_groups A list of status groups to filter positions by. (optional)
	 * @param  string|null $sort_by A specific field to sort the results by. (optional)
	 * @param  string|null $sort_order Order by which to sort results. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getJobSummaries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getJobSummariesRequest($status_groups = null, $sort_by = null, $sort_order = null, string $contentType = self::CONTENT_TYPES['getJobSummaries'][0]) {





		$resourcePath = '/api/v1/applicant_tracking/jobs';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$status_groups,
			'statusGroups', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$sort_by,
			'sortBy', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$sort_order,
			'sortOrder', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);




		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getListOfUsers
	 *
	 * Get a List of Users
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getListOfUsers'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getListOfUsers(string $contentType = self::CONTENT_TYPES['getListOfUsers'][0]) {
		$this->getListOfUsersWithHttpInfo($contentType);
	}

	/**
	 * Operation getListOfUsersWithHttpInfo
	 *
	 * Get a List of Users
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getListOfUsers'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getListOfUsersWithHttpInfo(string $contentType = self::CONTENT_TYPES['getListOfUsers'][0]) {
		$request = $this->getListOfUsersRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getListOfUsersAsync
	 *
	 * Get a List of Users
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getListOfUsers'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getListOfUsersAsync(string $contentType = self::CONTENT_TYPES['getListOfUsers'][0]) {
		return $this->getListOfUsersAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getListOfUsersAsyncWithHttpInfo
	 *
	 * Get a List of Users
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getListOfUsers'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getListOfUsersAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getListOfUsers'][0]) {
		$returnType = '';
		$request = $this->getListOfUsersRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getListOfUsers'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getListOfUsers'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getListOfUsersRequest(string $contentType = self::CONTENT_TYPES['getListOfUsers'][0]) {


		$resourcePath = '/api/v1/meta/users';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getMemberBenefit
	 *
	 * Get a list of member benefit events
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getMemberBenefit'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\MemberBenefitEvent[]
	 */
	public function getMemberBenefit(string $contentType = self::CONTENT_TYPES['getMemberBenefit'][0]) {
		list($response) = $this->getMemberBenefitWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation getMemberBenefitWithHttpInfo
	 *
	 * Get a list of member benefit events
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getMemberBenefit'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\MemberBenefitEvent[], HTTP status code, HTTP response headers (array of strings)
	 */
	public function getMemberBenefitWithHttpInfo(string $contentType = self::CONTENT_TYPES['getMemberBenefit'][0]) {
		$request = $this->getMemberBenefitRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\MemberBenefitEvent[]',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\MemberBenefitEvent[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\MemberBenefitEvent[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getMemberBenefitAsync
	 *
	 * Get a list of member benefit events
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getMemberBenefit'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getMemberBenefitAsync(string $contentType = self::CONTENT_TYPES['getMemberBenefit'][0]) {
		return $this->getMemberBenefitAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getMemberBenefitAsyncWithHttpInfo
	 *
	 * Get a list of member benefit events
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getMemberBenefit'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getMemberBenefitAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getMemberBenefit'][0]) {
		$returnType = '\BhrSdk\Model\MemberBenefitEvent[]';
		$request = $this->getMemberBenefitRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getMemberBenefit'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getMemberBenefit'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getMemberBenefitRequest(string $contentType = self::CONTENT_TYPES['getMemberBenefit'][0]) {


		$resourcePath = '/api/v1/benefit/member_benefit';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getMonitorFields
	 *
	 * Get monitor fields
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getMonitorFields'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetMonitorFields200Response|\BhrSdk\Model\WebhookError
	 */
	public function getMonitorFields(string $contentType = self::CONTENT_TYPES['getMonitorFields'][0]) {
		list($response) = $this->getMonitorFieldsWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation getMonitorFieldsWithHttpInfo
	 *
	 * Get monitor fields
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getMonitorFields'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetMonitorFields200Response|\BhrSdk\Model\WebhookError, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getMonitorFieldsWithHttpInfo(string $contentType = self::CONTENT_TYPES['getMonitorFields'][0]) {
		$request = $this->getMonitorFieldsRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetMonitorFields200Response',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetMonitorFields200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetMonitorFields200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getMonitorFieldsAsync
	 *
	 * Get monitor fields
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getMonitorFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getMonitorFieldsAsync(string $contentType = self::CONTENT_TYPES['getMonitorFields'][0]) {
		return $this->getMonitorFieldsAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getMonitorFieldsAsyncWithHttpInfo
	 *
	 * Get monitor fields
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getMonitorFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getMonitorFieldsAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getMonitorFields'][0]) {
		$returnType = '\BhrSdk\Model\GetMonitorFields200Response';
		$request = $this->getMonitorFieldsRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getMonitorFields'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getMonitorFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getMonitorFieldsRequest(string $contentType = self::CONTENT_TYPES['getMonitorFields'][0]) {


		$resourcePath = '/api/v1/webhooks/monitor_fields';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getStatesByCountryId
	 *
	 * Get states by country ID
	 *
	 * @param  int $country_id ID of the country to get states/provinces for (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getStatesByCountryId'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\StateProvinceResponseSchema
	 */
	public function getStatesByCountryId($country_id, string $contentType = self::CONTENT_TYPES['getStatesByCountryId'][0]) {
		list($response) = $this->getStatesByCountryIdWithHttpInfo($country_id, $contentType);
		return $response;
	}

	/**
	 * Operation getStatesByCountryIdWithHttpInfo
	 *
	 * Get states by country ID
	 *
	 * @param  int $country_id ID of the country to get states/provinces for (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getStatesByCountryId'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\StateProvinceResponseSchema, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getStatesByCountryIdWithHttpInfo($country_id, string $contentType = self::CONTENT_TYPES['getStatesByCountryId'][0]) {
		$request = $this->getStatesByCountryIdRequest($country_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\StateProvinceResponseSchema',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\StateProvinceResponseSchema',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\StateProvinceResponseSchema',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getStatesByCountryIdAsync
	 *
	 * Get states by country ID
	 *
	 * @param  int $country_id ID of the country to get states/provinces for (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getStatesByCountryId'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getStatesByCountryIdAsync($country_id, string $contentType = self::CONTENT_TYPES['getStatesByCountryId'][0]) {
		return $this->getStatesByCountryIdAsyncWithHttpInfo($country_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getStatesByCountryIdAsyncWithHttpInfo
	 *
	 * Get states by country ID
	 *
	 * @param  int $country_id ID of the country to get states/provinces for (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getStatesByCountryId'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getStatesByCountryIdAsyncWithHttpInfo($country_id, string $contentType = self::CONTENT_TYPES['getStatesByCountryId'][0]) {
		$returnType = '\BhrSdk\Model\StateProvinceResponseSchema';
		$request = $this->getStatesByCountryIdRequest($country_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getStatesByCountryId'
	 *
	 * @param  int $country_id ID of the country to get states/provinces for (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getStatesByCountryId'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getStatesByCountryIdRequest($country_id, string $contentType = self::CONTENT_TYPES['getStatesByCountryId'][0]) {

		// verify the required parameter 'country_id' is set
		if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $country_id when calling getStatesByCountryId'
			);
		}


		$resourcePath = '/api/v1/meta/provinces/{countryId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($country_id !== null) {
			$resourcePath = str_replace(
				'{' . 'countryId' . '}',
				ObjectSerializer::toPathValue($country_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getStatuses
	 *
	 * Get Statuses
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getStatuses'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getStatuses(string $contentType = self::CONTENT_TYPES['getStatuses'][0]) {
		$this->getStatusesWithHttpInfo($contentType);
	}

	/**
	 * Operation getStatusesWithHttpInfo
	 *
	 * Get Statuses
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getStatuses'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getStatusesWithHttpInfo(string $contentType = self::CONTENT_TYPES['getStatuses'][0]) {
		$request = $this->getStatusesRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getStatusesAsync
	 *
	 * Get Statuses
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getStatuses'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getStatusesAsync(string $contentType = self::CONTENT_TYPES['getStatuses'][0]) {
		return $this->getStatusesAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getStatusesAsyncWithHttpInfo
	 *
	 * Get Statuses
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getStatuses'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getStatusesAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getStatuses'][0]) {
		$returnType = '';
		$request = $this->getStatusesRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getStatuses'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getStatuses'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getStatusesRequest(string $contentType = self::CONTENT_TYPES['getStatuses'][0]) {


		$resourcePath = '/api/v1/applicant_tracking/statuses';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getTimeOffPolicies
	 *
	 * Get Time Off Policies
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeOffPolicies'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getTimeOffPolicies($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getTimeOffPolicies'][0]) {
		$this->getTimeOffPoliciesWithHttpInfo($accept_header_parameter, $contentType);
	}

	/**
	 * Operation getTimeOffPoliciesWithHttpInfo
	 *
	 * Get Time Off Policies
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeOffPolicies'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getTimeOffPoliciesWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getTimeOffPolicies'][0]) {
		$request = $this->getTimeOffPoliciesRequest($accept_header_parameter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getTimeOffPoliciesAsync
	 *
	 * Get Time Off Policies
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeOffPolicies'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getTimeOffPoliciesAsync($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getTimeOffPolicies'][0]) {
		return $this->getTimeOffPoliciesAsyncWithHttpInfo($accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getTimeOffPoliciesAsyncWithHttpInfo
	 *
	 * Get Time Off Policies
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeOffPolicies'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getTimeOffPoliciesAsyncWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getTimeOffPolicies'][0]) {
		$returnType = '';
		$request = $this->getTimeOffPoliciesRequest($accept_header_parameter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getTimeOffPolicies'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeOffPolicies'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getTimeOffPoliciesRequest($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getTimeOffPolicies'][0]) {



		$resourcePath = '/api/v1/meta/time_off/policies';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;


		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getTimeOffTypes
	 *
	 * Get Time Off Types
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $mode set to \\&#39;request\\&#39; to get a list of all time off types with which this user can create a time off request. The default is to return the list of time off types the user has permissions on. This distinction is important, as employees can request time off for types that they don\\&#39;t have permission to view balances and requests for. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeOffTypes'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function getTimeOffTypes($accept_header_parameter = null, $mode = null, string $contentType = self::CONTENT_TYPES['getTimeOffTypes'][0]) {
		$this->getTimeOffTypesWithHttpInfo($accept_header_parameter, $mode, $contentType);
	}

	/**
	 * Operation getTimeOffTypesWithHttpInfo
	 *
	 * Get Time Off Types
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $mode set to \\&#39;request\\&#39; to get a list of all time off types with which this user can create a time off request. The default is to return the list of time off types the user has permissions on. This distinction is important, as employees can request time off for types that they don\\&#39;t have permission to view balances and requests for. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeOffTypes'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getTimeOffTypesWithHttpInfo($accept_header_parameter = null, $mode = null, string $contentType = self::CONTENT_TYPES['getTimeOffTypes'][0]) {
		$request = $this->getTimeOffTypesRequest($accept_header_parameter, $mode, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getTimeOffTypesAsync
	 *
	 * Get Time Off Types
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $mode set to \\&#39;request\\&#39; to get a list of all time off types with which this user can create a time off request. The default is to return the list of time off types the user has permissions on. This distinction is important, as employees can request time off for types that they don\\&#39;t have permission to view balances and requests for. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeOffTypes'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getTimeOffTypesAsync($accept_header_parameter = null, $mode = null, string $contentType = self::CONTENT_TYPES['getTimeOffTypes'][0]) {
		return $this->getTimeOffTypesAsyncWithHttpInfo($accept_header_parameter, $mode, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getTimeOffTypesAsyncWithHttpInfo
	 *
	 * Get Time Off Types
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $mode set to \\&#39;request\\&#39; to get a list of all time off types with which this user can create a time off request. The default is to return the list of time off types the user has permissions on. This distinction is important, as employees can request time off for types that they don\\&#39;t have permission to view balances and requests for. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeOffTypes'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getTimeOffTypesAsyncWithHttpInfo($accept_header_parameter = null, $mode = null, string $contentType = self::CONTENT_TYPES['getTimeOffTypes'][0]) {
		$returnType = '';
		$request = $this->getTimeOffTypesRequest($accept_header_parameter, $mode, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getTimeOffTypes'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $mode set to \\&#39;request\\&#39; to get a list of all time off types with which this user can create a time off request. The default is to return the list of time off types the user has permissions on. This distinction is important, as employees can request time off for types that they don\\&#39;t have permission to view balances and requests for. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeOffTypes'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getTimeOffTypesRequest($accept_header_parameter = null, $mode = null, string $contentType = self::CONTENT_TYPES['getTimeOffTypes'][0]) {




		$resourcePath = '/api/v1/meta/time_off/types';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$mode,
			'mode', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);

		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getTimeTrackingRecord
	 *
	 * Get Hour Record
	 *
	 * @param  string $id {id} is the time tracking ID used to originally create the record. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeTrackingRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TimeTrackingRecordSchema|mixed
	 */
	public function getTimeTrackingRecord($id, string $contentType = self::CONTENT_TYPES['getTimeTrackingRecord'][0]) {
		list($response) = $this->getTimeTrackingRecordWithHttpInfo($id, $contentType);
		return $response;
	}

	/**
	 * Operation getTimeTrackingRecordWithHttpInfo
	 *
	 * Get Hour Record
	 *
	 * @param  string $id {id} is the time tracking ID used to originally create the record. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeTrackingRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TimeTrackingRecordSchema|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getTimeTrackingRecordWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['getTimeTrackingRecord'][0]) {
		$request = $this->getTimeTrackingRecordRequest($id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TimeTrackingRecordSchema',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TimeTrackingRecordSchema',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TimeTrackingRecordSchema',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getTimeTrackingRecordAsync
	 *
	 * Get Hour Record
	 *
	 * @param  string $id {id} is the time tracking ID used to originally create the record. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeTrackingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getTimeTrackingRecordAsync($id, string $contentType = self::CONTENT_TYPES['getTimeTrackingRecord'][0]) {
		return $this->getTimeTrackingRecordAsyncWithHttpInfo($id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getTimeTrackingRecordAsyncWithHttpInfo
	 *
	 * Get Hour Record
	 *
	 * @param  string $id {id} is the time tracking ID used to originally create the record. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeTrackingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getTimeTrackingRecordAsyncWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['getTimeTrackingRecord'][0]) {
		$returnType = '\BhrSdk\Model\TimeTrackingRecordSchema';
		$request = $this->getTimeTrackingRecordRequest($id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getTimeTrackingRecord'
	 *
	 * @param  string $id {id} is the time tracking ID used to originally create the record. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimeTrackingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getTimeTrackingRecordRequest($id, string $contentType = self::CONTENT_TYPES['getTimeTrackingRecord'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling getTimeTrackingRecord'
			);
		}


		$resourcePath = '/api/v1/timetracking/record/{id}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getTimesheetEntries
	 *
	 * Get Timesheet Entries
	 *
	 * @param  \DateTime $start YYYY-MM-DD. Only show timesheet entries on/after the specified start date. Must be within the last 365 days. (required)
	 * @param  \DateTime $end YYYY-MM-DD. Only show timesheet entries on/before the specified end date. Must be within the last 365 days. (required)
	 * @param  string|null $employee_ids A comma separated list of employee IDs. When specified, only entries that match these employee IDs are returned. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimesheetEntries'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\EmployeeTimesheetEntryTransformer[]|mixed|mixed|mixed|mixed
	 */
	public function getTimesheetEntries($start, $end, $employee_ids = null, string $contentType = self::CONTENT_TYPES['getTimesheetEntries'][0]) {
		list($response) = $this->getTimesheetEntriesWithHttpInfo($start, $end, $employee_ids, $contentType);
		return $response;
	}

	/**
	 * Operation getTimesheetEntriesWithHttpInfo
	 *
	 * Get Timesheet Entries
	 *
	 * @param  \DateTime $start YYYY-MM-DD. Only show timesheet entries on/after the specified start date. Must be within the last 365 days. (required)
	 * @param  \DateTime $end YYYY-MM-DD. Only show timesheet entries on/before the specified end date. Must be within the last 365 days. (required)
	 * @param  string|null $employee_ids A comma separated list of employee IDs. When specified, only entries that match these employee IDs are returned. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimesheetEntries'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\EmployeeTimesheetEntryTransformer[]|mixed|mixed|mixed|mixed, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getTimesheetEntriesWithHttpInfo($start, $end, $employee_ids = null, string $contentType = self::CONTENT_TYPES['getTimesheetEntries'][0]) {
		$request = $this->getTimesheetEntriesRequest($start, $end, $employee_ids, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\EmployeeTimesheetEntryTransformer[]',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 401:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'mixed',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\EmployeeTimesheetEntryTransformer[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\EmployeeTimesheetEntryTransformer[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 401:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'mixed',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getTimesheetEntriesAsync
	 *
	 * Get Timesheet Entries
	 *
	 * @param  \DateTime $start YYYY-MM-DD. Only show timesheet entries on/after the specified start date. Must be within the last 365 days. (required)
	 * @param  \DateTime $end YYYY-MM-DD. Only show timesheet entries on/before the specified end date. Must be within the last 365 days. (required)
	 * @param  string|null $employee_ids A comma separated list of employee IDs. When specified, only entries that match these employee IDs are returned. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimesheetEntries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getTimesheetEntriesAsync($start, $end, $employee_ids = null, string $contentType = self::CONTENT_TYPES['getTimesheetEntries'][0]) {
		return $this->getTimesheetEntriesAsyncWithHttpInfo($start, $end, $employee_ids, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getTimesheetEntriesAsyncWithHttpInfo
	 *
	 * Get Timesheet Entries
	 *
	 * @param  \DateTime $start YYYY-MM-DD. Only show timesheet entries on/after the specified start date. Must be within the last 365 days. (required)
	 * @param  \DateTime $end YYYY-MM-DD. Only show timesheet entries on/before the specified end date. Must be within the last 365 days. (required)
	 * @param  string|null $employee_ids A comma separated list of employee IDs. When specified, only entries that match these employee IDs are returned. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimesheetEntries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getTimesheetEntriesAsyncWithHttpInfo($start, $end, $employee_ids = null, string $contentType = self::CONTENT_TYPES['getTimesheetEntries'][0]) {
		$returnType = '\BhrSdk\Model\EmployeeTimesheetEntryTransformer[]';
		$request = $this->getTimesheetEntriesRequest($start, $end, $employee_ids, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getTimesheetEntries'
	 *
	 * @param  \DateTime $start YYYY-MM-DD. Only show timesheet entries on/after the specified start date. Must be within the last 365 days. (required)
	 * @param  \DateTime $end YYYY-MM-DD. Only show timesheet entries on/before the specified end date. Must be within the last 365 days. (required)
	 * @param  string|null $employee_ids A comma separated list of employee IDs. When specified, only entries that match these employee IDs are returned. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getTimesheetEntries'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getTimesheetEntriesRequest($start, $end, $employee_ids = null, string $contentType = self::CONTENT_TYPES['getTimesheetEntries'][0]) {

		// verify the required parameter 'start' is set
		if ($start === null || (is_array($start) && count($start) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $start when calling getTimesheetEntries'
			);
		}

		// verify the required parameter 'end' is set
		if ($end === null || (is_array($end) && count($end) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $end when calling getTimesheetEntries'
			);
		}

		if ($employee_ids !== null && !preg_match("/^\\d+(,\\d+)*$/", $employee_ids)) {
			throw new \InvalidArgumentException("invalid value for \"employee_ids\" when calling PublicAPIApi.getTimesheetEntries, must conform to the pattern /^\\d+(,\\d+)*$/.");
		}
		

		$resourcePath = '/api/v1/time_tracking/timesheet_entries';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$start,
			'start', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$end,
			'end', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$employee_ids,
			'employeeIds', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);




		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getWebhook
	 *
	 * Get Webhook
	 *
	 * @param  int $id The webhook ID to display details about. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhook'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\WebHookResponse|\BhrSdk\Model\WebhookError|\BhrSdk\Model\WebhookError|\BhrSdk\Model\WebhookError
	 */
	public function getWebhook($id, string $contentType = self::CONTENT_TYPES['getWebhook'][0]) {
		list($response) = $this->getWebhookWithHttpInfo($id, $contentType);
		return $response;
	}

	/**
	 * Operation getWebhookWithHttpInfo
	 *
	 * Get Webhook
	 *
	 * @param  int $id The webhook ID to display details about. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhook'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\WebHookResponse|\BhrSdk\Model\WebhookError|\BhrSdk\Model\WebhookError|\BhrSdk\Model\WebhookError, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getWebhookWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['getWebhook'][0]) {
		$request = $this->getWebhookRequest($id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebHookResponse',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
				case 404:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\WebHookResponse',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebHookResponse',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 404:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getWebhookAsync
	 *
	 * Get Webhook
	 *
	 * @param  int $id The webhook ID to display details about. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getWebhookAsync($id, string $contentType = self::CONTENT_TYPES['getWebhook'][0]) {
		return $this->getWebhookAsyncWithHttpInfo($id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getWebhookAsyncWithHttpInfo
	 *
	 * Get Webhook
	 *
	 * @param  int $id The webhook ID to display details about. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getWebhookAsyncWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['getWebhook'][0]) {
		$returnType = '\BhrSdk\Model\WebHookResponse';
		$request = $this->getWebhookRequest($id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getWebhook'
	 *
	 * @param  int $id The webhook ID to display details about. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getWebhookRequest($id, string $contentType = self::CONTENT_TYPES['getWebhook'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling getWebhook'
			);
		}


		$resourcePath = '/api/v1/webhooks/{id}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getWebhookList
	 *
	 * Gets as list of webhooks for the user API key.
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhookList'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetWebhookList200Response|\BhrSdk\Model\WebhookError
	 */
	public function getWebhookList(string $contentType = self::CONTENT_TYPES['getWebhookList'][0]) {
		list($response) = $this->getWebhookListWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation getWebhookListWithHttpInfo
	 *
	 * Gets as list of webhooks for the user API key.
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhookList'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetWebhookList200Response|\BhrSdk\Model\WebhookError, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getWebhookListWithHttpInfo(string $contentType = self::CONTENT_TYPES['getWebhookList'][0]) {
		$request = $this->getWebhookListRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\GetWebhookList200Response',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\GetWebhookList200Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\GetWebhookList200Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getWebhookListAsync
	 *
	 * Gets as list of webhooks for the user API key.
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhookList'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getWebhookListAsync(string $contentType = self::CONTENT_TYPES['getWebhookList'][0]) {
		return $this->getWebhookListAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getWebhookListAsyncWithHttpInfo
	 *
	 * Gets as list of webhooks for the user API key.
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhookList'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getWebhookListAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getWebhookList'][0]) {
		$returnType = '\BhrSdk\Model\GetWebhookList200Response';
		$request = $this->getWebhookListRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getWebhookList'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhookList'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getWebhookListRequest(string $contentType = self::CONTENT_TYPES['getWebhookList'][0]) {


		$resourcePath = '/api/v1/webhooks';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getWebhookLogs
	 *
	 * Get Webhook Logs
	 *
	 * @param  string $id The webhook ID to get logs about. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhookLogs'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\WebHookLogResponse|\BhrSdk\Model\WebhookError|\BhrSdk\Model\WebhookError|\BhrSdk\Model\WebhookError
	 */
	public function getWebhookLogs($id, string $contentType = self::CONTENT_TYPES['getWebhookLogs'][0]) {
		list($response) = $this->getWebhookLogsWithHttpInfo($id, $contentType);
		return $response;
	}

	/**
	 * Operation getWebhookLogsWithHttpInfo
	 *
	 * Get Webhook Logs
	 *
	 * @param  string $id The webhook ID to get logs about. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhookLogs'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\WebHookLogResponse|\BhrSdk\Model\WebhookError|\BhrSdk\Model\WebhookError|\BhrSdk\Model\WebhookError, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getWebhookLogsWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['getWebhookLogs'][0]) {
		$request = $this->getWebhookLogsRequest($id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebHookLogResponse',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
				case 404:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\WebHookLogResponse',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebHookLogResponse',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 404:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation getWebhookLogsAsync
	 *
	 * Get Webhook Logs
	 *
	 * @param  string $id The webhook ID to get logs about. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhookLogs'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getWebhookLogsAsync($id, string $contentType = self::CONTENT_TYPES['getWebhookLogs'][0]) {
		return $this->getWebhookLogsAsyncWithHttpInfo($id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getWebhookLogsAsyncWithHttpInfo
	 *
	 * Get Webhook Logs
	 *
	 * @param  string $id The webhook ID to get logs about. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhookLogs'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getWebhookLogsAsyncWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['getWebhookLogs'][0]) {
		$returnType = '\BhrSdk\Model\WebHookLogResponse';
		$request = $this->getWebhookLogsRequest($id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getWebhookLogs'
	 *
	 * @param  string $id The webhook ID to get logs about. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getWebhookLogs'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getWebhookLogsRequest($id, string $contentType = self::CONTENT_TYPES['getWebhookLogs'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling getWebhookLogs'
			);
		}


		$resourcePath = '/api/v1/webhooks/{id}/log';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation listCompanyFiles
	 *
	 * List company files and categories
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listCompanyFiles'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function listCompanyFiles(string $contentType = self::CONTENT_TYPES['listCompanyFiles'][0]) {
		$this->listCompanyFilesWithHttpInfo($contentType);
	}

	/**
	 * Operation listCompanyFilesWithHttpInfo
	 *
	 * List company files and categories
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listCompanyFiles'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function listCompanyFilesWithHttpInfo(string $contentType = self::CONTENT_TYPES['listCompanyFiles'][0]) {
		$request = $this->listCompanyFilesRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation listCompanyFilesAsync
	 *
	 * List company files and categories
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listCompanyFiles'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listCompanyFilesAsync(string $contentType = self::CONTENT_TYPES['listCompanyFiles'][0]) {
		return $this->listCompanyFilesAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation listCompanyFilesAsyncWithHttpInfo
	 *
	 * List company files and categories
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listCompanyFiles'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listCompanyFilesAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['listCompanyFiles'][0]) {
		$returnType = '';
		$request = $this->listCompanyFilesRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'listCompanyFiles'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listCompanyFiles'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function listCompanyFilesRequest(string $contentType = self::CONTENT_TYPES['listCompanyFiles'][0]) {


		$resourcePath = '/api/v1/files/view';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/xml', 'application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation listEmployeeFiles
	 *
	 * List employee files and categories
	 *
	 * @param  string $id Employee ID is required and needs to be a valid employee ID. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listEmployeeFiles'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function listEmployeeFiles($id, string $contentType = self::CONTENT_TYPES['listEmployeeFiles'][0]) {
		$this->listEmployeeFilesWithHttpInfo($id, $contentType);
	}

	/**
	 * Operation listEmployeeFilesWithHttpInfo
	 *
	 * List employee files and categories
	 *
	 * @param  string $id Employee ID is required and needs to be a valid employee ID. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listEmployeeFiles'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function listEmployeeFilesWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['listEmployeeFiles'][0]) {
		$request = $this->listEmployeeFilesRequest($id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation listEmployeeFilesAsync
	 *
	 * List employee files and categories
	 *
	 * @param  string $id Employee ID is required and needs to be a valid employee ID. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listEmployeeFiles'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listEmployeeFilesAsync($id, string $contentType = self::CONTENT_TYPES['listEmployeeFiles'][0]) {
		return $this->listEmployeeFilesAsyncWithHttpInfo($id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation listEmployeeFilesAsyncWithHttpInfo
	 *
	 * List employee files and categories
	 *
	 * @param  string $id Employee ID is required and needs to be a valid employee ID. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listEmployeeFiles'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listEmployeeFilesAsyncWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['listEmployeeFiles'][0]) {
		$returnType = '';
		$request = $this->listEmployeeFilesRequest($id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'listEmployeeFiles'
	 *
	 * @param  string $id Employee ID is required and needs to be a valid employee ID. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listEmployeeFiles'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function listEmployeeFilesRequest($id, string $contentType = self::CONTENT_TYPES['listEmployeeFiles'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling listEmployeeFiles'
			);
		}


		$resourcePath = '/api/v1/employees/{id}/files/view';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/xml', 'application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation listEmployeeTrainings
	 *
	 * List Employee Trainings
	 *
	 * @param  int $employee_id The ID of the employee to get a list of trainings for. (required)
	 * @param  int|null $training_type_id The training type id is optional. Not supplying a training type id will return the collection of all training records for the employee. (optional, default to 0)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listEmployeeTrainings'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\ListEmployeeTrainings200ResponseInner[]
	 */
	public function listEmployeeTrainings($employee_id, $training_type_id = 0, string $contentType = self::CONTENT_TYPES['listEmployeeTrainings'][0]) {
		list($response) = $this->listEmployeeTrainingsWithHttpInfo($employee_id, $training_type_id, $contentType);
		return $response;
	}

	/**
	 * Operation listEmployeeTrainingsWithHttpInfo
	 *
	 * List Employee Trainings
	 *
	 * @param  int $employee_id The ID of the employee to get a list of trainings for. (required)
	 * @param  int|null $training_type_id The training type id is optional. Not supplying a training type id will return the collection of all training records for the employee. (optional, default to 0)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listEmployeeTrainings'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\ListEmployeeTrainings200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
	 */
	public function listEmployeeTrainingsWithHttpInfo($employee_id, $training_type_id = 0, string $contentType = self::CONTENT_TYPES['listEmployeeTrainings'][0]) {
		$request = $this->listEmployeeTrainingsRequest($employee_id, $training_type_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\ListEmployeeTrainings200ResponseInner[]',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\ListEmployeeTrainings200ResponseInner[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\ListEmployeeTrainings200ResponseInner[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation listEmployeeTrainingsAsync
	 *
	 * List Employee Trainings
	 *
	 * @param  int $employee_id The ID of the employee to get a list of trainings for. (required)
	 * @param  int|null $training_type_id The training type id is optional. Not supplying a training type id will return the collection of all training records for the employee. (optional, default to 0)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listEmployeeTrainings'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listEmployeeTrainingsAsync($employee_id, $training_type_id = 0, string $contentType = self::CONTENT_TYPES['listEmployeeTrainings'][0]) {
		return $this->listEmployeeTrainingsAsyncWithHttpInfo($employee_id, $training_type_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation listEmployeeTrainingsAsyncWithHttpInfo
	 *
	 * List Employee Trainings
	 *
	 * @param  int $employee_id The ID of the employee to get a list of trainings for. (required)
	 * @param  int|null $training_type_id The training type id is optional. Not supplying a training type id will return the collection of all training records for the employee. (optional, default to 0)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listEmployeeTrainings'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listEmployeeTrainingsAsyncWithHttpInfo($employee_id, $training_type_id = 0, string $contentType = self::CONTENT_TYPES['listEmployeeTrainings'][0]) {
		$returnType = '\BhrSdk\Model\ListEmployeeTrainings200ResponseInner[]';
		$request = $this->listEmployeeTrainingsRequest($employee_id, $training_type_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'listEmployeeTrainings'
	 *
	 * @param  int $employee_id The ID of the employee to get a list of trainings for. (required)
	 * @param  int|null $training_type_id The training type id is optional. Not supplying a training type id will return the collection of all training records for the employee. (optional, default to 0)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listEmployeeTrainings'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function listEmployeeTrainingsRequest($employee_id, $training_type_id = 0, string $contentType = self::CONTENT_TYPES['listEmployeeTrainings'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling listEmployeeTrainings'
			);
		}



		$resourcePath = '/api/v1/training/record/employee/{employeeId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$training_type_id,
			'trainingTypeId', // param base name
			'integer', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);


		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation listReports
	 *
	 * List Reports
	 *
	 * @param  int|null $page The page number to retrieve (optional)
	 * @param  int|null $page_size The number of records to retrieve per page. Default is 500 and the Max is 1000 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listReports'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\ReportsResponse
	 */
	public function listReports($page = null, $page_size = null, string $contentType = self::CONTENT_TYPES['listReports'][0]) {
		list($response) = $this->listReportsWithHttpInfo($page, $page_size, $contentType);
		return $response;
	}

	/**
	 * Operation listReportsWithHttpInfo
	 *
	 * List Reports
	 *
	 * @param  int|null $page The page number to retrieve (optional)
	 * @param  int|null $page_size The number of records to retrieve per page. Default is 500 and the Max is 1000 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listReports'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\ReportsResponse, HTTP status code, HTTP response headers (array of strings)
	 */
	public function listReportsWithHttpInfo($page = null, $page_size = null, string $contentType = self::CONTENT_TYPES['listReports'][0]) {
		$request = $this->listReportsRequest($page, $page_size, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\ReportsResponse',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\ReportsResponse',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\ReportsResponse',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation listReportsAsync
	 *
	 * List Reports
	 *
	 * @param  int|null $page The page number to retrieve (optional)
	 * @param  int|null $page_size The number of records to retrieve per page. Default is 500 and the Max is 1000 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listReports'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listReportsAsync($page = null, $page_size = null, string $contentType = self::CONTENT_TYPES['listReports'][0]) {
		return $this->listReportsAsyncWithHttpInfo($page, $page_size, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation listReportsAsyncWithHttpInfo
	 *
	 * List Reports
	 *
	 * @param  int|null $page The page number to retrieve (optional)
	 * @param  int|null $page_size The number of records to retrieve per page. Default is 500 and the Max is 1000 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listReports'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listReportsAsyncWithHttpInfo($page = null, $page_size = null, string $contentType = self::CONTENT_TYPES['listReports'][0]) {
		$returnType = '\BhrSdk\Model\ReportsResponse';
		$request = $this->listReportsRequest($page, $page_size, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'listReports'
	 *
	 * @param  int|null $page The page number to retrieve (optional)
	 * @param  int|null $page_size The number of records to retrieve per page. Default is 500 and the Max is 1000 (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listReports'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function listReportsRequest($page = null, $page_size = null, string $contentType = self::CONTENT_TYPES['listReports'][0]) {




		$resourcePath = '/api/v1/custom-reports';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$page,
			'page', // param base name
			'integer', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$page_size,
			'page_size', // param base name
			'integer', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);




		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation listTrainingCategories
	 *
	 * List Training Categories
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listTrainingCategories'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\ListTrainingCategories200ResponseInner[]
	 */
	public function listTrainingCategories(string $contentType = self::CONTENT_TYPES['listTrainingCategories'][0]) {
		list($response) = $this->listTrainingCategoriesWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation listTrainingCategoriesWithHttpInfo
	 *
	 * List Training Categories
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listTrainingCategories'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\ListTrainingCategories200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
	 */
	public function listTrainingCategoriesWithHttpInfo(string $contentType = self::CONTENT_TYPES['listTrainingCategories'][0]) {
		$request = $this->listTrainingCategoriesRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\ListTrainingCategories200ResponseInner[]',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\ListTrainingCategories200ResponseInner[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\ListTrainingCategories200ResponseInner[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation listTrainingCategoriesAsync
	 *
	 * List Training Categories
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listTrainingCategories'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listTrainingCategoriesAsync(string $contentType = self::CONTENT_TYPES['listTrainingCategories'][0]) {
		return $this->listTrainingCategoriesAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation listTrainingCategoriesAsyncWithHttpInfo
	 *
	 * List Training Categories
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listTrainingCategories'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listTrainingCategoriesAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['listTrainingCategories'][0]) {
		$returnType = '\BhrSdk\Model\ListTrainingCategories200ResponseInner[]';
		$request = $this->listTrainingCategoriesRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'listTrainingCategories'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listTrainingCategories'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function listTrainingCategoriesRequest(string $contentType = self::CONTENT_TYPES['listTrainingCategories'][0]) {


		$resourcePath = '/api/v1/training/category';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation listTrainingTypes
	 *
	 * List Training Types
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listTrainingTypes'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\ListTrainingTypes200ResponseInner[]
	 */
	public function listTrainingTypes(string $contentType = self::CONTENT_TYPES['listTrainingTypes'][0]) {
		list($response) = $this->listTrainingTypesWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation listTrainingTypesWithHttpInfo
	 *
	 * List Training Types
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listTrainingTypes'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\ListTrainingTypes200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
	 */
	public function listTrainingTypesWithHttpInfo(string $contentType = self::CONTENT_TYPES['listTrainingTypes'][0]) {
		$request = $this->listTrainingTypesRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\ListTrainingTypes200ResponseInner[]',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\ListTrainingTypes200ResponseInner[]',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\ListTrainingTypes200ResponseInner[]',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation listTrainingTypesAsync
	 *
	 * List Training Types
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listTrainingTypes'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listTrainingTypesAsync(string $contentType = self::CONTENT_TYPES['listTrainingTypes'][0]) {
		return $this->listTrainingTypesAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation listTrainingTypesAsyncWithHttpInfo
	 *
	 * List Training Types
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listTrainingTypes'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function listTrainingTypesAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['listTrainingTypes'][0]) {
		$returnType = '\BhrSdk\Model\ListTrainingTypes200ResponseInner[]';
		$request = $this->listTrainingTypesRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'listTrainingTypes'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['listTrainingTypes'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function listTrainingTypesRequest(string $contentType = self::CONTENT_TYPES['listTrainingTypes'][0]) {


		$resourcePath = '/api/v1/training/type';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation login
	 *
	 * User Login
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $application_key application_key (optional)
	 * @param  string|null $user user (optional)
	 * @param  string|null $password password (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['login'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 * @deprecated
	 */
	public function login($accept_header_parameter = null, $application_key = null, $user = null, $password = null, string $contentType = self::CONTENT_TYPES['login'][0]) {
		$this->loginWithHttpInfo($accept_header_parameter, $application_key, $user, $password, $contentType);
	}

	/**
	 * Operation loginWithHttpInfo
	 *
	 * User Login
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $application_key (optional)
	 * @param  string|null $user (optional)
	 * @param  string|null $password (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['login'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 * @deprecated
	 */
	public function loginWithHttpInfo($accept_header_parameter = null, $application_key = null, $user = null, $password = null, string $contentType = self::CONTENT_TYPES['login'][0]) {
		$request = $this->loginRequest($accept_header_parameter, $application_key, $user, $password, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation loginAsync
	 *
	 * User Login
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $application_key (optional)
	 * @param  string|null $user (optional)
	 * @param  string|null $password (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['login'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function loginAsync($accept_header_parameter = null, $application_key = null, $user = null, $password = null, string $contentType = self::CONTENT_TYPES['login'][0]) {
		return $this->loginAsyncWithHttpInfo($accept_header_parameter, $application_key, $user, $password, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation loginAsyncWithHttpInfo
	 *
	 * User Login
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $application_key (optional)
	 * @param  string|null $user (optional)
	 * @param  string|null $password (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['login'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function loginAsyncWithHttpInfo($accept_header_parameter = null, $application_key = null, $user = null, $password = null, string $contentType = self::CONTENT_TYPES['login'][0]) {
		$returnType = '';
		$request = $this->loginRequest($accept_header_parameter, $application_key, $user, $password, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'login'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string|null $application_key (optional)
	 * @param  string|null $user (optional)
	 * @param  string|null $password (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['login'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 * @deprecated
	 */
	public function loginRequest($accept_header_parameter = null, $application_key = null, $user = null, $password = null, string $contentType = self::CONTENT_TYPES['login'][0]) {






		$resourcePath = '/api/v1/login';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;


		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}


		// form params
		$formDataProcessor = new FormDataProcessor();

		$formData = $formDataProcessor->prepare([
			'application_key' => $application_key,
			'user' => $user,
			'password' => $password,
		]);

		$formParams = $formDataProcessor->flatten($formData);
		$multipart = $formDataProcessor->has_file;

		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation metadataAddOrUpdateValuesForListFields
	 *
	 * Add or Update Values for List Fields
	 *
	 * @param  string $list_field_id list_field_id (required)
	 * @param  \BhrSdk\Model\ListFieldValues $list_field_values list_field_values (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataAddOrUpdateValuesForListFields'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function metadataAddOrUpdateValuesForListFields($list_field_id, $list_field_values, string $contentType = self::CONTENT_TYPES['metadataAddOrUpdateValuesForListFields'][0]) {
		$this->metadataAddOrUpdateValuesForListFieldsWithHttpInfo($list_field_id, $list_field_values, $contentType);
	}

	/**
	 * Operation metadataAddOrUpdateValuesForListFieldsWithHttpInfo
	 *
	 * Add or Update Values for List Fields
	 *
	 * @param  string $list_field_id (required)
	 * @param  \BhrSdk\Model\ListFieldValues $list_field_values (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataAddOrUpdateValuesForListFields'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function metadataAddOrUpdateValuesForListFieldsWithHttpInfo($list_field_id, $list_field_values, string $contentType = self::CONTENT_TYPES['metadataAddOrUpdateValuesForListFields'][0]) {
		$request = $this->metadataAddOrUpdateValuesForListFieldsRequest($list_field_id, $list_field_values, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation metadataAddOrUpdateValuesForListFieldsAsync
	 *
	 * Add or Update Values for List Fields
	 *
	 * @param  string $list_field_id (required)
	 * @param  \BhrSdk\Model\ListFieldValues $list_field_values (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataAddOrUpdateValuesForListFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function metadataAddOrUpdateValuesForListFieldsAsync($list_field_id, $list_field_values, string $contentType = self::CONTENT_TYPES['metadataAddOrUpdateValuesForListFields'][0]) {
		return $this->metadataAddOrUpdateValuesForListFieldsAsyncWithHttpInfo($list_field_id, $list_field_values, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation metadataAddOrUpdateValuesForListFieldsAsyncWithHttpInfo
	 *
	 * Add or Update Values for List Fields
	 *
	 * @param  string $list_field_id (required)
	 * @param  \BhrSdk\Model\ListFieldValues $list_field_values (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataAddOrUpdateValuesForListFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function metadataAddOrUpdateValuesForListFieldsAsyncWithHttpInfo($list_field_id, $list_field_values, string $contentType = self::CONTENT_TYPES['metadataAddOrUpdateValuesForListFields'][0]) {
		$returnType = '';
		$request = $this->metadataAddOrUpdateValuesForListFieldsRequest($list_field_id, $list_field_values, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'metadataAddOrUpdateValuesForListFields'
	 *
	 * @param  string $list_field_id (required)
	 * @param  \BhrSdk\Model\ListFieldValues $list_field_values (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataAddOrUpdateValuesForListFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function metadataAddOrUpdateValuesForListFieldsRequest($list_field_id, $list_field_values, string $contentType = self::CONTENT_TYPES['metadataAddOrUpdateValuesForListFields'][0]) {

		// verify the required parameter 'list_field_id' is set
		if ($list_field_id === null || (is_array($list_field_id) && count($list_field_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $list_field_id when calling metadataAddOrUpdateValuesForListFields'
			);
		}

		// verify the required parameter 'list_field_values' is set
		if ($list_field_values === null || (is_array($list_field_values) && count($list_field_values) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $list_field_values when calling metadataAddOrUpdateValuesForListFields'
			);
		}


		$resourcePath = '/api/v1/meta/lists/{listFieldId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($list_field_id !== null) {
			$resourcePath = str_replace(
				'{' . 'listFieldId' . '}',
				ObjectSerializer::toPathValue($list_field_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/xml', 'application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($list_field_values)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($list_field_values));
			} else {
				$httpBody = $list_field_values;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation metadataGetAListOfFields
	 *
	 * Get a list of fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetAListOfFields'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function metadataGetAListOfFields($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetAListOfFields'][0]) {
		$this->metadataGetAListOfFieldsWithHttpInfo($accept_header_parameter, $contentType);
	}

	/**
	 * Operation metadataGetAListOfFieldsWithHttpInfo
	 *
	 * Get a list of fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetAListOfFields'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function metadataGetAListOfFieldsWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetAListOfFields'][0]) {
		$request = $this->metadataGetAListOfFieldsRequest($accept_header_parameter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation metadataGetAListOfFieldsAsync
	 *
	 * Get a list of fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetAListOfFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function metadataGetAListOfFieldsAsync($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetAListOfFields'][0]) {
		return $this->metadataGetAListOfFieldsAsyncWithHttpInfo($accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation metadataGetAListOfFieldsAsyncWithHttpInfo
	 *
	 * Get a list of fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetAListOfFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function metadataGetAListOfFieldsAsyncWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetAListOfFields'][0]) {
		$returnType = '';
		$request = $this->metadataGetAListOfFieldsRequest($accept_header_parameter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'metadataGetAListOfFields'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetAListOfFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function metadataGetAListOfFieldsRequest($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetAListOfFields'][0]) {



		$resourcePath = '/api/v1/meta/fields';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;


		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation metadataGetAListOfTabularFields
	 *
	 * Get a list of tabular fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetAListOfTabularFields'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function metadataGetAListOfTabularFields($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetAListOfTabularFields'][0]) {
		$this->metadataGetAListOfTabularFieldsWithHttpInfo($accept_header_parameter, $contentType);
	}

	/**
	 * Operation metadataGetAListOfTabularFieldsWithHttpInfo
	 *
	 * Get a list of tabular fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetAListOfTabularFields'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function metadataGetAListOfTabularFieldsWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetAListOfTabularFields'][0]) {
		$request = $this->metadataGetAListOfTabularFieldsRequest($accept_header_parameter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation metadataGetAListOfTabularFieldsAsync
	 *
	 * Get a list of tabular fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetAListOfTabularFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function metadataGetAListOfTabularFieldsAsync($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetAListOfTabularFields'][0]) {
		return $this->metadataGetAListOfTabularFieldsAsyncWithHttpInfo($accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation metadataGetAListOfTabularFieldsAsyncWithHttpInfo
	 *
	 * Get a list of tabular fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetAListOfTabularFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function metadataGetAListOfTabularFieldsAsyncWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetAListOfTabularFields'][0]) {
		$returnType = '';
		$request = $this->metadataGetAListOfTabularFieldsRequest($accept_header_parameter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'metadataGetAListOfTabularFields'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetAListOfTabularFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function metadataGetAListOfTabularFieldsRequest($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetAListOfTabularFields'][0]) {



		$resourcePath = '/api/v1/meta/tables';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;


		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation metadataGetDetailsForListFields
	 *
	 * Get details for list fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetDetailsForListFields'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function metadataGetDetailsForListFields($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetDetailsForListFields'][0]) {
		$this->metadataGetDetailsForListFieldsWithHttpInfo($accept_header_parameter, $contentType);
	}

	/**
	 * Operation metadataGetDetailsForListFieldsWithHttpInfo
	 *
	 * Get details for list fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetDetailsForListFields'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function metadataGetDetailsForListFieldsWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetDetailsForListFields'][0]) {
		$request = $this->metadataGetDetailsForListFieldsRequest($accept_header_parameter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation metadataGetDetailsForListFieldsAsync
	 *
	 * Get details for list fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetDetailsForListFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function metadataGetDetailsForListFieldsAsync($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetDetailsForListFields'][0]) {
		return $this->metadataGetDetailsForListFieldsAsyncWithHttpInfo($accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation metadataGetDetailsForListFieldsAsyncWithHttpInfo
	 *
	 * Get details for list fields
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetDetailsForListFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function metadataGetDetailsForListFieldsAsyncWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetDetailsForListFields'][0]) {
		$returnType = '';
		$request = $this->metadataGetDetailsForListFieldsRequest($accept_header_parameter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'metadataGetDetailsForListFields'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['metadataGetDetailsForListFields'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function metadataGetDetailsForListFieldsRequest($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['metadataGetDetailsForListFields'][0]) {



		$resourcePath = '/api/v1/meta/lists';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;


		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation postApplicantStatus
	 *
	 * Change Applicant&#39;s Status
	 *
	 * @param  int $application_id The ID of the application to add a comment to. (required)
	 * @param  \BhrSdk\Model\PostApplicantStatusRequest $post_applicant_status_request Sample Post Data. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postApplicantStatus'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function postApplicantStatus($application_id, $post_applicant_status_request, string $contentType = self::CONTENT_TYPES['postApplicantStatus'][0]) {
		$this->postApplicantStatusWithHttpInfo($application_id, $post_applicant_status_request, $contentType);
	}

	/**
	 * Operation postApplicantStatusWithHttpInfo
	 *
	 * Change Applicant&#39;s Status
	 *
	 * @param  int $application_id The ID of the application to add a comment to. (required)
	 * @param  \BhrSdk\Model\PostApplicantStatusRequest $post_applicant_status_request Sample Post Data. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postApplicantStatus'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function postApplicantStatusWithHttpInfo($application_id, $post_applicant_status_request, string $contentType = self::CONTENT_TYPES['postApplicantStatus'][0]) {
		$request = $this->postApplicantStatusRequest($application_id, $post_applicant_status_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation postApplicantStatusAsync
	 *
	 * Change Applicant&#39;s Status
	 *
	 * @param  int $application_id The ID of the application to add a comment to. (required)
	 * @param  \BhrSdk\Model\PostApplicantStatusRequest $post_applicant_status_request Sample Post Data. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postApplicantStatus'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postApplicantStatusAsync($application_id, $post_applicant_status_request, string $contentType = self::CONTENT_TYPES['postApplicantStatus'][0]) {
		return $this->postApplicantStatusAsyncWithHttpInfo($application_id, $post_applicant_status_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation postApplicantStatusAsyncWithHttpInfo
	 *
	 * Change Applicant&#39;s Status
	 *
	 * @param  int $application_id The ID of the application to add a comment to. (required)
	 * @param  \BhrSdk\Model\PostApplicantStatusRequest $post_applicant_status_request Sample Post Data. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postApplicantStatus'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postApplicantStatusAsyncWithHttpInfo($application_id, $post_applicant_status_request, string $contentType = self::CONTENT_TYPES['postApplicantStatus'][0]) {
		$returnType = '';
		$request = $this->postApplicantStatusRequest($application_id, $post_applicant_status_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'postApplicantStatus'
	 *
	 * @param  int $application_id The ID of the application to add a comment to. (required)
	 * @param  \BhrSdk\Model\PostApplicantStatusRequest $post_applicant_status_request Sample Post Data. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postApplicantStatus'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function postApplicantStatusRequest($application_id, $post_applicant_status_request, string $contentType = self::CONTENT_TYPES['postApplicantStatus'][0]) {

		// verify the required parameter 'application_id' is set
		if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $application_id when calling postApplicantStatus'
			);
		}

		// verify the required parameter 'post_applicant_status_request' is set
		if ($post_applicant_status_request === null || (is_array($post_applicant_status_request) && count($post_applicant_status_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $post_applicant_status_request when calling postApplicantStatus'
			);
		}


		$resourcePath = '/api/v1/applicant_tracking/applications/{applicationId}/status';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($application_id !== null) {
			$resourcePath = str_replace(
				'{' . 'applicationId' . '}',
				ObjectSerializer::toPathValue($application_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($post_applicant_status_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_applicant_status_request));
			} else {
				$httpBody = $post_applicant_status_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation postApplicationComment
	 *
	 * Add Application Comment
	 *
	 * @param  int $application_id The ID of the application to add a comment to. (required)
	 * @param  \BhrSdk\Model\PostApplicationCommentRequest $post_application_comment_request Comment object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postApplicationComment'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function postApplicationComment($application_id, $post_application_comment_request, string $contentType = self::CONTENT_TYPES['postApplicationComment'][0]) {
		$this->postApplicationCommentWithHttpInfo($application_id, $post_application_comment_request, $contentType);
	}

	/**
	 * Operation postApplicationCommentWithHttpInfo
	 *
	 * Add Application Comment
	 *
	 * @param  int $application_id The ID of the application to add a comment to. (required)
	 * @param  \BhrSdk\Model\PostApplicationCommentRequest $post_application_comment_request Comment object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postApplicationComment'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function postApplicationCommentWithHttpInfo($application_id, $post_application_comment_request, string $contentType = self::CONTENT_TYPES['postApplicationComment'][0]) {
		$request = $this->postApplicationCommentRequest($application_id, $post_application_comment_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation postApplicationCommentAsync
	 *
	 * Add Application Comment
	 *
	 * @param  int $application_id The ID of the application to add a comment to. (required)
	 * @param  \BhrSdk\Model\PostApplicationCommentRequest $post_application_comment_request Comment object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postApplicationComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postApplicationCommentAsync($application_id, $post_application_comment_request, string $contentType = self::CONTENT_TYPES['postApplicationComment'][0]) {
		return $this->postApplicationCommentAsyncWithHttpInfo($application_id, $post_application_comment_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation postApplicationCommentAsyncWithHttpInfo
	 *
	 * Add Application Comment
	 *
	 * @param  int $application_id The ID of the application to add a comment to. (required)
	 * @param  \BhrSdk\Model\PostApplicationCommentRequest $post_application_comment_request Comment object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postApplicationComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postApplicationCommentAsyncWithHttpInfo($application_id, $post_application_comment_request, string $contentType = self::CONTENT_TYPES['postApplicationComment'][0]) {
		$returnType = '';
		$request = $this->postApplicationCommentRequest($application_id, $post_application_comment_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'postApplicationComment'
	 *
	 * @param  int $application_id The ID of the application to add a comment to. (required)
	 * @param  \BhrSdk\Model\PostApplicationCommentRequest $post_application_comment_request Comment object to post (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postApplicationComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function postApplicationCommentRequest($application_id, $post_application_comment_request, string $contentType = self::CONTENT_TYPES['postApplicationComment'][0]) {

		// verify the required parameter 'application_id' is set
		if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $application_id when calling postApplicationComment'
			);
		}

		// verify the required parameter 'post_application_comment_request' is set
		if ($post_application_comment_request === null || (is_array($post_application_comment_request) && count($post_application_comment_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $post_application_comment_request when calling postApplicationComment'
			);
		}


		$resourcePath = '/api/v1/applicant_tracking/applications/{applicationId}/comments';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($application_id !== null) {
			$resourcePath = str_replace(
				'{' . 'applicationId' . '}',
				ObjectSerializer::toPathValue($application_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($post_application_comment_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_application_comment_request));
			} else {
				$httpBody = $post_application_comment_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation postCloseGoal
	 *
	 * Close Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string|null $body Comment field is optional. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postCloseGoal'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TransformedApiGoal
	 */
	public function postCloseGoal($employee_id, $goal_id, $body = null, string $contentType = self::CONTENT_TYPES['postCloseGoal'][0]) {
		list($response) = $this->postCloseGoalWithHttpInfo($employee_id, $goal_id, $body, $contentType);
		return $response;
	}

	/**
	 * Operation postCloseGoalWithHttpInfo
	 *
	 * Close Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string|null $body Comment field is optional. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postCloseGoal'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TransformedApiGoal, HTTP status code, HTTP response headers (array of strings)
	 */
	public function postCloseGoalWithHttpInfo($employee_id, $goal_id, $body = null, string $contentType = self::CONTENT_TYPES['postCloseGoal'][0]) {
		$request = $this->postCloseGoalRequest($employee_id, $goal_id, $body, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TransformedApiGoal',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TransformedApiGoal',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TransformedApiGoal',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation postCloseGoalAsync
	 *
	 * Close Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string|null $body Comment field is optional. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postCloseGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postCloseGoalAsync($employee_id, $goal_id, $body = null, string $contentType = self::CONTENT_TYPES['postCloseGoal'][0]) {
		return $this->postCloseGoalAsyncWithHttpInfo($employee_id, $goal_id, $body, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation postCloseGoalAsyncWithHttpInfo
	 *
	 * Close Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string|null $body Comment field is optional. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postCloseGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postCloseGoalAsyncWithHttpInfo($employee_id, $goal_id, $body = null, string $contentType = self::CONTENT_TYPES['postCloseGoal'][0]) {
		$returnType = '\BhrSdk\Model\TransformedApiGoal';
		$request = $this->postCloseGoalRequest($employee_id, $goal_id, $body, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'postCloseGoal'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string|null $body Comment field is optional. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postCloseGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function postCloseGoalRequest($employee_id, $goal_id, $body = null, string $contentType = self::CONTENT_TYPES['postCloseGoal'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling postCloseGoal'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling postCloseGoal'
			);
		}



		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}/close';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($body)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
			} else {
				$httpBody = $body;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation postGoal
	 *
	 * Create Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  \BhrSdk\Model\PostGoalRequest $post_goal_request post_goal_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postGoal'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TransformedApiGoal
	 */
	public function postGoal($employee_id, $post_goal_request, string $contentType = self::CONTENT_TYPES['postGoal'][0]) {
		list($response) = $this->postGoalWithHttpInfo($employee_id, $post_goal_request, $contentType);
		return $response;
	}

	/**
	 * Operation postGoalWithHttpInfo
	 *
	 * Create Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  \BhrSdk\Model\PostGoalRequest $post_goal_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postGoal'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TransformedApiGoal, HTTP status code, HTTP response headers (array of strings)
	 */
	public function postGoalWithHttpInfo($employee_id, $post_goal_request, string $contentType = self::CONTENT_TYPES['postGoal'][0]) {
		$request = $this->postGoalRequest($employee_id, $post_goal_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TransformedApiGoal',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TransformedApiGoal',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TransformedApiGoal',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation postGoalAsync
	 *
	 * Create Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  \BhrSdk\Model\PostGoalRequest $post_goal_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postGoalAsync($employee_id, $post_goal_request, string $contentType = self::CONTENT_TYPES['postGoal'][0]) {
		return $this->postGoalAsyncWithHttpInfo($employee_id, $post_goal_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation postGoalAsyncWithHttpInfo
	 *
	 * Create Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  \BhrSdk\Model\PostGoalRequest $post_goal_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postGoalAsyncWithHttpInfo($employee_id, $post_goal_request, string $contentType = self::CONTENT_TYPES['postGoal'][0]) {
		$returnType = '\BhrSdk\Model\TransformedApiGoal';
		$request = $this->postGoalRequest($employee_id, $post_goal_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'postGoal'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  \BhrSdk\Model\PostGoalRequest $post_goal_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function postGoalRequest($employee_id, $post_goal_request, string $contentType = self::CONTENT_TYPES['postGoal'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling postGoal'
			);
		}

		// verify the required parameter 'post_goal_request' is set
		if ($post_goal_request === null || (is_array($post_goal_request) && count($post_goal_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $post_goal_request when calling postGoal'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($post_goal_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_goal_request));
			} else {
				$httpBody = $post_goal_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation postGoalComment
	 *
	 * Create Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $body body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postGoalComment'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function postGoalComment($employee_id, $goal_id, $body, string $contentType = self::CONTENT_TYPES['postGoalComment'][0]) {
		$this->postGoalCommentWithHttpInfo($employee_id, $goal_id, $body, $contentType);
	}

	/**
	 * Operation postGoalCommentWithHttpInfo
	 *
	 * Create Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postGoalComment'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function postGoalCommentWithHttpInfo($employee_id, $goal_id, $body, string $contentType = self::CONTENT_TYPES['postGoalComment'][0]) {
		$request = $this->postGoalCommentRequest($employee_id, $goal_id, $body, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation postGoalCommentAsync
	 *
	 * Create Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postGoalComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postGoalCommentAsync($employee_id, $goal_id, $body, string $contentType = self::CONTENT_TYPES['postGoalComment'][0]) {
		return $this->postGoalCommentAsyncWithHttpInfo($employee_id, $goal_id, $body, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation postGoalCommentAsyncWithHttpInfo
	 *
	 * Create Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postGoalComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postGoalCommentAsyncWithHttpInfo($employee_id, $goal_id, $body, string $contentType = self::CONTENT_TYPES['postGoalComment'][0]) {
		$returnType = '';
		$request = $this->postGoalCommentRequest($employee_id, $goal_id, $body, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'postGoalComment'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postGoalComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function postGoalCommentRequest($employee_id, $goal_id, $body, string $contentType = self::CONTENT_TYPES['postGoalComment'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling postGoalComment'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling postGoalComment'
			);
		}

		// verify the required parameter 'body' is set
		if ($body === null || (is_array($body) && count($body) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $body when calling postGoalComment'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}/comments';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($body)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
			} else {
				$httpBody = $body;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation postReopenGoal
	 *
	 * Reopen a Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postReopenGoal'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TransformedApiGoal
	 */
	public function postReopenGoal($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['postReopenGoal'][0]) {
		list($response) = $this->postReopenGoalWithHttpInfo($employee_id, $goal_id, $contentType);
		return $response;
	}

	/**
	 * Operation postReopenGoalWithHttpInfo
	 *
	 * Reopen a Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postReopenGoal'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TransformedApiGoal, HTTP status code, HTTP response headers (array of strings)
	 */
	public function postReopenGoalWithHttpInfo($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['postReopenGoal'][0]) {
		$request = $this->postReopenGoalRequest($employee_id, $goal_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TransformedApiGoal',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TransformedApiGoal',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TransformedApiGoal',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation postReopenGoalAsync
	 *
	 * Reopen a Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postReopenGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postReopenGoalAsync($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['postReopenGoal'][0]) {
		return $this->postReopenGoalAsyncWithHttpInfo($employee_id, $goal_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation postReopenGoalAsyncWithHttpInfo
	 *
	 * Reopen a Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postReopenGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postReopenGoalAsyncWithHttpInfo($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['postReopenGoal'][0]) {
		$returnType = '\BhrSdk\Model\TransformedApiGoal';
		$request = $this->postReopenGoalRequest($employee_id, $goal_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'postReopenGoal'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postReopenGoal'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function postReopenGoalRequest($employee_id, $goal_id, string $contentType = self::CONTENT_TYPES['postReopenGoal'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling postReopenGoal'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling postReopenGoal'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}/reopen';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation postWebhook
	 *
	 * Add Webhook
	 *
	 * @param  \BhrSdk\Model\NewWebHook $new_web_hook new_web_hook (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postWebhook'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\PostWebhook201Response|\BhrSdk\Model\Webhook400Error|\BhrSdk\Model\PostWebhook403Response|\BhrSdk\Model\WebhookError
	 */
	public function postWebhook($new_web_hook, string $contentType = self::CONTENT_TYPES['postWebhook'][0]) {
		list($response) = $this->postWebhookWithHttpInfo($new_web_hook, $contentType);
		return $response;
	}

	/**
	 * Operation postWebhookWithHttpInfo
	 *
	 * Add Webhook
	 *
	 * @param  \BhrSdk\Model\NewWebHook $new_web_hook (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postWebhook'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\PostWebhook201Response|\BhrSdk\Model\Webhook400Error|\BhrSdk\Model\PostWebhook403Response|\BhrSdk\Model\WebhookError, HTTP status code, HTTP response headers (array of strings)
	 */
	public function postWebhookWithHttpInfo($new_web_hook, string $contentType = self::CONTENT_TYPES['postWebhook'][0]) {
		$request = $this->postWebhookRequest($new_web_hook, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 201:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\PostWebhook201Response',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\Webhook400Error',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\PostWebhook403Response',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\PostWebhook201Response',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 201:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\PostWebhook201Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\Webhook400Error',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\PostWebhook403Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation postWebhookAsync
	 *
	 * Add Webhook
	 *
	 * @param  \BhrSdk\Model\NewWebHook $new_web_hook (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postWebhookAsync($new_web_hook, string $contentType = self::CONTENT_TYPES['postWebhook'][0]) {
		return $this->postWebhookAsyncWithHttpInfo($new_web_hook, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation postWebhookAsyncWithHttpInfo
	 *
	 * Add Webhook
	 *
	 * @param  \BhrSdk\Model\NewWebHook $new_web_hook (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function postWebhookAsyncWithHttpInfo($new_web_hook, string $contentType = self::CONTENT_TYPES['postWebhook'][0]) {
		$returnType = '\BhrSdk\Model\PostWebhook201Response';
		$request = $this->postWebhookRequest($new_web_hook, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'postWebhook'
	 *
	 * @param  \BhrSdk\Model\NewWebHook $new_web_hook (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['postWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function postWebhookRequest($new_web_hook, string $contentType = self::CONTENT_TYPES['postWebhook'][0]) {

		// verify the required parameter 'new_web_hook' is set
		if ($new_web_hook === null || (is_array($new_web_hook) && count($new_web_hook) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $new_web_hook when calling postWebhook'
			);
		}


		$resourcePath = '/api/v1/webhooks';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($new_web_hook)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_web_hook));
			} else {
				$httpBody = $new_web_hook;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation putGoalComment
	 *
	 * Update Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $comment_id commentId is the comment ID for the specified goal. (required)
	 * @param  string $body body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalComment'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function putGoalComment($employee_id, $goal_id, $comment_id, $body, string $contentType = self::CONTENT_TYPES['putGoalComment'][0]) {
		$this->putGoalCommentWithHttpInfo($employee_id, $goal_id, $comment_id, $body, $contentType);
	}

	/**
	 * Operation putGoalCommentWithHttpInfo
	 *
	 * Update Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $comment_id commentId is the comment ID for the specified goal. (required)
	 * @param  string $body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalComment'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function putGoalCommentWithHttpInfo($employee_id, $goal_id, $comment_id, $body, string $contentType = self::CONTENT_TYPES['putGoalComment'][0]) {
		$request = $this->putGoalCommentRequest($employee_id, $goal_id, $comment_id, $body, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation putGoalCommentAsync
	 *
	 * Update Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $comment_id commentId is the comment ID for the specified goal. (required)
	 * @param  string $body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putGoalCommentAsync($employee_id, $goal_id, $comment_id, $body, string $contentType = self::CONTENT_TYPES['putGoalComment'][0]) {
		return $this->putGoalCommentAsyncWithHttpInfo($employee_id, $goal_id, $comment_id, $body, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation putGoalCommentAsyncWithHttpInfo
	 *
	 * Update Goal Comment
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $comment_id commentId is the comment ID for the specified goal. (required)
	 * @param  string $body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putGoalCommentAsyncWithHttpInfo($employee_id, $goal_id, $comment_id, $body, string $contentType = self::CONTENT_TYPES['putGoalComment'][0]) {
		$returnType = '';
		$request = $this->putGoalCommentRequest($employee_id, $goal_id, $comment_id, $body, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'putGoalComment'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $comment_id commentId is the comment ID for the specified goal. (required)
	 * @param  string $body (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalComment'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function putGoalCommentRequest($employee_id, $goal_id, $comment_id, $body, string $contentType = self::CONTENT_TYPES['putGoalComment'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling putGoalComment'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling putGoalComment'
			);
		}

		// verify the required parameter 'comment_id' is set
		if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $comment_id when calling putGoalComment'
			);
		}

		// verify the required parameter 'body' is set
		if ($body === null || (is_array($body) && count($body) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $body when calling putGoalComment'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}/comments/{commentId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}
		// path params
		if ($comment_id !== null) {
			$resourcePath = str_replace(
				'{' . 'commentId' . '}',
				ObjectSerializer::toPathValue($comment_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($body)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
			} else {
				$httpBody = $body;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation putGoalMilestoneProgress
	 *
	 * Update Milestone Progress
	 *
	 * @param  string $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $milestone_id milestoneId is the milestone ID for the specified goal. (required)
	 * @param  \BhrSdk\Model\PutGoalMilestoneProgressRequest $put_goal_milestone_progress_request put_goal_milestone_progress_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalMilestoneProgress'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return object
	 */
	public function putGoalMilestoneProgress($employee_id, $goal_id, $milestone_id, $put_goal_milestone_progress_request, string $contentType = self::CONTENT_TYPES['putGoalMilestoneProgress'][0]) {
		list($response) = $this->putGoalMilestoneProgressWithHttpInfo($employee_id, $goal_id, $milestone_id, $put_goal_milestone_progress_request, $contentType);
		return $response;
	}

	/**
	 * Operation putGoalMilestoneProgressWithHttpInfo
	 *
	 * Update Milestone Progress
	 *
	 * @param  string $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $milestone_id milestoneId is the milestone ID for the specified goal. (required)
	 * @param  \BhrSdk\Model\PutGoalMilestoneProgressRequest $put_goal_milestone_progress_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalMilestoneProgress'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of object, HTTP status code, HTTP response headers (array of strings)
	 */
	public function putGoalMilestoneProgressWithHttpInfo($employee_id, $goal_id, $milestone_id, $put_goal_milestone_progress_request, string $contentType = self::CONTENT_TYPES['putGoalMilestoneProgress'][0]) {
		$request = $this->putGoalMilestoneProgressRequest($employee_id, $goal_id, $milestone_id, $put_goal_milestone_progress_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'object',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'object',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'object',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation putGoalMilestoneProgressAsync
	 *
	 * Update Milestone Progress
	 *
	 * @param  string $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $milestone_id milestoneId is the milestone ID for the specified goal. (required)
	 * @param  \BhrSdk\Model\PutGoalMilestoneProgressRequest $put_goal_milestone_progress_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalMilestoneProgress'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putGoalMilestoneProgressAsync($employee_id, $goal_id, $milestone_id, $put_goal_milestone_progress_request, string $contentType = self::CONTENT_TYPES['putGoalMilestoneProgress'][0]) {
		return $this->putGoalMilestoneProgressAsyncWithHttpInfo($employee_id, $goal_id, $milestone_id, $put_goal_milestone_progress_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation putGoalMilestoneProgressAsyncWithHttpInfo
	 *
	 * Update Milestone Progress
	 *
	 * @param  string $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $milestone_id milestoneId is the milestone ID for the specified goal. (required)
	 * @param  \BhrSdk\Model\PutGoalMilestoneProgressRequest $put_goal_milestone_progress_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalMilestoneProgress'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putGoalMilestoneProgressAsyncWithHttpInfo($employee_id, $goal_id, $milestone_id, $put_goal_milestone_progress_request, string $contentType = self::CONTENT_TYPES['putGoalMilestoneProgress'][0]) {
		$returnType = 'object';
		$request = $this->putGoalMilestoneProgressRequest($employee_id, $goal_id, $milestone_id, $put_goal_milestone_progress_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'putGoalMilestoneProgress'
	 *
	 * @param  string $employee_id employeeId is the employee ID to whom the goals are assigned. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  string $milestone_id milestoneId is the milestone ID for the specified goal. (required)
	 * @param  \BhrSdk\Model\PutGoalMilestoneProgressRequest $put_goal_milestone_progress_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalMilestoneProgress'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function putGoalMilestoneProgressRequest($employee_id, $goal_id, $milestone_id, $put_goal_milestone_progress_request, string $contentType = self::CONTENT_TYPES['putGoalMilestoneProgress'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling putGoalMilestoneProgress'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling putGoalMilestoneProgress'
			);
		}

		// verify the required parameter 'milestone_id' is set
		if ($milestone_id === null || (is_array($milestone_id) && count($milestone_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $milestone_id when calling putGoalMilestoneProgress'
			);
		}

		// verify the required parameter 'put_goal_milestone_progress_request' is set
		if ($put_goal_milestone_progress_request === null || (is_array($put_goal_milestone_progress_request) && count($put_goal_milestone_progress_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $put_goal_milestone_progress_request when calling putGoalMilestoneProgress'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}/milestones/{milestoneId}/progress';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}
		// path params
		if ($milestone_id !== null) {
			$resourcePath = str_replace(
				'{' . 'milestoneId' . '}',
				ObjectSerializer::toPathValue($milestone_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($put_goal_milestone_progress_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_goal_milestone_progress_request));
			} else {
				$httpBody = $put_goal_milestone_progress_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation putGoalProgress
	 *
	 * Update Goal Progress
	 *
	 * @param  int $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  int $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalProgressRequest $put_goal_progress_request Employee IDs of employees with whom the goal is shared. All goal owners are considered \&quot;shared with\&quot;. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalProgress'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TransformedApiGoal
	 */
	public function putGoalProgress($employee_id, $goal_id, $put_goal_progress_request, string $contentType = self::CONTENT_TYPES['putGoalProgress'][0]) {
		list($response) = $this->putGoalProgressWithHttpInfo($employee_id, $goal_id, $put_goal_progress_request, $contentType);
		return $response;
	}

	/**
	 * Operation putGoalProgressWithHttpInfo
	 *
	 * Update Goal Progress
	 *
	 * @param  int $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  int $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalProgressRequest $put_goal_progress_request Employee IDs of employees with whom the goal is shared. All goal owners are considered \&quot;shared with\&quot;. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalProgress'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TransformedApiGoal, HTTP status code, HTTP response headers (array of strings)
	 */
	public function putGoalProgressWithHttpInfo($employee_id, $goal_id, $put_goal_progress_request, string $contentType = self::CONTENT_TYPES['putGoalProgress'][0]) {
		$request = $this->putGoalProgressRequest($employee_id, $goal_id, $put_goal_progress_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TransformedApiGoal',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TransformedApiGoal',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TransformedApiGoal',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation putGoalProgressAsync
	 *
	 * Update Goal Progress
	 *
	 * @param  int $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  int $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalProgressRequest $put_goal_progress_request Employee IDs of employees with whom the goal is shared. All goal owners are considered \&quot;shared with\&quot;. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalProgress'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putGoalProgressAsync($employee_id, $goal_id, $put_goal_progress_request, string $contentType = self::CONTENT_TYPES['putGoalProgress'][0]) {
		return $this->putGoalProgressAsyncWithHttpInfo($employee_id, $goal_id, $put_goal_progress_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation putGoalProgressAsyncWithHttpInfo
	 *
	 * Update Goal Progress
	 *
	 * @param  int $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  int $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalProgressRequest $put_goal_progress_request Employee IDs of employees with whom the goal is shared. All goal owners are considered \&quot;shared with\&quot;. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalProgress'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putGoalProgressAsyncWithHttpInfo($employee_id, $goal_id, $put_goal_progress_request, string $contentType = self::CONTENT_TYPES['putGoalProgress'][0]) {
		$returnType = '\BhrSdk\Model\TransformedApiGoal';
		$request = $this->putGoalProgressRequest($employee_id, $goal_id, $put_goal_progress_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'putGoalProgress'
	 *
	 * @param  int $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  int $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalProgressRequest $put_goal_progress_request Employee IDs of employees with whom the goal is shared. All goal owners are considered \&quot;shared with\&quot;. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalProgress'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function putGoalProgressRequest($employee_id, $goal_id, $put_goal_progress_request, string $contentType = self::CONTENT_TYPES['putGoalProgress'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling putGoalProgress'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling putGoalProgress'
			);
		}

		// verify the required parameter 'put_goal_progress_request' is set
		if ($put_goal_progress_request === null || (is_array($put_goal_progress_request) && count($put_goal_progress_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $put_goal_progress_request when calling putGoalProgress'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}/progress';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($put_goal_progress_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_goal_progress_request));
			} else {
				$httpBody = $put_goal_progress_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation putGoalSharedWith
	 *
	 * Update Goal Sharing
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalSharedWithRequest $put_goal_shared_with_request Employee IDs of employees with whom the goal is shared. All goal owners are considered \&quot;shared with\&quot;. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalSharedWith'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TransformedApiGoal
	 */
	public function putGoalSharedWith($employee_id, $goal_id, $put_goal_shared_with_request, string $contentType = self::CONTENT_TYPES['putGoalSharedWith'][0]) {
		list($response) = $this->putGoalSharedWithWithHttpInfo($employee_id, $goal_id, $put_goal_shared_with_request, $contentType);
		return $response;
	}

	/**
	 * Operation putGoalSharedWithWithHttpInfo
	 *
	 * Update Goal Sharing
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalSharedWithRequest $put_goal_shared_with_request Employee IDs of employees with whom the goal is shared. All goal owners are considered \&quot;shared with\&quot;. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalSharedWith'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TransformedApiGoal, HTTP status code, HTTP response headers (array of strings)
	 */
	public function putGoalSharedWithWithHttpInfo($employee_id, $goal_id, $put_goal_shared_with_request, string $contentType = self::CONTENT_TYPES['putGoalSharedWith'][0]) {
		$request = $this->putGoalSharedWithRequest($employee_id, $goal_id, $put_goal_shared_with_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TransformedApiGoal',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TransformedApiGoal',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TransformedApiGoal',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation putGoalSharedWithAsync
	 *
	 * Update Goal Sharing
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalSharedWithRequest $put_goal_shared_with_request Employee IDs of employees with whom the goal is shared. All goal owners are considered \&quot;shared with\&quot;. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalSharedWith'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putGoalSharedWithAsync($employee_id, $goal_id, $put_goal_shared_with_request, string $contentType = self::CONTENT_TYPES['putGoalSharedWith'][0]) {
		return $this->putGoalSharedWithAsyncWithHttpInfo($employee_id, $goal_id, $put_goal_shared_with_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation putGoalSharedWithAsyncWithHttpInfo
	 *
	 * Update Goal Sharing
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalSharedWithRequest $put_goal_shared_with_request Employee IDs of employees with whom the goal is shared. All goal owners are considered \&quot;shared with\&quot;. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalSharedWith'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putGoalSharedWithAsyncWithHttpInfo($employee_id, $goal_id, $put_goal_shared_with_request, string $contentType = self::CONTENT_TYPES['putGoalSharedWith'][0]) {
		$returnType = '\BhrSdk\Model\TransformedApiGoal';
		$request = $this->putGoalSharedWithRequest($employee_id, $goal_id, $put_goal_shared_with_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'putGoalSharedWith'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalSharedWithRequest $put_goal_shared_with_request Employee IDs of employees with whom the goal is shared. All goal owners are considered \&quot;shared with\&quot;. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalSharedWith'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function putGoalSharedWithRequest($employee_id, $goal_id, $put_goal_shared_with_request, string $contentType = self::CONTENT_TYPES['putGoalSharedWith'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling putGoalSharedWith'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling putGoalSharedWith'
			);
		}

		// verify the required parameter 'put_goal_shared_with_request' is set
		if ($put_goal_shared_with_request === null || (is_array($put_goal_shared_with_request) && count($put_goal_shared_with_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $put_goal_shared_with_request when calling putGoalSharedWith'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}/sharedWith';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($put_goal_shared_with_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_goal_shared_with_request));
			} else {
				$httpBody = $put_goal_shared_with_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation putGoalV1
	 *
	 * Update Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\Goal $goal Required fields: title, sharedWithEmployeeIds, dueDate. Any non-required field not provided will overwrite existing data with a NULL value. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalV1'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TransformedApiGoal
	 * @deprecated
	 */
	public function putGoalV1($employee_id, $goal_id, $goal, string $contentType = self::CONTENT_TYPES['putGoalV1'][0]) {
		list($response) = $this->putGoalV1WithHttpInfo($employee_id, $goal_id, $goal, $contentType);
		return $response;
	}

	/**
	 * Operation putGoalV1WithHttpInfo
	 *
	 * Update Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\Goal $goal Required fields: title, sharedWithEmployeeIds, dueDate. Any non-required field not provided will overwrite existing data with a NULL value. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalV1'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TransformedApiGoal, HTTP status code, HTTP response headers (array of strings)
	 * @deprecated
	 */
	public function putGoalV1WithHttpInfo($employee_id, $goal_id, $goal, string $contentType = self::CONTENT_TYPES['putGoalV1'][0]) {
		$request = $this->putGoalV1Request($employee_id, $goal_id, $goal, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TransformedApiGoal',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TransformedApiGoal',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TransformedApiGoal',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation putGoalV1Async
	 *
	 * Update Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\Goal $goal Required fields: title, sharedWithEmployeeIds, dueDate. Any non-required field not provided will overwrite existing data with a NULL value. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function putGoalV1Async($employee_id, $goal_id, $goal, string $contentType = self::CONTENT_TYPES['putGoalV1'][0]) {
		return $this->putGoalV1AsyncWithHttpInfo($employee_id, $goal_id, $goal, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation putGoalV1AsyncWithHttpInfo
	 *
	 * Update Goal
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\Goal $goal Required fields: title, sharedWithEmployeeIds, dueDate. Any non-required field not provided will overwrite existing data with a NULL value. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 * @deprecated
	 */
	public function putGoalV1AsyncWithHttpInfo($employee_id, $goal_id, $goal, string $contentType = self::CONTENT_TYPES['putGoalV1'][0]) {
		$returnType = '\BhrSdk\Model\TransformedApiGoal';
		$request = $this->putGoalV1Request($employee_id, $goal_id, $goal, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'putGoalV1'
	 *
	 * @param  string $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  string $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\Goal $goal Required fields: title, sharedWithEmployeeIds, dueDate. Any non-required field not provided will overwrite existing data with a NULL value. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalV1'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 * @deprecated
	 */
	public function putGoalV1Request($employee_id, $goal_id, $goal, string $contentType = self::CONTENT_TYPES['putGoalV1'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling putGoalV1'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling putGoalV1'
			);
		}

		// verify the required parameter 'goal' is set
		if ($goal === null || (is_array($goal) && count($goal) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal when calling putGoalV1'
			);
		}


		$resourcePath = '/api/v1/performance/employees/{employeeId}/goals/{goalId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($goal)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($goal));
			} else {
				$httpBody = $goal;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation putGoalV11
	 *
	 * Update Goal, V1.1
	 *
	 * @param  int $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  int $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalV11Request $put_goal_v11_request Required fields: title, sharedWithEmployeeIds, dueDate. Any non-required field not provided will overwrite existing data with a NULL value. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalV11'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TransformedApiGoal
	 */
	public function putGoalV11($employee_id, $goal_id, $put_goal_v11_request, string $contentType = self::CONTENT_TYPES['putGoalV11'][0]) {
		list($response) = $this->putGoalV11WithHttpInfo($employee_id, $goal_id, $put_goal_v11_request, $contentType);
		return $response;
	}

	/**
	 * Operation putGoalV11WithHttpInfo
	 *
	 * Update Goal, V1.1
	 *
	 * @param  int $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  int $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalV11Request $put_goal_v11_request Required fields: title, sharedWithEmployeeIds, dueDate. Any non-required field not provided will overwrite existing data with a NULL value. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalV11'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TransformedApiGoal, HTTP status code, HTTP response headers (array of strings)
	 */
	public function putGoalV11WithHttpInfo($employee_id, $goal_id, $put_goal_v11_request, string $contentType = self::CONTENT_TYPES['putGoalV11'][0]) {
		$request = $this->putGoalV11Request($employee_id, $goal_id, $put_goal_v11_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TransformedApiGoal',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TransformedApiGoal',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TransformedApiGoal',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation putGoalV11Async
	 *
	 * Update Goal, V1.1
	 *
	 * @param  int $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  int $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalV11Request $put_goal_v11_request Required fields: title, sharedWithEmployeeIds, dueDate. Any non-required field not provided will overwrite existing data with a NULL value. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putGoalV11Async($employee_id, $goal_id, $put_goal_v11_request, string $contentType = self::CONTENT_TYPES['putGoalV11'][0]) {
		return $this->putGoalV11AsyncWithHttpInfo($employee_id, $goal_id, $put_goal_v11_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation putGoalV11AsyncWithHttpInfo
	 *
	 * Update Goal, V1.1
	 *
	 * @param  int $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  int $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalV11Request $put_goal_v11_request Required fields: title, sharedWithEmployeeIds, dueDate. Any non-required field not provided will overwrite existing data with a NULL value. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putGoalV11AsyncWithHttpInfo($employee_id, $goal_id, $put_goal_v11_request, string $contentType = self::CONTENT_TYPES['putGoalV11'][0]) {
		$returnType = '\BhrSdk\Model\TransformedApiGoal';
		$request = $this->putGoalV11Request($employee_id, $goal_id, $put_goal_v11_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'putGoalV11'
	 *
	 * @param  int $employee_id employeeId is the employee ID with whom the goal is associated. (required)
	 * @param  int $goal_id goalId is the goal ID for the specified employee. (required)
	 * @param  \BhrSdk\Model\PutGoalV11Request $put_goal_v11_request Required fields: title, sharedWithEmployeeIds, dueDate. Any non-required field not provided will overwrite existing data with a NULL value. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putGoalV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function putGoalV11Request($employee_id, $goal_id, $put_goal_v11_request, string $contentType = self::CONTENT_TYPES['putGoalV11'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling putGoalV11'
			);
		}

		// verify the required parameter 'goal_id' is set
		if ($goal_id === null || (is_array($goal_id) && count($goal_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $goal_id when calling putGoalV11'
			);
		}

		// verify the required parameter 'put_goal_v11_request' is set
		if ($put_goal_v11_request === null || (is_array($put_goal_v11_request) && count($put_goal_v11_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $put_goal_v11_request when calling putGoalV11'
			);
		}


		$resourcePath = '/api/v1_1/performance/employees/{employeeId}/goals/{goalId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}
		// path params
		if ($goal_id !== null) {
			$resourcePath = str_replace(
				'{' . 'goalId' . '}',
				ObjectSerializer::toPathValue($goal_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($put_goal_v11_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_goal_v11_request));
			} else {
				$httpBody = $put_goal_v11_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation putWebhook
	 *
	 * Update Webhook
	 *
	 * @param  string $id {id} is a webhook ID. (required)
	 * @param  \BhrSdk\Model\NewWebHook $new_web_hook new_web_hook (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putWebhook'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\WebHookResponse|\BhrSdk\Model\Webhook400Error|\BhrSdk\Model\PutWebhook403Response|\BhrSdk\Model\WebhookError|\BhrSdk\Model\WebhookError
	 */
	public function putWebhook($id, $new_web_hook, string $contentType = self::CONTENT_TYPES['putWebhook'][0]) {
		list($response) = $this->putWebhookWithHttpInfo($id, $new_web_hook, $contentType);
		return $response;
	}

	/**
	 * Operation putWebhookWithHttpInfo
	 *
	 * Update Webhook
	 *
	 * @param  string $id {id} is a webhook ID. (required)
	 * @param  \BhrSdk\Model\NewWebHook $new_web_hook (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putWebhook'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\WebHookResponse|\BhrSdk\Model\Webhook400Error|\BhrSdk\Model\PutWebhook403Response|\BhrSdk\Model\WebhookError|\BhrSdk\Model\WebhookError, HTTP status code, HTTP response headers (array of strings)
	 */
	public function putWebhookWithHttpInfo($id, $new_web_hook, string $contentType = self::CONTENT_TYPES['putWebhook'][0]) {
		$request = $this->putWebhookRequest($id, $new_web_hook, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebHookResponse',
						$request,
						$response,
					);
				case 400:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\Webhook400Error',
						$request,
						$response,
					);
				case 403:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\PutWebhook403Response',
						$request,
						$response,
					);
				case 404:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
				case 500:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\WebhookError',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\WebHookResponse',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebHookResponse',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 400:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\Webhook400Error',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 403:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\PutWebhook403Response',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 404:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
				case 500:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\WebhookError',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation putWebhookAsync
	 *
	 * Update Webhook
	 *
	 * @param  string $id {id} is a webhook ID. (required)
	 * @param  \BhrSdk\Model\NewWebHook $new_web_hook (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putWebhookAsync($id, $new_web_hook, string $contentType = self::CONTENT_TYPES['putWebhook'][0]) {
		return $this->putWebhookAsyncWithHttpInfo($id, $new_web_hook, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation putWebhookAsyncWithHttpInfo
	 *
	 * Update Webhook
	 *
	 * @param  string $id {id} is a webhook ID. (required)
	 * @param  \BhrSdk\Model\NewWebHook $new_web_hook (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function putWebhookAsyncWithHttpInfo($id, $new_web_hook, string $contentType = self::CONTENT_TYPES['putWebhook'][0]) {
		$returnType = '\BhrSdk\Model\WebHookResponse';
		$request = $this->putWebhookRequest($id, $new_web_hook, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'putWebhook'
	 *
	 * @param  string $id {id} is a webhook ID. (required)
	 * @param  \BhrSdk\Model\NewWebHook $new_web_hook (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['putWebhook'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function putWebhookRequest($id, $new_web_hook, string $contentType = self::CONTENT_TYPES['putWebhook'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling putWebhook'
			);
		}

		// verify the required parameter 'new_web_hook' is set
		if ($new_web_hook === null || (is_array($new_web_hook) && count($new_web_hook) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $new_web_hook when calling putWebhook'
			);
		}


		$resourcePath = '/api/v1/webhooks/{id}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($new_web_hook)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_web_hook));
			} else {
				$httpBody = $new_web_hook;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation requestCustomReport
	 *
	 * Request a custom report
	 *
	 * @param  string $format The output format for the report. Supported formats: CSV, PDF, XLS, XML, JSON (required)
	 * @param  \BhrSdk\Model\RequestCustomReport $request_custom_report request_custom_report (required)
	 * @param  bool|null $only_current Limits the report to only current employees. Setting to false will include future-dated employees in the report. (optional, default to false)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['requestCustomReport'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function requestCustomReport($format, $request_custom_report, $only_current = false, string $contentType = self::CONTENT_TYPES['requestCustomReport'][0]) {
		$this->requestCustomReportWithHttpInfo($format, $request_custom_report, $only_current, $contentType);
	}

	/**
	 * Operation requestCustomReportWithHttpInfo
	 *
	 * Request a custom report
	 *
	 * @param  string $format The output format for the report. Supported formats: CSV, PDF, XLS, XML, JSON (required)
	 * @param  \BhrSdk\Model\RequestCustomReport $request_custom_report (required)
	 * @param  bool|null $only_current Limits the report to only current employees. Setting to false will include future-dated employees in the report. (optional, default to false)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['requestCustomReport'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function requestCustomReportWithHttpInfo($format, $request_custom_report, $only_current = false, string $contentType = self::CONTENT_TYPES['requestCustomReport'][0]) {
		$request = $this->requestCustomReportRequest($format, $request_custom_report, $only_current, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation requestCustomReportAsync
	 *
	 * Request a custom report
	 *
	 * @param  string $format The output format for the report. Supported formats: CSV, PDF, XLS, XML, JSON (required)
	 * @param  \BhrSdk\Model\RequestCustomReport $request_custom_report (required)
	 * @param  bool|null $only_current Limits the report to only current employees. Setting to false will include future-dated employees in the report. (optional, default to false)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['requestCustomReport'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function requestCustomReportAsync($format, $request_custom_report, $only_current = false, string $contentType = self::CONTENT_TYPES['requestCustomReport'][0]) {
		return $this->requestCustomReportAsyncWithHttpInfo($format, $request_custom_report, $only_current, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation requestCustomReportAsyncWithHttpInfo
	 *
	 * Request a custom report
	 *
	 * @param  string $format The output format for the report. Supported formats: CSV, PDF, XLS, XML, JSON (required)
	 * @param  \BhrSdk\Model\RequestCustomReport $request_custom_report (required)
	 * @param  bool|null $only_current Limits the report to only current employees. Setting to false will include future-dated employees in the report. (optional, default to false)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['requestCustomReport'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function requestCustomReportAsyncWithHttpInfo($format, $request_custom_report, $only_current = false, string $contentType = self::CONTENT_TYPES['requestCustomReport'][0]) {
		$returnType = '';
		$request = $this->requestCustomReportRequest($format, $request_custom_report, $only_current, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'requestCustomReport'
	 *
	 * @param  string $format The output format for the report. Supported formats: CSV, PDF, XLS, XML, JSON (required)
	 * @param  \BhrSdk\Model\RequestCustomReport $request_custom_report (required)
	 * @param  bool|null $only_current Limits the report to only current employees. Setting to false will include future-dated employees in the report. (optional, default to false)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['requestCustomReport'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function requestCustomReportRequest($format, $request_custom_report, $only_current = false, string $contentType = self::CONTENT_TYPES['requestCustomReport'][0]) {

		// verify the required parameter 'format' is set
		if ($format === null || (is_array($format) && count($format) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $format when calling requestCustomReport'
			);
		}

		// verify the required parameter 'request_custom_report' is set
		if ($request_custom_report === null || (is_array($request_custom_report) && count($request_custom_report) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $request_custom_report when calling requestCustomReport'
			);
		}



		$resourcePath = '/api/v1/reports/custom';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$format,
			'format', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$only_current,
			'onlyCurrent', // param base name
			'boolean', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);




		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($request_custom_report)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_custom_report));
			} else {
				$httpBody = $request_custom_report;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation timeOffAddATimeOffHistoryItemForTimeOffRequest
	 *
	 * Add a Time Off History Item For Time Off Request
	 *
	 * @param  int $employee_id The ID of the employee. (required)
	 * @param  \BhrSdk\Model\TimeOffHistory $time_off_history time_off_history (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAddATimeOffHistoryItemForTimeOffRequest'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function timeOffAddATimeOffHistoryItemForTimeOffRequest($employee_id, $time_off_history, string $contentType = self::CONTENT_TYPES['timeOffAddATimeOffHistoryItemForTimeOffRequest'][0]) {
		$this->timeOffAddATimeOffHistoryItemForTimeOffRequestWithHttpInfo($employee_id, $time_off_history, $contentType);
	}

	/**
	 * Operation timeOffAddATimeOffHistoryItemForTimeOffRequestWithHttpInfo
	 *
	 * Add a Time Off History Item For Time Off Request
	 *
	 * @param  int $employee_id The ID of the employee. (required)
	 * @param  \BhrSdk\Model\TimeOffHistory $time_off_history (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAddATimeOffHistoryItemForTimeOffRequest'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function timeOffAddATimeOffHistoryItemForTimeOffRequestWithHttpInfo($employee_id, $time_off_history, string $contentType = self::CONTENT_TYPES['timeOffAddATimeOffHistoryItemForTimeOffRequest'][0]) {
		$request = $this->timeOffAddATimeOffHistoryItemForTimeOffRequestRequest($employee_id, $time_off_history, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation timeOffAddATimeOffHistoryItemForTimeOffRequestAsync
	 *
	 * Add a Time Off History Item For Time Off Request
	 *
	 * @param  int $employee_id The ID of the employee. (required)
	 * @param  \BhrSdk\Model\TimeOffHistory $time_off_history (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAddATimeOffHistoryItemForTimeOffRequest'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffAddATimeOffHistoryItemForTimeOffRequestAsync($employee_id, $time_off_history, string $contentType = self::CONTENT_TYPES['timeOffAddATimeOffHistoryItemForTimeOffRequest'][0]) {
		return $this->timeOffAddATimeOffHistoryItemForTimeOffRequestAsyncWithHttpInfo($employee_id, $time_off_history, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation timeOffAddATimeOffHistoryItemForTimeOffRequestAsyncWithHttpInfo
	 *
	 * Add a Time Off History Item For Time Off Request
	 *
	 * @param  int $employee_id The ID of the employee. (required)
	 * @param  \BhrSdk\Model\TimeOffHistory $time_off_history (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAddATimeOffHistoryItemForTimeOffRequest'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffAddATimeOffHistoryItemForTimeOffRequestAsyncWithHttpInfo($employee_id, $time_off_history, string $contentType = self::CONTENT_TYPES['timeOffAddATimeOffHistoryItemForTimeOffRequest'][0]) {
		$returnType = '';
		$request = $this->timeOffAddATimeOffHistoryItemForTimeOffRequestRequest($employee_id, $time_off_history, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'timeOffAddATimeOffHistoryItemForTimeOffRequest'
	 *
	 * @param  int $employee_id The ID of the employee. (required)
	 * @param  \BhrSdk\Model\TimeOffHistory $time_off_history (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAddATimeOffHistoryItemForTimeOffRequest'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function timeOffAddATimeOffHistoryItemForTimeOffRequestRequest($employee_id, $time_off_history, string $contentType = self::CONTENT_TYPES['timeOffAddATimeOffHistoryItemForTimeOffRequest'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling timeOffAddATimeOffHistoryItemForTimeOffRequest'
			);
		}

		// verify the required parameter 'time_off_history' is set
		if ($time_off_history === null || (is_array($time_off_history) && count($time_off_history) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $time_off_history when calling timeOffAddATimeOffHistoryItemForTimeOffRequest'
			);
		}


		$resourcePath = '/api/v1/employees/{employeeId}/time_off/history';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($time_off_history)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($time_off_history));
			} else {
				$httpBody = $time_off_history;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation timeOffAddATimeOffRequest
	 *
	 * Add a Time Off Request
	 *
	 * @param  string $employee_id employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffRequest $time_off_request time_off_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAddATimeOffRequest'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function timeOffAddATimeOffRequest($employee_id, $time_off_request, string $contentType = self::CONTENT_TYPES['timeOffAddATimeOffRequest'][0]) {
		$this->timeOffAddATimeOffRequestWithHttpInfo($employee_id, $time_off_request, $contentType);
	}

	/**
	 * Operation timeOffAddATimeOffRequestWithHttpInfo
	 *
	 * Add a Time Off Request
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffRequest $time_off_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAddATimeOffRequest'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function timeOffAddATimeOffRequestWithHttpInfo($employee_id, $time_off_request, string $contentType = self::CONTENT_TYPES['timeOffAddATimeOffRequest'][0]) {
		$request = $this->timeOffAddATimeOffRequestRequest($employee_id, $time_off_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation timeOffAddATimeOffRequestAsync
	 *
	 * Add a Time Off Request
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffRequest $time_off_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAddATimeOffRequest'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffAddATimeOffRequestAsync($employee_id, $time_off_request, string $contentType = self::CONTENT_TYPES['timeOffAddATimeOffRequest'][0]) {
		return $this->timeOffAddATimeOffRequestAsyncWithHttpInfo($employee_id, $time_off_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation timeOffAddATimeOffRequestAsyncWithHttpInfo
	 *
	 * Add a Time Off Request
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffRequest $time_off_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAddATimeOffRequest'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffAddATimeOffRequestAsyncWithHttpInfo($employee_id, $time_off_request, string $contentType = self::CONTENT_TYPES['timeOffAddATimeOffRequest'][0]) {
		$returnType = '';
		$request = $this->timeOffAddATimeOffRequestRequest($employee_id, $time_off_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'timeOffAddATimeOffRequest'
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffRequest $time_off_request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAddATimeOffRequest'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function timeOffAddATimeOffRequestRequest($employee_id, $time_off_request, string $contentType = self::CONTENT_TYPES['timeOffAddATimeOffRequest'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling timeOffAddATimeOffRequest'
			);
		}

		// verify the required parameter 'time_off_request' is set
		if ($time_off_request === null || (is_array($time_off_request) && count($time_off_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $time_off_request when calling timeOffAddATimeOffRequest'
			);
		}


		$resourcePath = '/api/v1/employees/{employeeId}/time_off/request';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($time_off_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($time_off_request));
			} else {
				$httpBody = $time_off_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation timeOffAdjustTimeOffBalance
	 *
	 * Adjust Time Off Balance
	 *
	 * @param  int $employee_id The ID of the employee. (required)
	 * @param  \BhrSdk\Model\AdjustTimeOffBalance $adjust_time_off_balance adjust_time_off_balance (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAdjustTimeOffBalance'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function timeOffAdjustTimeOffBalance($employee_id, $adjust_time_off_balance, string $contentType = self::CONTENT_TYPES['timeOffAdjustTimeOffBalance'][0]) {
		$this->timeOffAdjustTimeOffBalanceWithHttpInfo($employee_id, $adjust_time_off_balance, $contentType);
	}

	/**
	 * Operation timeOffAdjustTimeOffBalanceWithHttpInfo
	 *
	 * Adjust Time Off Balance
	 *
	 * @param  int $employee_id The ID of the employee. (required)
	 * @param  \BhrSdk\Model\AdjustTimeOffBalance $adjust_time_off_balance (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAdjustTimeOffBalance'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function timeOffAdjustTimeOffBalanceWithHttpInfo($employee_id, $adjust_time_off_balance, string $contentType = self::CONTENT_TYPES['timeOffAdjustTimeOffBalance'][0]) {
		$request = $this->timeOffAdjustTimeOffBalanceRequest($employee_id, $adjust_time_off_balance, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation timeOffAdjustTimeOffBalanceAsync
	 *
	 * Adjust Time Off Balance
	 *
	 * @param  int $employee_id The ID of the employee. (required)
	 * @param  \BhrSdk\Model\AdjustTimeOffBalance $adjust_time_off_balance (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAdjustTimeOffBalance'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffAdjustTimeOffBalanceAsync($employee_id, $adjust_time_off_balance, string $contentType = self::CONTENT_TYPES['timeOffAdjustTimeOffBalance'][0]) {
		return $this->timeOffAdjustTimeOffBalanceAsyncWithHttpInfo($employee_id, $adjust_time_off_balance, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation timeOffAdjustTimeOffBalanceAsyncWithHttpInfo
	 *
	 * Adjust Time Off Balance
	 *
	 * @param  int $employee_id The ID of the employee. (required)
	 * @param  \BhrSdk\Model\AdjustTimeOffBalance $adjust_time_off_balance (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAdjustTimeOffBalance'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffAdjustTimeOffBalanceAsyncWithHttpInfo($employee_id, $adjust_time_off_balance, string $contentType = self::CONTENT_TYPES['timeOffAdjustTimeOffBalance'][0]) {
		$returnType = '';
		$request = $this->timeOffAdjustTimeOffBalanceRequest($employee_id, $adjust_time_off_balance, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'timeOffAdjustTimeOffBalance'
	 *
	 * @param  int $employee_id The ID of the employee. (required)
	 * @param  \BhrSdk\Model\AdjustTimeOffBalance $adjust_time_off_balance (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAdjustTimeOffBalance'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function timeOffAdjustTimeOffBalanceRequest($employee_id, $adjust_time_off_balance, string $contentType = self::CONTENT_TYPES['timeOffAdjustTimeOffBalance'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling timeOffAdjustTimeOffBalance'
			);
		}

		// verify the required parameter 'adjust_time_off_balance' is set
		if ($adjust_time_off_balance === null || (is_array($adjust_time_off_balance) && count($adjust_time_off_balance) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $adjust_time_off_balance when calling timeOffAdjustTimeOffBalance'
			);
		}


		$resourcePath = '/api/v1/employees/{employeeId}/time_off/balance_adjustment';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($adjust_time_off_balance)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($adjust_time_off_balance));
			} else {
				$httpBody = $adjust_time_off_balance;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation timeOffAssignTimeOffPoliciesForAnEmployee
	 *
	 * Assign Time Off Policies for an Employee
	 *
	 * @param  string $employee_id employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffAssignTimeOffPoliciesForAnEmployeeRequestInner[] $time_off_assign_time_off_policies_for_an_employee_request_inner time_off_assign_time_off_policies_for_an_employee_request_inner (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function timeOffAssignTimeOffPoliciesForAnEmployee($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, string $contentType = self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployee'][0]) {
		$this->timeOffAssignTimeOffPoliciesForAnEmployeeWithHttpInfo($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, $contentType);
	}

	/**
	 * Operation timeOffAssignTimeOffPoliciesForAnEmployeeWithHttpInfo
	 *
	 * Assign Time Off Policies for an Employee
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffAssignTimeOffPoliciesForAnEmployeeRequestInner[] $time_off_assign_time_off_policies_for_an_employee_request_inner (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function timeOffAssignTimeOffPoliciesForAnEmployeeWithHttpInfo($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, string $contentType = self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployee'][0]) {
		$request = $this->timeOffAssignTimeOffPoliciesForAnEmployeeRequest($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation timeOffAssignTimeOffPoliciesForAnEmployeeAsync
	 *
	 * Assign Time Off Policies for an Employee
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffAssignTimeOffPoliciesForAnEmployeeRequestInner[] $time_off_assign_time_off_policies_for_an_employee_request_inner (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffAssignTimeOffPoliciesForAnEmployeeAsync($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, string $contentType = self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployee'][0]) {
		return $this->timeOffAssignTimeOffPoliciesForAnEmployeeAsyncWithHttpInfo($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation timeOffAssignTimeOffPoliciesForAnEmployeeAsyncWithHttpInfo
	 *
	 * Assign Time Off Policies for an Employee
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffAssignTimeOffPoliciesForAnEmployeeRequestInner[] $time_off_assign_time_off_policies_for_an_employee_request_inner (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffAssignTimeOffPoliciesForAnEmployeeAsyncWithHttpInfo($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, string $contentType = self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployee'][0]) {
		$returnType = '';
		$request = $this->timeOffAssignTimeOffPoliciesForAnEmployeeRequest($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'timeOffAssignTimeOffPoliciesForAnEmployee'
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffAssignTimeOffPoliciesForAnEmployeeRequestInner[] $time_off_assign_time_off_policies_for_an_employee_request_inner (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function timeOffAssignTimeOffPoliciesForAnEmployeeRequest($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, string $contentType = self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployee'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling timeOffAssignTimeOffPoliciesForAnEmployee'
			);
		}

		// verify the required parameter 'time_off_assign_time_off_policies_for_an_employee_request_inner' is set
		if ($time_off_assign_time_off_policies_for_an_employee_request_inner === null || (is_array($time_off_assign_time_off_policies_for_an_employee_request_inner) && count($time_off_assign_time_off_policies_for_an_employee_request_inner) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $time_off_assign_time_off_policies_for_an_employee_request_inner when calling timeOffAssignTimeOffPoliciesForAnEmployee'
			);
		}


		$resourcePath = '/api/v1/employees/{employeeId}/time_off/policies';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($time_off_assign_time_off_policies_for_an_employee_request_inner)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($time_off_assign_time_off_policies_for_an_employee_request_inner));
			} else {
				$httpBody = $time_off_assign_time_off_policies_for_an_employee_request_inner;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation timeOffAssignTimeOffPoliciesForAnEmployeeV11
	 *
	 * Assign Time Off Policies for an Employee, Version 1.1
	 *
	 * @param  string $employee_id employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffAssignTimeOffPoliciesForAnEmployeeRequestInner[] $time_off_assign_time_off_policies_for_an_employee_request_inner time_off_assign_time_off_policies_for_an_employee_request_inner (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployeeV11'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function timeOffAssignTimeOffPoliciesForAnEmployeeV11($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, string $contentType = self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployeeV11'][0]) {
		$this->timeOffAssignTimeOffPoliciesForAnEmployeeV11WithHttpInfo($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, $contentType);
	}

	/**
	 * Operation timeOffAssignTimeOffPoliciesForAnEmployeeV11WithHttpInfo
	 *
	 * Assign Time Off Policies for an Employee, Version 1.1
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffAssignTimeOffPoliciesForAnEmployeeRequestInner[] $time_off_assign_time_off_policies_for_an_employee_request_inner (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployeeV11'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function timeOffAssignTimeOffPoliciesForAnEmployeeV11WithHttpInfo($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, string $contentType = self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployeeV11'][0]) {
		$request = $this->timeOffAssignTimeOffPoliciesForAnEmployeeV11Request($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation timeOffAssignTimeOffPoliciesForAnEmployeeV11Async
	 *
	 * Assign Time Off Policies for an Employee, Version 1.1
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffAssignTimeOffPoliciesForAnEmployeeRequestInner[] $time_off_assign_time_off_policies_for_an_employee_request_inner (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployeeV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffAssignTimeOffPoliciesForAnEmployeeV11Async($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, string $contentType = self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployeeV11'][0]) {
		return $this->timeOffAssignTimeOffPoliciesForAnEmployeeV11AsyncWithHttpInfo($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation timeOffAssignTimeOffPoliciesForAnEmployeeV11AsyncWithHttpInfo
	 *
	 * Assign Time Off Policies for an Employee, Version 1.1
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffAssignTimeOffPoliciesForAnEmployeeRequestInner[] $time_off_assign_time_off_policies_for_an_employee_request_inner (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployeeV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffAssignTimeOffPoliciesForAnEmployeeV11AsyncWithHttpInfo($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, string $contentType = self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployeeV11'][0]) {
		$returnType = '';
		$request = $this->timeOffAssignTimeOffPoliciesForAnEmployeeV11Request($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'timeOffAssignTimeOffPoliciesForAnEmployeeV11'
	 *
	 * @param  string $employee_id (required)
	 * @param  \BhrSdk\Model\TimeOffAssignTimeOffPoliciesForAnEmployeeRequestInner[] $time_off_assign_time_off_policies_for_an_employee_request_inner (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployeeV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function timeOffAssignTimeOffPoliciesForAnEmployeeV11Request($employee_id, $time_off_assign_time_off_policies_for_an_employee_request_inner, string $contentType = self::CONTENT_TYPES['timeOffAssignTimeOffPoliciesForAnEmployeeV11'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling timeOffAssignTimeOffPoliciesForAnEmployeeV11'
			);
		}

		// verify the required parameter 'time_off_assign_time_off_policies_for_an_employee_request_inner' is set
		if ($time_off_assign_time_off_policies_for_an_employee_request_inner === null || (is_array($time_off_assign_time_off_policies_for_an_employee_request_inner) && count($time_off_assign_time_off_policies_for_an_employee_request_inner) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $time_off_assign_time_off_policies_for_an_employee_request_inner when calling timeOffAssignTimeOffPoliciesForAnEmployeeV11'
			);
		}


		$resourcePath = '/api/v1_1/employees/{employeeId}/time_off/policies';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($time_off_assign_time_off_policies_for_an_employee_request_inner)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($time_off_assign_time_off_policies_for_an_employee_request_inner));
			} else {
				$httpBody = $time_off_assign_time_off_policies_for_an_employee_request_inner;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation timeOffChangeARequestStatus
	 *
	 * Change a Request Status
	 *
	 * @param  string $request_id request_id (required)
	 * @param  \BhrSdk\Model\Request $request request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffChangeARequestStatus'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function timeOffChangeARequestStatus($request_id, $request, string $contentType = self::CONTENT_TYPES['timeOffChangeARequestStatus'][0]) {
		$this->timeOffChangeARequestStatusWithHttpInfo($request_id, $request, $contentType);
	}

	/**
	 * Operation timeOffChangeARequestStatusWithHttpInfo
	 *
	 * Change a Request Status
	 *
	 * @param  string $request_id (required)
	 * @param  \BhrSdk\Model\Request $request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffChangeARequestStatus'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function timeOffChangeARequestStatusWithHttpInfo($request_id, $request, string $contentType = self::CONTENT_TYPES['timeOffChangeARequestStatus'][0]) {
		$request = $this->timeOffChangeARequestStatusRequest($request_id, $request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation timeOffChangeARequestStatusAsync
	 *
	 * Change a Request Status
	 *
	 * @param  string $request_id (required)
	 * @param  \BhrSdk\Model\Request $request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffChangeARequestStatus'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffChangeARequestStatusAsync($request_id, $request, string $contentType = self::CONTENT_TYPES['timeOffChangeARequestStatus'][0]) {
		return $this->timeOffChangeARequestStatusAsyncWithHttpInfo($request_id, $request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation timeOffChangeARequestStatusAsyncWithHttpInfo
	 *
	 * Change a Request Status
	 *
	 * @param  string $request_id (required)
	 * @param  \BhrSdk\Model\Request $request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffChangeARequestStatus'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffChangeARequestStatusAsyncWithHttpInfo($request_id, $request, string $contentType = self::CONTENT_TYPES['timeOffChangeARequestStatus'][0]) {
		$returnType = '';
		$request = $this->timeOffChangeARequestStatusRequest($request_id, $request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'timeOffChangeARequestStatus'
	 *
	 * @param  string $request_id (required)
	 * @param  \BhrSdk\Model\Request $request (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffChangeARequestStatus'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function timeOffChangeARequestStatusRequest($request_id, $request, string $contentType = self::CONTENT_TYPES['timeOffChangeARequestStatus'][0]) {

		// verify the required parameter 'request_id' is set
		if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $request_id when calling timeOffChangeARequestStatus'
			);
		}

		// verify the required parameter 'request' is set
		if ($request === null || (is_array($request) && count($request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $request when calling timeOffChangeARequestStatus'
			);
		}


		$resourcePath = '/api/v1/time_off/requests/{requestId}/status';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($request_id !== null) {
			$resourcePath = str_replace(
				'{' . 'requestId' . '}',
				ObjectSerializer::toPathValue($request_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request));
			} else {
				$httpBody = $request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation timeOffEstimateFutureTimeOffBalances
	 *
	 * Estimate Future Time Off Balances
	 *
	 * @param  \DateTime $end end (required)
	 * @param  string $employee_id employee_id (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffEstimateFutureTimeOffBalances'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function timeOffEstimateFutureTimeOffBalances($end, $employee_id, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['timeOffEstimateFutureTimeOffBalances'][0]) {
		$this->timeOffEstimateFutureTimeOffBalancesWithHttpInfo($end, $employee_id, $accept_header_parameter, $contentType);
	}

	/**
	 * Operation timeOffEstimateFutureTimeOffBalancesWithHttpInfo
	 *
	 * Estimate Future Time Off Balances
	 *
	 * @param  \DateTime $end (required)
	 * @param  string $employee_id (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffEstimateFutureTimeOffBalances'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function timeOffEstimateFutureTimeOffBalancesWithHttpInfo($end, $employee_id, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['timeOffEstimateFutureTimeOffBalances'][0]) {
		$request = $this->timeOffEstimateFutureTimeOffBalancesRequest($end, $employee_id, $accept_header_parameter, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation timeOffEstimateFutureTimeOffBalancesAsync
	 *
	 * Estimate Future Time Off Balances
	 *
	 * @param  \DateTime $end (required)
	 * @param  string $employee_id (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffEstimateFutureTimeOffBalances'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffEstimateFutureTimeOffBalancesAsync($end, $employee_id, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['timeOffEstimateFutureTimeOffBalances'][0]) {
		return $this->timeOffEstimateFutureTimeOffBalancesAsyncWithHttpInfo($end, $employee_id, $accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation timeOffEstimateFutureTimeOffBalancesAsyncWithHttpInfo
	 *
	 * Estimate Future Time Off Balances
	 *
	 * @param  \DateTime $end (required)
	 * @param  string $employee_id (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffEstimateFutureTimeOffBalances'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffEstimateFutureTimeOffBalancesAsyncWithHttpInfo($end, $employee_id, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['timeOffEstimateFutureTimeOffBalances'][0]) {
		$returnType = '';
		$request = $this->timeOffEstimateFutureTimeOffBalancesRequest($end, $employee_id, $accept_header_parameter, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'timeOffEstimateFutureTimeOffBalances'
	 *
	 * @param  \DateTime $end (required)
	 * @param  string $employee_id (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffEstimateFutureTimeOffBalances'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function timeOffEstimateFutureTimeOffBalancesRequest($end, $employee_id, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['timeOffEstimateFutureTimeOffBalances'][0]) {

		// verify the required parameter 'end' is set
		if ($end === null || (is_array($end) && count($end) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $end when calling timeOffEstimateFutureTimeOffBalances'
			);
		}

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling timeOffEstimateFutureTimeOffBalances'
			);
		}



		$resourcePath = '/api/v1/employees/{employeeId}/time_off/calculator';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$end,
			'end', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);

		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation timeOffGetTimeOffRequests
	 *
	 * Get Time Off Requests
	 *
	 * @param  string $start YYYY-MM-DD. Only show time off that occurs on/after the specified start date. (required)
	 * @param  string $end YYYY-MM-DD. Only show time off that occurs on/before the specified end date. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  int|null $id A particular request ID to limit the response to. (optional)
	 * @param  string|null $action Limit to requests that the user has a particular level of access to. Legal values are: \&quot;view\&quot; or \&quot;approve\&quot;. Defaults to view. (optional)
	 * @param  string|null $employee_id A particular employee ID to limit the response to. (optional)
	 * @param  string|null $type A comma separated list of time off types IDs to include limit the response to. If omitted, requests of all types are included. (optional)
	 * @param  string|null $status A comma separated list of request status values to include. If omitted, requests of all status values are included. Legal values are \&quot;approved\&quot;, \&quot;denied\&quot;, \&quot;superceded\&quot;, \&quot;requested\&quot;, \&quot;canceled\&quot;. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffGetTimeOffRequests'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function timeOffGetTimeOffRequests($start, $end, $accept_header_parameter = null, $id = null, $action = null, $employee_id = null, $type = null, $status = null, string $contentType = self::CONTENT_TYPES['timeOffGetTimeOffRequests'][0]) {
		$this->timeOffGetTimeOffRequestsWithHttpInfo($start, $end, $accept_header_parameter, $id, $action, $employee_id, $type, $status, $contentType);
	}

	/**
	 * Operation timeOffGetTimeOffRequestsWithHttpInfo
	 *
	 * Get Time Off Requests
	 *
	 * @param  string $start YYYY-MM-DD. Only show time off that occurs on/after the specified start date. (required)
	 * @param  string $end YYYY-MM-DD. Only show time off that occurs on/before the specified end date. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  int|null $id A particular request ID to limit the response to. (optional)
	 * @param  string|null $action Limit to requests that the user has a particular level of access to. Legal values are: \&quot;view\&quot; or \&quot;approve\&quot;. Defaults to view. (optional)
	 * @param  string|null $employee_id A particular employee ID to limit the response to. (optional)
	 * @param  string|null $type A comma separated list of time off types IDs to include limit the response to. If omitted, requests of all types are included. (optional)
	 * @param  string|null $status A comma separated list of request status values to include. If omitted, requests of all status values are included. Legal values are \&quot;approved\&quot;, \&quot;denied\&quot;, \&quot;superceded\&quot;, \&quot;requested\&quot;, \&quot;canceled\&quot;. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffGetTimeOffRequests'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function timeOffGetTimeOffRequestsWithHttpInfo($start, $end, $accept_header_parameter = null, $id = null, $action = null, $employee_id = null, $type = null, $status = null, string $contentType = self::CONTENT_TYPES['timeOffGetTimeOffRequests'][0]) {
		$request = $this->timeOffGetTimeOffRequestsRequest($start, $end, $accept_header_parameter, $id, $action, $employee_id, $type, $status, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation timeOffGetTimeOffRequestsAsync
	 *
	 * Get Time Off Requests
	 *
	 * @param  string $start YYYY-MM-DD. Only show time off that occurs on/after the specified start date. (required)
	 * @param  string $end YYYY-MM-DD. Only show time off that occurs on/before the specified end date. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  int|null $id A particular request ID to limit the response to. (optional)
	 * @param  string|null $action Limit to requests that the user has a particular level of access to. Legal values are: \&quot;view\&quot; or \&quot;approve\&quot;. Defaults to view. (optional)
	 * @param  string|null $employee_id A particular employee ID to limit the response to. (optional)
	 * @param  string|null $type A comma separated list of time off types IDs to include limit the response to. If omitted, requests of all types are included. (optional)
	 * @param  string|null $status A comma separated list of request status values to include. If omitted, requests of all status values are included. Legal values are \&quot;approved\&quot;, \&quot;denied\&quot;, \&quot;superceded\&quot;, \&quot;requested\&quot;, \&quot;canceled\&quot;. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffGetTimeOffRequests'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffGetTimeOffRequestsAsync($start, $end, $accept_header_parameter = null, $id = null, $action = null, $employee_id = null, $type = null, $status = null, string $contentType = self::CONTENT_TYPES['timeOffGetTimeOffRequests'][0]) {
		return $this->timeOffGetTimeOffRequestsAsyncWithHttpInfo($start, $end, $accept_header_parameter, $id, $action, $employee_id, $type, $status, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation timeOffGetTimeOffRequestsAsyncWithHttpInfo
	 *
	 * Get Time Off Requests
	 *
	 * @param  string $start YYYY-MM-DD. Only show time off that occurs on/after the specified start date. (required)
	 * @param  string $end YYYY-MM-DD. Only show time off that occurs on/before the specified end date. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  int|null $id A particular request ID to limit the response to. (optional)
	 * @param  string|null $action Limit to requests that the user has a particular level of access to. Legal values are: \&quot;view\&quot; or \&quot;approve\&quot;. Defaults to view. (optional)
	 * @param  string|null $employee_id A particular employee ID to limit the response to. (optional)
	 * @param  string|null $type A comma separated list of time off types IDs to include limit the response to. If omitted, requests of all types are included. (optional)
	 * @param  string|null $status A comma separated list of request status values to include. If omitted, requests of all status values are included. Legal values are \&quot;approved\&quot;, \&quot;denied\&quot;, \&quot;superceded\&quot;, \&quot;requested\&quot;, \&quot;canceled\&quot;. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffGetTimeOffRequests'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffGetTimeOffRequestsAsyncWithHttpInfo($start, $end, $accept_header_parameter = null, $id = null, $action = null, $employee_id = null, $type = null, $status = null, string $contentType = self::CONTENT_TYPES['timeOffGetTimeOffRequests'][0]) {
		$returnType = '';
		$request = $this->timeOffGetTimeOffRequestsRequest($start, $end, $accept_header_parameter, $id, $action, $employee_id, $type, $status, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'timeOffGetTimeOffRequests'
	 *
	 * @param  string $start YYYY-MM-DD. Only show time off that occurs on/after the specified start date. (required)
	 * @param  string $end YYYY-MM-DD. Only show time off that occurs on/before the specified end date. (required)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  int|null $id A particular request ID to limit the response to. (optional)
	 * @param  string|null $action Limit to requests that the user has a particular level of access to. Legal values are: \&quot;view\&quot; or \&quot;approve\&quot;. Defaults to view. (optional)
	 * @param  string|null $employee_id A particular employee ID to limit the response to. (optional)
	 * @param  string|null $type A comma separated list of time off types IDs to include limit the response to. If omitted, requests of all types are included. (optional)
	 * @param  string|null $status A comma separated list of request status values to include. If omitted, requests of all status values are included. Legal values are \&quot;approved\&quot;, \&quot;denied\&quot;, \&quot;superceded\&quot;, \&quot;requested\&quot;, \&quot;canceled\&quot;. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffGetTimeOffRequests'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function timeOffGetTimeOffRequestsRequest($start, $end, $accept_header_parameter = null, $id = null, $action = null, $employee_id = null, $type = null, $status = null, string $contentType = self::CONTENT_TYPES['timeOffGetTimeOffRequests'][0]) {

		// verify the required parameter 'start' is set
		if ($start === null || (is_array($start) && count($start) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $start when calling timeOffGetTimeOffRequests'
			);
		}

		// verify the required parameter 'end' is set
		if ($end === null || (is_array($end) && count($end) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $end when calling timeOffGetTimeOffRequests'
			);
		}








		$resourcePath = '/api/v1/time_off/requests';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$id,
			'id', // param base name
			'integer', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$action,
			'action', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$employee_id,
			'employeeId', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$start,
			'start', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$end,
			'end', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			true // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$type,
			'type', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);
		// query params
		$queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
			$status,
			'status', // param base name
			'string', // openApiType
			'form', // style
			true, // explode
			false // required
		) ?? []);

		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation timeOffListTimeOffPoliciesForEmployee
	 *
	 * List Time Off Policies for Employee
	 *
	 * @param  string $employee_id employee_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function timeOffListTimeOffPoliciesForEmployee($employee_id, string $contentType = self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployee'][0]) {
		$this->timeOffListTimeOffPoliciesForEmployeeWithHttpInfo($employee_id, $contentType);
	}

	/**
	 * Operation timeOffListTimeOffPoliciesForEmployeeWithHttpInfo
	 *
	 * List Time Off Policies for Employee
	 *
	 * @param  string $employee_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function timeOffListTimeOffPoliciesForEmployeeWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployee'][0]) {
		$request = $this->timeOffListTimeOffPoliciesForEmployeeRequest($employee_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation timeOffListTimeOffPoliciesForEmployeeAsync
	 *
	 * List Time Off Policies for Employee
	 *
	 * @param  string $employee_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffListTimeOffPoliciesForEmployeeAsync($employee_id, string $contentType = self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployee'][0]) {
		return $this->timeOffListTimeOffPoliciesForEmployeeAsyncWithHttpInfo($employee_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation timeOffListTimeOffPoliciesForEmployeeAsyncWithHttpInfo
	 *
	 * List Time Off Policies for Employee
	 *
	 * @param  string $employee_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffListTimeOffPoliciesForEmployeeAsyncWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployee'][0]) {
		$returnType = '';
		$request = $this->timeOffListTimeOffPoliciesForEmployeeRequest($employee_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'timeOffListTimeOffPoliciesForEmployee'
	 *
	 * @param  string $employee_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function timeOffListTimeOffPoliciesForEmployeeRequest($employee_id, string $contentType = self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployee'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling timeOffListTimeOffPoliciesForEmployee'
			);
		}


		$resourcePath = '/api/v1/employees/{employeeId}/time_off/policies';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation timeOffListTimeOffPoliciesForEmployeeV11
	 *
	 * List Time Off Policies for Employee, Version 1.1
	 *
	 * @param  string $employee_id employee_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployeeV11'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function timeOffListTimeOffPoliciesForEmployeeV11($employee_id, string $contentType = self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployeeV11'][0]) {
		$this->timeOffListTimeOffPoliciesForEmployeeV11WithHttpInfo($employee_id, $contentType);
	}

	/**
	 * Operation timeOffListTimeOffPoliciesForEmployeeV11WithHttpInfo
	 *
	 * List Time Off Policies for Employee, Version 1.1
	 *
	 * @param  string $employee_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployeeV11'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function timeOffListTimeOffPoliciesForEmployeeV11WithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployeeV11'][0]) {
		$request = $this->timeOffListTimeOffPoliciesForEmployeeV11Request($employee_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation timeOffListTimeOffPoliciesForEmployeeV11Async
	 *
	 * List Time Off Policies for Employee, Version 1.1
	 *
	 * @param  string $employee_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployeeV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffListTimeOffPoliciesForEmployeeV11Async($employee_id, string $contentType = self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployeeV11'][0]) {
		return $this->timeOffListTimeOffPoliciesForEmployeeV11AsyncWithHttpInfo($employee_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation timeOffListTimeOffPoliciesForEmployeeV11AsyncWithHttpInfo
	 *
	 * List Time Off Policies for Employee, Version 1.1
	 *
	 * @param  string $employee_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployeeV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function timeOffListTimeOffPoliciesForEmployeeV11AsyncWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployeeV11'][0]) {
		$returnType = '';
		$request = $this->timeOffListTimeOffPoliciesForEmployeeV11Request($employee_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'timeOffListTimeOffPoliciesForEmployeeV11'
	 *
	 * @param  string $employee_id (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployeeV11'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function timeOffListTimeOffPoliciesForEmployeeV11Request($employee_id, string $contentType = self::CONTENT_TYPES['timeOffListTimeOffPoliciesForEmployeeV11'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling timeOffListTimeOffPoliciesForEmployeeV11'
			);
		}


		$resourcePath = '/api/v1_1/employees/{employeeId}/time_off/policies';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateCompanyFile
	 *
	 * Update Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the employee file being updated. (required)
	 * @param  \BhrSdk\Model\CompanyFileUpdate $company_file_update company_file_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function updateCompanyFile($file_id, $company_file_update, string $contentType = self::CONTENT_TYPES['updateCompanyFile'][0]) {
		$this->updateCompanyFileWithHttpInfo($file_id, $company_file_update, $contentType);
	}

	/**
	 * Operation updateCompanyFileWithHttpInfo
	 *
	 * Update Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the employee file being updated. (required)
	 * @param  \BhrSdk\Model\CompanyFileUpdate $company_file_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateCompanyFileWithHttpInfo($file_id, $company_file_update, string $contentType = self::CONTENT_TYPES['updateCompanyFile'][0]) {
		$request = $this->updateCompanyFileRequest($file_id, $company_file_update, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation updateCompanyFileAsync
	 *
	 * Update Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the employee file being updated. (required)
	 * @param  \BhrSdk\Model\CompanyFileUpdate $company_file_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateCompanyFileAsync($file_id, $company_file_update, string $contentType = self::CONTENT_TYPES['updateCompanyFile'][0]) {
		return $this->updateCompanyFileAsyncWithHttpInfo($file_id, $company_file_update, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateCompanyFileAsyncWithHttpInfo
	 *
	 * Update Company File
	 *
	 * @param  string $file_id {fileId} is the ID of the employee file being updated. (required)
	 * @param  \BhrSdk\Model\CompanyFileUpdate $company_file_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateCompanyFileAsyncWithHttpInfo($file_id, $company_file_update, string $contentType = self::CONTENT_TYPES['updateCompanyFile'][0]) {
		$returnType = '';
		$request = $this->updateCompanyFileRequest($file_id, $company_file_update, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateCompanyFile'
	 *
	 * @param  string $file_id {fileId} is the ID of the employee file being updated. (required)
	 * @param  \BhrSdk\Model\CompanyFileUpdate $company_file_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateCompanyFileRequest($file_id, $company_file_update, string $contentType = self::CONTENT_TYPES['updateCompanyFile'][0]) {

		// verify the required parameter 'file_id' is set
		if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $file_id when calling updateCompanyFile'
			);
		}

		// verify the required parameter 'company_file_update' is set
		if ($company_file_update === null || (is_array($company_file_update) && count($company_file_update) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $company_file_update when calling updateCompanyFile'
			);
		}


		$resourcePath = '/api/v1/files/{fileId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($file_id !== null) {
			$resourcePath = str_replace(
				'{' . 'fileId' . '}',
				ObjectSerializer::toPathValue($file_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($company_file_update)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_file_update));
			} else {
				$httpBody = $company_file_update;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateEmployee
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function updateEmployee($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		$this->updateEmployeeWithHttpInfo($id, $employee, $contentType);
	}

	/**
	 * Operation updateEmployeeWithHttpInfo
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateEmployeeWithHttpInfo($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		$request = $this->updateEmployeeRequest($id, $employee, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation updateEmployeeAsync
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeAsync($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		return $this->updateEmployeeAsyncWithHttpInfo($id, $employee, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateEmployeeAsyncWithHttpInfo
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeAsyncWithHttpInfo($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		$returnType = '';
		$request = $this->updateEmployeeRequest($id, $employee, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateEmployee'
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateEmployeeRequest($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling updateEmployee'
			);
		}

		// verify the required parameter 'employee' is set
		if ($employee === null || (is_array($employee) && count($employee) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee when calling updateEmployee'
			);
		}


		$resourcePath = '/api/v1/employees/{id}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/xml', 'application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($employee)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($employee));
			} else {
				$httpBody = $employee;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateEmployeeDependent
	 *
	 * Update an employee dependent
	 *
	 * @param  string $id {id} is the employee dependent ID. (required)
	 * @param  \BhrSdk\Model\EmployeeDependent $employee_dependent employee_dependent (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function updateEmployeeDependent($id, $employee_dependent, string $contentType = self::CONTENT_TYPES['updateEmployeeDependent'][0]) {
		$this->updateEmployeeDependentWithHttpInfo($id, $employee_dependent, $contentType);
	}

	/**
	 * Operation updateEmployeeDependentWithHttpInfo
	 *
	 * Update an employee dependent
	 *
	 * @param  string $id {id} is the employee dependent ID. (required)
	 * @param  \BhrSdk\Model\EmployeeDependent $employee_dependent (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateEmployeeDependentWithHttpInfo($id, $employee_dependent, string $contentType = self::CONTENT_TYPES['updateEmployeeDependent'][0]) {
		$request = $this->updateEmployeeDependentRequest($id, $employee_dependent, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation updateEmployeeDependentAsync
	 *
	 * Update an employee dependent
	 *
	 * @param  string $id {id} is the employee dependent ID. (required)
	 * @param  \BhrSdk\Model\EmployeeDependent $employee_dependent (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeDependentAsync($id, $employee_dependent, string $contentType = self::CONTENT_TYPES['updateEmployeeDependent'][0]) {
		return $this->updateEmployeeDependentAsyncWithHttpInfo($id, $employee_dependent, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateEmployeeDependentAsyncWithHttpInfo
	 *
	 * Update an employee dependent
	 *
	 * @param  string $id {id} is the employee dependent ID. (required)
	 * @param  \BhrSdk\Model\EmployeeDependent $employee_dependent (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeDependentAsyncWithHttpInfo($id, $employee_dependent, string $contentType = self::CONTENT_TYPES['updateEmployeeDependent'][0]) {
		$returnType = '';
		$request = $this->updateEmployeeDependentRequest($id, $employee_dependent, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateEmployeeDependent'
	 *
	 * @param  string $id {id} is the employee dependent ID. (required)
	 * @param  \BhrSdk\Model\EmployeeDependent $employee_dependent (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeDependent'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateEmployeeDependentRequest($id, $employee_dependent, string $contentType = self::CONTENT_TYPES['updateEmployeeDependent'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling updateEmployeeDependent'
			);
		}

		// verify the required parameter 'employee_dependent' is set
		if ($employee_dependent === null || (is_array($employee_dependent) && count($employee_dependent) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_dependent when calling updateEmployeeDependent'
			);
		}


		$resourcePath = '/api/v1/employeedependents/{id}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($employee_dependent)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($employee_dependent));
			} else {
				$httpBody = $employee_dependent;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateEmployeeFile
	 *
	 * Update Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being updated. (required)
	 * @param  \BhrSdk\Model\EmployeeFileUpdate $employee_file_update employee_file_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function updateEmployeeFile($id, $file_id, $employee_file_update, string $contentType = self::CONTENT_TYPES['updateEmployeeFile'][0]) {
		$this->updateEmployeeFileWithHttpInfo($id, $file_id, $employee_file_update, $contentType);
	}

	/**
	 * Operation updateEmployeeFileWithHttpInfo
	 *
	 * Update Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being updated. (required)
	 * @param  \BhrSdk\Model\EmployeeFileUpdate $employee_file_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateEmployeeFileWithHttpInfo($id, $file_id, $employee_file_update, string $contentType = self::CONTENT_TYPES['updateEmployeeFile'][0]) {
		$request = $this->updateEmployeeFileRequest($id, $file_id, $employee_file_update, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation updateEmployeeFileAsync
	 *
	 * Update Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being updated. (required)
	 * @param  \BhrSdk\Model\EmployeeFileUpdate $employee_file_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeFileAsync($id, $file_id, $employee_file_update, string $contentType = self::CONTENT_TYPES['updateEmployeeFile'][0]) {
		return $this->updateEmployeeFileAsyncWithHttpInfo($id, $file_id, $employee_file_update, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateEmployeeFileAsyncWithHttpInfo
	 *
	 * Update Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being updated. (required)
	 * @param  \BhrSdk\Model\EmployeeFileUpdate $employee_file_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeFileAsyncWithHttpInfo($id, $file_id, $employee_file_update, string $contentType = self::CONTENT_TYPES['updateEmployeeFile'][0]) {
		$returnType = '';
		$request = $this->updateEmployeeFileRequest($id, $file_id, $employee_file_update, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateEmployeeFile'
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $file_id {fileId} is the ID of the employee file being updated. (required)
	 * @param  \BhrSdk\Model\EmployeeFileUpdate $employee_file_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateEmployeeFileRequest($id, $file_id, $employee_file_update, string $contentType = self::CONTENT_TYPES['updateEmployeeFile'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling updateEmployeeFile'
			);
		}

		// verify the required parameter 'file_id' is set
		if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $file_id when calling updateEmployeeFile'
			);
		}

		// verify the required parameter 'employee_file_update' is set
		if ($employee_file_update === null || (is_array($employee_file_update) && count($employee_file_update) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_file_update when calling updateEmployeeFile'
			);
		}


		$resourcePath = '/api/v1/employees/{id}/files/{fileId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}
		// path params
		if ($file_id !== null) {
			$resourcePath = str_replace(
				'{' . 'fileId' . '}',
				ObjectSerializer::toPathValue($file_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($employee_file_update)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($employee_file_update));
			} else {
				$httpBody = $employee_file_update;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateEmployeeTableRow
	 *
	 * Updates a table row.
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function updateEmployeeTableRow($id, $table, $row_id, $table_row_update, string $contentType = self::CONTENT_TYPES['updateEmployeeTableRow'][0]) {
		$this->updateEmployeeTableRowWithHttpInfo($id, $table, $row_id, $table_row_update, $contentType);
	}

	/**
	 * Operation updateEmployeeTableRowWithHttpInfo
	 *
	 * Updates a table row.
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateEmployeeTableRowWithHttpInfo($id, $table, $row_id, $table_row_update, string $contentType = self::CONTENT_TYPES['updateEmployeeTableRow'][0]) {
		$request = $this->updateEmployeeTableRowRequest($id, $table, $row_id, $table_row_update, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation updateEmployeeTableRowAsync
	 *
	 * Updates a table row.
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeTableRowAsync($id, $table, $row_id, $table_row_update, string $contentType = self::CONTENT_TYPES['updateEmployeeTableRow'][0]) {
		return $this->updateEmployeeTableRowAsyncWithHttpInfo($id, $table, $row_id, $table_row_update, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateEmployeeTableRowAsyncWithHttpInfo
	 *
	 * Updates a table row.
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeTableRowAsyncWithHttpInfo($id, $table, $row_id, $table_row_update, string $contentType = self::CONTENT_TYPES['updateEmployeeTableRow'][0]) {
		$returnType = '';
		$request = $this->updateEmployeeTableRowRequest($id, $table, $row_id, $table_row_update, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateEmployeeTableRow'
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTableRow'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateEmployeeTableRowRequest($id, $table, $row_id, $table_row_update, string $contentType = self::CONTENT_TYPES['updateEmployeeTableRow'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling updateEmployeeTableRow'
			);
		}

		// verify the required parameter 'table' is set
		if ($table === null || (is_array($table) && count($table) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table when calling updateEmployeeTableRow'
			);
		}

		// verify the required parameter 'row_id' is set
		if ($row_id === null || (is_array($row_id) && count($row_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $row_id when calling updateEmployeeTableRow'
			);
		}

		// verify the required parameter 'table_row_update' is set
		if ($table_row_update === null || (is_array($table_row_update) && count($table_row_update) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table_row_update when calling updateEmployeeTableRow'
			);
		}


		$resourcePath = '/api/v1/employees/{id}/tables/{table}/{rowId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}
		// path params
		if ($table !== null) {
			$resourcePath = str_replace(
				'{' . 'table' . '}',
				ObjectSerializer::toPathValue($table),
				$resourcePath
			);
		}
		// path params
		if ($row_id !== null) {
			$resourcePath = str_replace(
				'{' . 'rowId' . '}',
				ObjectSerializer::toPathValue($row_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/xml', 'application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($table_row_update)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($table_row_update));
			} else {
				$httpBody = $table_row_update;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateEmployeeTableRowV
	 *
	 * Updates a table row.
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTableRowV'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function updateEmployeeTableRowV($id, $table, $row_id, $table_row_update, string $contentType = self::CONTENT_TYPES['updateEmployeeTableRowV'][0]) {
		$this->updateEmployeeTableRowVWithHttpInfo($id, $table, $row_id, $table_row_update, $contentType);
	}

	/**
	 * Operation updateEmployeeTableRowVWithHttpInfo
	 *
	 * Updates a table row.
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTableRowV'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateEmployeeTableRowVWithHttpInfo($id, $table, $row_id, $table_row_update, string $contentType = self::CONTENT_TYPES['updateEmployeeTableRowV'][0]) {
		$request = $this->updateEmployeeTableRowVRequest($id, $table, $row_id, $table_row_update, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation updateEmployeeTableRowVAsync
	 *
	 * Updates a table row.
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTableRowV'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeTableRowVAsync($id, $table, $row_id, $table_row_update, string $contentType = self::CONTENT_TYPES['updateEmployeeTableRowV'][0]) {
		return $this->updateEmployeeTableRowVAsyncWithHttpInfo($id, $table, $row_id, $table_row_update, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateEmployeeTableRowVAsyncWithHttpInfo
	 *
	 * Updates a table row.
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTableRowV'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeTableRowVAsyncWithHttpInfo($id, $table, $row_id, $table_row_update, string $contentType = self::CONTENT_TYPES['updateEmployeeTableRowV'][0]) {
		$returnType = '';
		$request = $this->updateEmployeeTableRowVRequest($id, $table, $row_id, $table_row_update, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateEmployeeTableRowV'
	 *
	 * @param  string $id {id} is the employee ID. (required)
	 * @param  string $table Table name (required)
	 * @param  string $row_id Row ID (required)
	 * @param  \BhrSdk\Model\TableRowUpdate $table_row_update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTableRowV'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateEmployeeTableRowVRequest($id, $table, $row_id, $table_row_update, string $contentType = self::CONTENT_TYPES['updateEmployeeTableRowV'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling updateEmployeeTableRowV'
			);
		}

		// verify the required parameter 'table' is set
		if ($table === null || (is_array($table) && count($table) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table when calling updateEmployeeTableRowV'
			);
		}

		// verify the required parameter 'row_id' is set
		if ($row_id === null || (is_array($row_id) && count($row_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $row_id when calling updateEmployeeTableRowV'
			);
		}

		// verify the required parameter 'table_row_update' is set
		if ($table_row_update === null || (is_array($table_row_update) && count($table_row_update) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $table_row_update when calling updateEmployeeTableRowV'
			);
		}


		$resourcePath = '/api/v1_1/employees/{id}/tables/{table}/{rowId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}
		// path params
		if ($table !== null) {
			$resourcePath = str_replace(
				'{' . 'table' . '}',
				ObjectSerializer::toPathValue($table),
				$resourcePath
			);
		}
		// path params
		if ($row_id !== null) {
			$resourcePath = str_replace(
				'{' . 'rowId' . '}',
				ObjectSerializer::toPathValue($row_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/xml', 'application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($table_row_update)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($table_row_update));
			} else {
				$httpBody = $table_row_update;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateEmployeeTrainingRecord
	 *
	 * Update Employee Training Record
	 *
	 * @param  int $employee_training_record_id The ID of the training record to update. (required)
	 * @param  \BhrSdk\Model\UpdateEmployeeTrainingRecordRequest $update_employee_training_record_request Training object to update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TrainingRecord
	 */
	public function updateEmployeeTrainingRecord($employee_training_record_id, $update_employee_training_record_request, string $contentType = self::CONTENT_TYPES['updateEmployeeTrainingRecord'][0]) {
		list($response) = $this->updateEmployeeTrainingRecordWithHttpInfo($employee_training_record_id, $update_employee_training_record_request, $contentType);
		return $response;
	}

	/**
	 * Operation updateEmployeeTrainingRecordWithHttpInfo
	 *
	 * Update Employee Training Record
	 *
	 * @param  int $employee_training_record_id The ID of the training record to update. (required)
	 * @param  \BhrSdk\Model\UpdateEmployeeTrainingRecordRequest $update_employee_training_record_request Training object to update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TrainingRecord, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateEmployeeTrainingRecordWithHttpInfo($employee_training_record_id, $update_employee_training_record_request, string $contentType = self::CONTENT_TYPES['updateEmployeeTrainingRecord'][0]) {
		$request = $this->updateEmployeeTrainingRecordRequest($employee_training_record_id, $update_employee_training_record_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TrainingRecord',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TrainingRecord',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TrainingRecord',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation updateEmployeeTrainingRecordAsync
	 *
	 * Update Employee Training Record
	 *
	 * @param  int $employee_training_record_id The ID of the training record to update. (required)
	 * @param  \BhrSdk\Model\UpdateEmployeeTrainingRecordRequest $update_employee_training_record_request Training object to update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeTrainingRecordAsync($employee_training_record_id, $update_employee_training_record_request, string $contentType = self::CONTENT_TYPES['updateEmployeeTrainingRecord'][0]) {
		return $this->updateEmployeeTrainingRecordAsyncWithHttpInfo($employee_training_record_id, $update_employee_training_record_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateEmployeeTrainingRecordAsyncWithHttpInfo
	 *
	 * Update Employee Training Record
	 *
	 * @param  int $employee_training_record_id The ID of the training record to update. (required)
	 * @param  \BhrSdk\Model\UpdateEmployeeTrainingRecordRequest $update_employee_training_record_request Training object to update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeTrainingRecordAsyncWithHttpInfo($employee_training_record_id, $update_employee_training_record_request, string $contentType = self::CONTENT_TYPES['updateEmployeeTrainingRecord'][0]) {
		$returnType = '\BhrSdk\Model\TrainingRecord';
		$request = $this->updateEmployeeTrainingRecordRequest($employee_training_record_id, $update_employee_training_record_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateEmployeeTrainingRecord'
	 *
	 * @param  int $employee_training_record_id The ID of the training record to update. (required)
	 * @param  \BhrSdk\Model\UpdateEmployeeTrainingRecordRequest $update_employee_training_record_request Training object to update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployeeTrainingRecord'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateEmployeeTrainingRecordRequest($employee_training_record_id, $update_employee_training_record_request, string $contentType = self::CONTENT_TYPES['updateEmployeeTrainingRecord'][0]) {

		// verify the required parameter 'employee_training_record_id' is set
		if ($employee_training_record_id === null || (is_array($employee_training_record_id) && count($employee_training_record_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_training_record_id when calling updateEmployeeTrainingRecord'
			);
		}

		// verify the required parameter 'update_employee_training_record_request' is set
		if ($update_employee_training_record_request === null || (is_array($update_employee_training_record_request) && count($update_employee_training_record_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $update_employee_training_record_request when calling updateEmployeeTrainingRecord'
			);
		}


		$resourcePath = '/api/v1/training/record/{employeeTrainingRecordId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_training_record_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeTrainingRecordId' . '}',
				ObjectSerializer::toPathValue($employee_training_record_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($update_employee_training_record_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_employee_training_record_request));
			} else {
				$httpBody = $update_employee_training_record_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateTrainingCategory
	 *
	 * Update Training Category
	 *
	 * @param  int $training_category_id The ID of the training category to update. (required)
	 * @param  \BhrSdk\Model\UpdateTrainingCategoryRequest $update_training_category_request Training category to update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TrainingCategory
	 */
	public function updateTrainingCategory($training_category_id, $update_training_category_request, string $contentType = self::CONTENT_TYPES['updateTrainingCategory'][0]) {
		list($response) = $this->updateTrainingCategoryWithHttpInfo($training_category_id, $update_training_category_request, $contentType);
		return $response;
	}

	/**
	 * Operation updateTrainingCategoryWithHttpInfo
	 *
	 * Update Training Category
	 *
	 * @param  int $training_category_id The ID of the training category to update. (required)
	 * @param  \BhrSdk\Model\UpdateTrainingCategoryRequest $update_training_category_request Training category to update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TrainingCategory, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateTrainingCategoryWithHttpInfo($training_category_id, $update_training_category_request, string $contentType = self::CONTENT_TYPES['updateTrainingCategory'][0]) {
		$request = $this->updateTrainingCategoryRequest($training_category_id, $update_training_category_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TrainingCategory',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TrainingCategory',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TrainingCategory',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation updateTrainingCategoryAsync
	 *
	 * Update Training Category
	 *
	 * @param  int $training_category_id The ID of the training category to update. (required)
	 * @param  \BhrSdk\Model\UpdateTrainingCategoryRequest $update_training_category_request Training category to update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateTrainingCategoryAsync($training_category_id, $update_training_category_request, string $contentType = self::CONTENT_TYPES['updateTrainingCategory'][0]) {
		return $this->updateTrainingCategoryAsyncWithHttpInfo($training_category_id, $update_training_category_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateTrainingCategoryAsyncWithHttpInfo
	 *
	 * Update Training Category
	 *
	 * @param  int $training_category_id The ID of the training category to update. (required)
	 * @param  \BhrSdk\Model\UpdateTrainingCategoryRequest $update_training_category_request Training category to update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateTrainingCategoryAsyncWithHttpInfo($training_category_id, $update_training_category_request, string $contentType = self::CONTENT_TYPES['updateTrainingCategory'][0]) {
		$returnType = '\BhrSdk\Model\TrainingCategory';
		$request = $this->updateTrainingCategoryRequest($training_category_id, $update_training_category_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateTrainingCategory'
	 *
	 * @param  int $training_category_id The ID of the training category to update. (required)
	 * @param  \BhrSdk\Model\UpdateTrainingCategoryRequest $update_training_category_request Training category to update (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateTrainingCategory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateTrainingCategoryRequest($training_category_id, $update_training_category_request, string $contentType = self::CONTENT_TYPES['updateTrainingCategory'][0]) {

		// verify the required parameter 'training_category_id' is set
		if ($training_category_id === null || (is_array($training_category_id) && count($training_category_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $training_category_id when calling updateTrainingCategory'
			);
		}

		// verify the required parameter 'update_training_category_request' is set
		if ($update_training_category_request === null || (is_array($update_training_category_request) && count($update_training_category_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $update_training_category_request when calling updateTrainingCategory'
			);
		}


		$resourcePath = '/api/v1/training/category/{trainingCategoryId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($training_category_id !== null) {
			$resourcePath = str_replace(
				'{' . 'trainingCategoryId' . '}',
				ObjectSerializer::toPathValue($training_category_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($update_training_category_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_training_category_request));
			} else {
				$httpBody = $update_training_category_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateTrainingType
	 *
	 * Update Training Type
	 *
	 * @param  int $training_type_id The ID of the training type to update. (required)
	 * @param  \BhrSdk\Model\UpdateTrainingTypeRequest $update_training_type_request Training type object to update to (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateTrainingType'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\TrainingType
	 */
	public function updateTrainingType($training_type_id, $update_training_type_request, string $contentType = self::CONTENT_TYPES['updateTrainingType'][0]) {
		list($response) = $this->updateTrainingTypeWithHttpInfo($training_type_id, $update_training_type_request, $contentType);
		return $response;
	}

	/**
	 * Operation updateTrainingTypeWithHttpInfo
	 *
	 * Update Training Type
	 *
	 * @param  int $training_type_id The ID of the training type to update. (required)
	 * @param  \BhrSdk\Model\UpdateTrainingTypeRequest $update_training_type_request Training type object to update to (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateTrainingType'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\TrainingType, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateTrainingTypeWithHttpInfo($training_type_id, $update_training_type_request, string $contentType = self::CONTENT_TYPES['updateTrainingType'][0]) {
		$request = $this->updateTrainingTypeRequest($training_type_id, $update_training_type_request, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			switch($statusCode) {
				case 200:
					return $this->handleResponseWithDataType(
						'\BhrSdk\Model\TrainingType',
						$request,
						$response,
					);
			}

			

			if ($statusCode < 200 || $statusCode > 299) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						(string) $request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					(string) $response->getBody()
				);
			}

			return $this->handleResponseWithDataType(
				'\BhrSdk\Model\TrainingType',
				$request,
				$response,
			);
		} catch (ApiException $e) {
			switch ($e->getCode()) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\BhrSdk\Model\TrainingType',
						$e->getResponseHeaders()
					);
					$e->setResponseObject($data);
					throw $e;
			}
		

			throw $e;
		}
	}

	/**
	 * Operation updateTrainingTypeAsync
	 *
	 * Update Training Type
	 *
	 * @param  int $training_type_id The ID of the training type to update. (required)
	 * @param  \BhrSdk\Model\UpdateTrainingTypeRequest $update_training_type_request Training type object to update to (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateTrainingType'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateTrainingTypeAsync($training_type_id, $update_training_type_request, string $contentType = self::CONTENT_TYPES['updateTrainingType'][0]) {
		return $this->updateTrainingTypeAsyncWithHttpInfo($training_type_id, $update_training_type_request, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateTrainingTypeAsyncWithHttpInfo
	 *
	 * Update Training Type
	 *
	 * @param  int $training_type_id The ID of the training type to update. (required)
	 * @param  \BhrSdk\Model\UpdateTrainingTypeRequest $update_training_type_request Training type object to update to (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateTrainingType'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateTrainingTypeAsyncWithHttpInfo($training_type_id, $update_training_type_request, string $contentType = self::CONTENT_TYPES['updateTrainingType'][0]) {
		$returnType = '\BhrSdk\Model\TrainingType';
		$request = $this->updateTrainingTypeRequest($training_type_id, $update_training_type_request, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					if ($returnType === '\SplFileObject') {
						$content = $response->getBody(); //stream goes to serializer
					} else {
						$content = (string) $response->getBody();
						if ($returnType !== 'string') {
							$content = json_decode($content);
						}
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateTrainingType'
	 *
	 * @param  int $training_type_id The ID of the training type to update. (required)
	 * @param  \BhrSdk\Model\UpdateTrainingTypeRequest $update_training_type_request Training type object to update to (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateTrainingType'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateTrainingTypeRequest($training_type_id, $update_training_type_request, string $contentType = self::CONTENT_TYPES['updateTrainingType'][0]) {

		// verify the required parameter 'training_type_id' is set
		if ($training_type_id === null || (is_array($training_type_id) && count($training_type_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $training_type_id when calling updateTrainingType'
			);
		}

		// verify the required parameter 'update_training_type_request' is set
		if ($update_training_type_request === null || (is_array($update_training_type_request) && count($update_training_type_request) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $update_training_type_request when calling updateTrainingType'
			);
		}


		$resourcePath = '/api/v1/training/type/{trainingTypeId}';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($training_type_id !== null) {
			$resourcePath = str_replace(
				'{' . 'trainingTypeId' . '}',
				ObjectSerializer::toPathValue($training_type_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($update_training_type_request)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_training_type_request));
			} else {
				$httpBody = $update_training_type_request;
			}
		} elseif (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'PUT',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation uploadCompanyFile
	 *
	 * Upload Company File
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function uploadCompanyFile(string $contentType = self::CONTENT_TYPES['uploadCompanyFile'][0]) {
		$this->uploadCompanyFileWithHttpInfo($contentType);
	}

	/**
	 * Operation uploadCompanyFileWithHttpInfo
	 *
	 * Upload Company File
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function uploadCompanyFileWithHttpInfo(string $contentType = self::CONTENT_TYPES['uploadCompanyFile'][0]) {
		$request = $this->uploadCompanyFileRequest($contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation uploadCompanyFileAsync
	 *
	 * Upload Company File
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function uploadCompanyFileAsync(string $contentType = self::CONTENT_TYPES['uploadCompanyFile'][0]) {
		return $this->uploadCompanyFileAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation uploadCompanyFileAsyncWithHttpInfo
	 *
	 * Upload Company File
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function uploadCompanyFileAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['uploadCompanyFile'][0]) {
		$returnType = '';
		$request = $this->uploadCompanyFileRequest($contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'uploadCompanyFile'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadCompanyFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function uploadCompanyFileRequest(string $contentType = self::CONTENT_TYPES['uploadCompanyFile'][0]) {


		$resourcePath = '/api/v1/files';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation uploadEmployeeFile
	 *
	 * Upload Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function uploadEmployeeFile($id, string $contentType = self::CONTENT_TYPES['uploadEmployeeFile'][0]) {
		$this->uploadEmployeeFileWithHttpInfo($id, $contentType);
	}

	/**
	 * Operation uploadEmployeeFileWithHttpInfo
	 *
	 * Upload Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function uploadEmployeeFileWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['uploadEmployeeFile'][0]) {
		$request = $this->uploadEmployeeFileRequest($id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation uploadEmployeeFileAsync
	 *
	 * Upload Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function uploadEmployeeFileAsync($id, string $contentType = self::CONTENT_TYPES['uploadEmployeeFile'][0]) {
		return $this->uploadEmployeeFileAsyncWithHttpInfo($id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation uploadEmployeeFileAsyncWithHttpInfo
	 *
	 * Upload Employee File
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function uploadEmployeeFileAsyncWithHttpInfo($id, string $contentType = self::CONTENT_TYPES['uploadEmployeeFile'][0]) {
		$returnType = '';
		$request = $this->uploadEmployeeFileRequest($id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'uploadEmployeeFile'
	 *
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadEmployeeFile'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function uploadEmployeeFileRequest($id, string $contentType = self::CONTENT_TYPES['uploadEmployeeFile'][0]) {

		// verify the required parameter 'id' is set
		if ($id === null || (is_array($id) && count($id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling uploadEmployeeFile'
			);
		}


		$resourcePath = '/api/v1/employees/{id}/files';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation uploadEmployeePhoto
	 *
	 * Store a new employee photo
	 *
	 * @param  string $employee_id The ID for the employee you are setting the photo for. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadEmployeePhoto'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function uploadEmployeePhoto($employee_id, string $contentType = self::CONTENT_TYPES['uploadEmployeePhoto'][0]) {
		$this->uploadEmployeePhotoWithHttpInfo($employee_id, $contentType);
	}

	/**
	 * Operation uploadEmployeePhotoWithHttpInfo
	 *
	 * Store a new employee photo
	 *
	 * @param  string $employee_id The ID for the employee you are setting the photo for. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadEmployeePhoto'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function uploadEmployeePhotoWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['uploadEmployeePhoto'][0]) {
		$request = $this->uploadEmployeePhotoRequest($employee_id, $contentType);

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send($request, $options);
			} catch (RequestException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? (string) $e->getResponse()->getBody() : null
				);
			} catch (ConnectException $e) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
			}

			$statusCode = $response->getStatusCode();


			return [null, $statusCode, $response->getHeaders()];
		} catch (ApiException $e) {
			switch ($e->getCode()) {
			}
		

			throw $e;
		}
	}

	/**
	 * Operation uploadEmployeePhotoAsync
	 *
	 * Store a new employee photo
	 *
	 * @param  string $employee_id The ID for the employee you are setting the photo for. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadEmployeePhoto'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function uploadEmployeePhotoAsync($employee_id, string $contentType = self::CONTENT_TYPES['uploadEmployeePhoto'][0]) {
		return $this->uploadEmployeePhotoAsyncWithHttpInfo($employee_id, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation uploadEmployeePhotoAsyncWithHttpInfo
	 *
	 * Store a new employee photo
	 *
	 * @param  string $employee_id The ID for the employee you are setting the photo for. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadEmployeePhoto'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function uploadEmployeePhotoAsyncWithHttpInfo($employee_id, string $contentType = self::CONTENT_TYPES['uploadEmployeePhoto'][0]) {
		$returnType = '';
		$request = $this->uploadEmployeePhotoRequest($employee_id, $contentType);

		return $this->client
			->sendAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'uploadEmployeePhoto'
	 *
	 * @param  string $employee_id The ID for the employee you are setting the photo for. (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['uploadEmployeePhoto'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function uploadEmployeePhotoRequest($employee_id, string $contentType = self::CONTENT_TYPES['uploadEmployeePhoto'][0]) {

		// verify the required parameter 'employee_id' is set
		if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $employee_id when calling uploadEmployeePhoto'
			);
		}


		$resourcePath = '/api/v1/employees/{employeeId}/photo';
		$formParams = [];
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($employee_id !== null) {
			$resourcePath = str_replace(
				'{' . 'employeeId' . '}',
				ObjectSerializer::toPathValue($employee_id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (count($formParams) > 0) {
			if ($multipart) {
				$multipartContents = [];
				foreach ($formParams as $formParamName => $formParamValue) {
					$formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
					foreach ($formParamValueItems as $formParamValueItem) {
						$multipartContents[] = [
							'name' => $formParamName,
							'contents' => $formParamValueItem
						];
					}
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream($multipartContents);

			} elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the form parameters
				$httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
			} else {
				// for HTTP post (form)
				$httpBody = ObjectSerializer::buildQuery($formParams);
			}
		}

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Create http client option
	 *
	 * @throws \RuntimeException on file opening failure
	 * @return array of http client options
	 */
	protected function createHttpClientOption() {
		$options = [];
		if ($this->config->getDebug()) {
			$options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
			if (!$options[RequestOptions::DEBUG]) {
				throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
			}
		}

		return $options;
	}

	private function handleResponseWithDataType(
		string $dataType,
		RequestInterface $request,
		ResponseInterface $response
	): array {
		if ($dataType === '\SplFileObject') {
			$content = $response->getBody(); //stream goes to serializer
		} else {
			$content = (string) $response->getBody();
			if ($dataType !== 'string') {
				try {
					$content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
				} catch (\JsonException $exception) {
					throw new ApiException(
						sprintf(
							'Error JSON decoding server response (%s)',
							$request->getUri()
						),
						$response->getStatusCode(),
						$response->getHeaders(),
						$content
					);
				}
			}
		}

		return [
			ObjectSerializer::deserialize($content, $dataType, []),
			$response->getStatusCode(),
			$response->getHeaders()
		];
	}

	private function responseWithinRangeCode(
		string $rangeCode,
		int $statusCode
	): bool {
		$left = (int) ($rangeCode[0].'00');
		$right = (int) ($rangeCode[0].'99');

		return $statusCode >= $left && $statusCode <= $right;
	}
}
