<?php
/**
 * EmployeesApi
 * PHP version 8.1
 *
 * @category Class
 * @package  BhrSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BambooHR API
 *
 * BambooHR API documentation. https://www.bamboohr.com/api/documentation/
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.15.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace BhrSdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use BhrSdk\ApiException;
use BhrSdk\Configuration;
use BhrSdk\FormDataProcessor;
use BhrSdk\HeaderSelector;
use BhrSdk\ObjectSerializer;
use BhrSdk\ApiErrorHelper;

/**
 * EmployeesApi Class Doc Comment
 *
 * @category Class
 * @package  BhrSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class EmployeesApi {
	/**
	 * @var ClientInterface
	 */
	protected $client;

	/**
	 * @var Configuration
	 */
	protected $config;

	/**
	 * @var HeaderSelector
	 */
	protected $headerSelector;

	/**
	 * @var int Host index
	 */
	protected $hostIndex;

	/** @var string[] $CONTENT_TYPES **/
	public const CONTENT_TYPES = [
		'addEmployee' => [
			'application/json',
        ],
		'getCompanyInformation' => [
			'application/json',
        ],
		'getEmployee' => [
			'application/json',
        ],
		'getEmployeesDirectory' => [
			'application/json',
        ],
		'getEmployeesList' => [
			'application/json',
        ],
		'updateEmployee' => [
			'application/json',
        ],
	];

	/**
	 * @param ClientInterface $client
	 * @param Configuration   $config
	 * @param HeaderSelector  $selector
	 * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
	 */
	public function __construct(
		?ClientInterface $client = null,
		?Configuration $config = null,
		?HeaderSelector $selector = null,
		int $hostIndex = 0
	) {
		$this->client = $client ?: new Client();
		$this->config = $config ?: Configuration::getDefaultConfiguration();
		$this->headerSelector = $selector ?: new HeaderSelector();
		$this->hostIndex = $hostIndex;
	}

	/**
	 * Set the host index
	 *
	 * @param int $hostIndex Host index (required)
	 */
	public function setHostIndex($hostIndex): void {
		$this->hostIndex = $hostIndex;
	}

	/**
	 * Get the host index
	 *
	 * @return int Host index
	 */
	public function getHostIndex() {
		return $this->hostIndex;
	}

	/**
	 * @return Configuration
	 */
	public function getConfig() {
		return $this->config;
	}

	/**
	 * Operation addEmployee
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function addEmployee($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		$this->addEmployeeWithHttpInfo($post_new_employee, $contentType);
	}

	/**
	 * Operation addEmployeeWithHttpInfo
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addEmployeeWithHttpInfo($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		$request = $this->addEmployeeRequest($post_new_employee, $contentType);
		$options = $this->createHttpClientOption();
		
		// Send request with retry support for timeout errors
		$response = $this->sendRequestWithRetries($request, $options);

		$statusCode = $response->getStatusCode();


		return [null, $statusCode, $response->getHeaders()];
	}

	/**
	 * Operation addEmployeeAsync
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeAsync($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		return $this->addEmployeeAsyncWithHttpInfo($post_new_employee, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addEmployeeAsyncWithHttpInfo
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeAsyncWithHttpInfo($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		
		$request = $this->addEmployeeRequest($post_new_employee, $contentType);

		return $this->sendRequestWithRetriesAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addEmployee'
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addEmployeeRequest($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		// PHP 8.0+ only
		$this->validateRequiredParameters(
			params: [
				'post_new_employee' => $post_new_employee,
			],
			methodName: 'addEmployee'
		);



		$resourcePath = '/api/v1/employees';
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($post_new_employee)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_new_employee));
			} else {
				$httpBody = $post_new_employee;
			}
		} 

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getCompanyInformation
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetCompanyInformation200Response
	 */
	public function getCompanyInformation(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		list($response) = $this->getCompanyInformationWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation getCompanyInformationWithHttpInfo
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetCompanyInformation200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getCompanyInformationWithHttpInfo(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		$request = $this->getCompanyInformationRequest($contentType);
		$options = $this->createHttpClientOption();
		
		// Send request with retry support for timeout errors
		$response = $this->sendRequestWithRetries($request, $options);

		$statusCode = $response->getStatusCode();


		switch($statusCode) {
			case 200:
				return $this->handleResponseWithDataType(
					'\BhrSdk\Model\GetCompanyInformation200Response',
					$request,
					$response,
				);
		}

		

		if ($statusCode < 200 || $statusCode > 299) {
			throw new ApiException(
				sprintf(
					'[%d] Error connecting to the API (%s)',
					$statusCode,
					(string) $request->getUri()
				),
				$statusCode,
				$response->getHeaders(),
				(string) $response->getBody()
			);
		}

		return $this->handleResponseWithDataType(
			'\BhrSdk\Model\GetCompanyInformation200Response',
			$request,
			$response,
		);
	}

	/**
	 * Operation getCompanyInformationAsync
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyInformationAsync(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		return $this->getCompanyInformationAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getCompanyInformationAsyncWithHttpInfo
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyInformationAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		$returnType = '\BhrSdk\Model\GetCompanyInformation200Response';
		$request = $this->getCompanyInformationRequest($contentType);

		return $this->sendRequestWithRetriesAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					$content = (string) $response->getBody();
					if ($returnType !== 'string') {
						$content = json_decode($content);
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getCompanyInformation'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getCompanyInformationRequest(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {


		$resourcePath = '/api/v1/company_information';
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;





		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);


		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getEmployee
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array<string,mixed>
	 */
	public function getEmployee($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		list($response) = $this->getEmployeeWithHttpInfo($fields, $id, $only_current, $accept_header_parameter, $contentType);
		return $response;
	}

	/**
	 * Operation getEmployeeWithHttpInfo
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeeWithHttpInfo($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		$request = $this->getEmployeeRequest($fields, $id, $only_current, $accept_header_parameter, $contentType);
		$options = $this->createHttpClientOption();
		
		// Send request with retry support for timeout errors
		$response = $this->sendRequestWithRetries($request, $options);

		$statusCode = $response->getStatusCode();


		switch($statusCode) {
			case 200:
				return $this->handleResponseWithDataType(
					'array<string,mixed>',
					$request,
					$response,
				);
		}

		

		if ($statusCode < 200 || $statusCode > 299) {
			throw new ApiException(
				sprintf(
					'[%d] Error connecting to the API (%s)',
					$statusCode,
					(string) $request->getUri()
				),
				$statusCode,
				$response->getHeaders(),
				(string) $response->getBody()
			);
		}

		return $this->handleResponseWithDataType(
			'array<string,mixed>',
			$request,
			$response,
		);
	}

	/**
	 * Operation getEmployeeAsync
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeAsync($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		return $this->getEmployeeAsyncWithHttpInfo($fields, $id, $only_current, $accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeeAsyncWithHttpInfo
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeAsyncWithHttpInfo($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		$returnType = 'array<string,mixed>';
		$request = $this->getEmployeeRequest($fields, $id, $only_current, $accept_header_parameter, $contentType);

		return $this->sendRequestWithRetriesAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					$content = (string) $response->getBody();
					if ($returnType !== 'string') {
						$content = json_decode($content);
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployee'
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeeRequest($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		// PHP 8.0+ only
		$this->validateRequiredParameters(
			params: [
				'fields' => $fields,
				'id' => $id,
			],
			methodName: 'getEmployee'
		);






		$resourcePath = '/api/v1/employees/{id}';
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		$parameters = [
			'fields' => ['value' => $fields, 'type' => 'string', 'required' => true, 'style' => 'form', 'explode' => true],
			'onlyCurrent' => ['value' => $only_current, 'type' => 'boolean', 'required' => false, 'style' => 'form', 'explode' => true],
		];

		// Process parameters and build query values directly
		$queryParams = [];

		foreach ($parameters as $paramName => $config) {
			$value = ObjectSerializer::toQueryValue($config['value'], $paramName, $config['type'], $config['style'], $config['explode'], $config['required']);
			
			if ($value !== null) {
				// Merge each parameter value directly into queryParams
				$queryParams = array_merge($queryParams, $value);
			}
		}

		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);


		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getEmployeesDirectory
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetEmployeesDirectory200Response
	 */
	public function getEmployeesDirectory($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		list($response) = $this->getEmployeesDirectoryWithHttpInfo($accept_header_parameter, $contentType);
		return $response;
	}

	/**
	 * Operation getEmployeesDirectoryWithHttpInfo
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetEmployeesDirectory200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeesDirectoryWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		$request = $this->getEmployeesDirectoryRequest($accept_header_parameter, $contentType);
		$options = $this->createHttpClientOption();
		
		// Send request with retry support for timeout errors
		$response = $this->sendRequestWithRetries($request, $options);

		$statusCode = $response->getStatusCode();


		switch($statusCode) {
			case 200:
				return $this->handleResponseWithDataType(
					'\BhrSdk\Model\GetEmployeesDirectory200Response',
					$request,
					$response,
				);
		}

		

		if ($statusCode < 200 || $statusCode > 299) {
			throw new ApiException(
				sprintf(
					'[%d] Error connecting to the API (%s)',
					$statusCode,
					(string) $request->getUri()
				),
				$statusCode,
				$response->getHeaders(),
				(string) $response->getBody()
			);
		}

		return $this->handleResponseWithDataType(
			'\BhrSdk\Model\GetEmployeesDirectory200Response',
			$request,
			$response,
		);
	}

	/**
	 * Operation getEmployeesDirectoryAsync
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeesDirectoryAsync($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		return $this->getEmployeesDirectoryAsyncWithHttpInfo($accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeesDirectoryAsyncWithHttpInfo
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeesDirectoryAsyncWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		$returnType = '\BhrSdk\Model\GetEmployeesDirectory200Response';
		$request = $this->getEmployeesDirectoryRequest($accept_header_parameter, $contentType);

		return $this->sendRequestWithRetriesAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					$content = (string) $response->getBody();
					if ($returnType !== 'string') {
						$content = json_decode($content);
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployeesDirectory'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeesDirectoryRequest($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {



		$resourcePath = '/api/v1/employees/directory';
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;


		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}



		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);


		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation getEmployeesList
	 *
	 * Get Employees
	 *
	 * @param  \BhrSdk\Model\GetEmployeesFilterRequestObject|null $filter Filters used to match employees. Encode filter properties using deepObject style. If the caller does not have access to the filtered field on a matching employee, that employee is excluded from the results to avoid leaking sensitive data. (optional)
	 * @param  string|null $sort Comma-separated list of sortable fields. Prefix a field with \&quot;-\&quot; for descending order. Allowed fields: &#x60;employeeId&#x60;, &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;preferredName&#x60;, &#x60;jobTitleName&#x60;, &#x60;status&#x60;. Nulls sort first in ascending order and last in descending order. If the caller does not have access to the sort field for an employee, that employee is excluded from the final result set to avoid leaking sensitive information. (optional)
	 * @param  \BhrSdk\Model\CursorPaginationQueryObject|null $page Cursor-based pagination parameters (&#x60;limit&#x60;, &#x60;after&#x60;, &#x60;before&#x60;). (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesList'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetEmployeesResponseObject|\BhrSdk\Model\GetEmployeesList400Response
	 */
	public function getEmployeesList($filter = null, $sort = null, $page = null, string $contentType = self::CONTENT_TYPES['getEmployeesList'][0]) {
		list($response) = $this->getEmployeesListWithHttpInfo($filter, $sort, $page, $contentType);
		return $response;
	}

	/**
	 * Operation getEmployeesListWithHttpInfo
	 *
	 * Get Employees
	 *
	 * @param  \BhrSdk\Model\GetEmployeesFilterRequestObject|null $filter Filters used to match employees. Encode filter properties using deepObject style. If the caller does not have access to the filtered field on a matching employee, that employee is excluded from the results to avoid leaking sensitive data. (optional)
	 * @param  string|null $sort Comma-separated list of sortable fields. Prefix a field with \&quot;-\&quot; for descending order. Allowed fields: &#x60;employeeId&#x60;, &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;preferredName&#x60;, &#x60;jobTitleName&#x60;, &#x60;status&#x60;. Nulls sort first in ascending order and last in descending order. If the caller does not have access to the sort field for an employee, that employee is excluded from the final result set to avoid leaking sensitive information. (optional)
	 * @param  \BhrSdk\Model\CursorPaginationQueryObject|null $page Cursor-based pagination parameters (&#x60;limit&#x60;, &#x60;after&#x60;, &#x60;before&#x60;). (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesList'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetEmployeesResponseObject|\BhrSdk\Model\GetEmployeesList400Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeesListWithHttpInfo($filter = null, $sort = null, $page = null, string $contentType = self::CONTENT_TYPES['getEmployeesList'][0]) {
		$request = $this->getEmployeesListRequest($filter, $sort, $page, $contentType);
		$options = $this->createHttpClientOption();
		
		// Send request with retry support for timeout errors
		$response = $this->sendRequestWithRetries($request, $options);

		$statusCode = $response->getStatusCode();


		switch($statusCode) {
			case 200:
				return $this->handleResponseWithDataType(
					'\BhrSdk\Model\GetEmployeesResponseObject',
					$request,
					$response,
				);
			case 400:
				return $this->handleResponseWithDataType(
					'\BhrSdk\Model\GetEmployeesList400Response',
					$request,
					$response,
				);
		}

		

		if ($statusCode < 200 || $statusCode > 299) {
			throw new ApiException(
				sprintf(
					'[%d] Error connecting to the API (%s)',
					$statusCode,
					(string) $request->getUri()
				),
				$statusCode,
				$response->getHeaders(),
				(string) $response->getBody()
			);
		}

		return $this->handleResponseWithDataType(
			'\BhrSdk\Model\GetEmployeesResponseObject',
			$request,
			$response,
		);
	}

	/**
	 * Operation getEmployeesListAsync
	 *
	 * Get Employees
	 *
	 * @param  \BhrSdk\Model\GetEmployeesFilterRequestObject|null $filter Filters used to match employees. Encode filter properties using deepObject style. If the caller does not have access to the filtered field on a matching employee, that employee is excluded from the results to avoid leaking sensitive data. (optional)
	 * @param  string|null $sort Comma-separated list of sortable fields. Prefix a field with \&quot;-\&quot; for descending order. Allowed fields: &#x60;employeeId&#x60;, &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;preferredName&#x60;, &#x60;jobTitleName&#x60;, &#x60;status&#x60;. Nulls sort first in ascending order and last in descending order. If the caller does not have access to the sort field for an employee, that employee is excluded from the final result set to avoid leaking sensitive information. (optional)
	 * @param  \BhrSdk\Model\CursorPaginationQueryObject|null $page Cursor-based pagination parameters (&#x60;limit&#x60;, &#x60;after&#x60;, &#x60;before&#x60;). (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesList'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeesListAsync($filter = null, $sort = null, $page = null, string $contentType = self::CONTENT_TYPES['getEmployeesList'][0]) {
		return $this->getEmployeesListAsyncWithHttpInfo($filter, $sort, $page, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeesListAsyncWithHttpInfo
	 *
	 * Get Employees
	 *
	 * @param  \BhrSdk\Model\GetEmployeesFilterRequestObject|null $filter Filters used to match employees. Encode filter properties using deepObject style. If the caller does not have access to the filtered field on a matching employee, that employee is excluded from the results to avoid leaking sensitive data. (optional)
	 * @param  string|null $sort Comma-separated list of sortable fields. Prefix a field with \&quot;-\&quot; for descending order. Allowed fields: &#x60;employeeId&#x60;, &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;preferredName&#x60;, &#x60;jobTitleName&#x60;, &#x60;status&#x60;. Nulls sort first in ascending order and last in descending order. If the caller does not have access to the sort field for an employee, that employee is excluded from the final result set to avoid leaking sensitive information. (optional)
	 * @param  \BhrSdk\Model\CursorPaginationQueryObject|null $page Cursor-based pagination parameters (&#x60;limit&#x60;, &#x60;after&#x60;, &#x60;before&#x60;). (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesList'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeesListAsyncWithHttpInfo($filter = null, $sort = null, $page = null, string $contentType = self::CONTENT_TYPES['getEmployeesList'][0]) {
		$returnType = '\BhrSdk\Model\GetEmployeesResponseObject';
		$request = $this->getEmployeesListRequest($filter, $sort, $page, $contentType);

		return $this->sendRequestWithRetriesAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) use ($returnType) {
					$content = (string) $response->getBody();
					if ($returnType !== 'string') {
						$content = json_decode($content);
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployeesList'
	 *
	 * @param  \BhrSdk\Model\GetEmployeesFilterRequestObject|null $filter Filters used to match employees. Encode filter properties using deepObject style. If the caller does not have access to the filtered field on a matching employee, that employee is excluded from the results to avoid leaking sensitive data. (optional)
	 * @param  string|null $sort Comma-separated list of sortable fields. Prefix a field with \&quot;-\&quot; for descending order. Allowed fields: &#x60;employeeId&#x60;, &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;preferredName&#x60;, &#x60;jobTitleName&#x60;, &#x60;status&#x60;. Nulls sort first in ascending order and last in descending order. If the caller does not have access to the sort field for an employee, that employee is excluded from the final result set to avoid leaking sensitive information. (optional)
	 * @param  \BhrSdk\Model\CursorPaginationQueryObject|null $page Cursor-based pagination parameters (&#x60;limit&#x60;, &#x60;after&#x60;, &#x60;before&#x60;). (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesList'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeesListRequest($filter = null, $sort = null, $page = null, string $contentType = self::CONTENT_TYPES['getEmployeesList'][0]) {





		$resourcePath = '/api/v1/employees';
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		$parameters = [
			'filter' => ['value' => $filter, 'type' => 'object', 'required' => false, 'style' => 'deepObject', 'explode' => true],
			'sort' => ['value' => $sort, 'type' => 'string', 'required' => false, 'style' => 'form', 'explode' => true],
			'page' => ['value' => $page, 'type' => 'object', 'required' => false, 'style' => 'deepObject', 'explode' => true],
		];

		// Process parameters and build query values directly
		$queryParams = [];

		foreach ($parameters as $paramName => $config) {
			$value = ObjectSerializer::toQueryValue($config['value'], $paramName, $config['type'], $config['style'], $config['explode'], $config['required']);
			
			if ($value !== null) {
				// Merge each parameter value directly into queryParams
				$queryParams = array_merge($queryParams, $value);
			}
		}




		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);


		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateEmployee
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function updateEmployee($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		$this->updateEmployeeWithHttpInfo($id, $employee, $contentType);
	}

	/**
	 * Operation updateEmployeeWithHttpInfo
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateEmployeeWithHttpInfo($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		$request = $this->updateEmployeeRequest($id, $employee, $contentType);
		$options = $this->createHttpClientOption();
		
		// Send request with retry support for timeout errors
		$response = $this->sendRequestWithRetries($request, $options);

		$statusCode = $response->getStatusCode();


		return [null, $statusCode, $response->getHeaders()];
	}

	/**
	 * Operation updateEmployeeAsync
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeAsync($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		return $this->updateEmployeeAsyncWithHttpInfo($id, $employee, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateEmployeeAsyncWithHttpInfo
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeAsyncWithHttpInfo($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		
		$request = $this->updateEmployeeRequest($id, $employee, $contentType);

		return $this->sendRequestWithRetriesAsync($request, $this->createHttpClientOption())
			->then(
				function ($response) {
					return [null, $response->getStatusCode(), $response->getHeaders()];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateEmployee'
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateEmployeeRequest($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		// PHP 8.0+ only
		$this->validateRequiredParameters(
			params: [
				'id' => $id,
				'employee' => $employee,
			],
			methodName: 'updateEmployee'
		);




		$resourcePath = '/api/v1/employees/{id}';
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;



		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue($id),
				$resourcePath
			);
		}


		$headers = $this->headerSelector->selectHeaders(
			['application/xml', 'application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($employee)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($employee));
			} else {
				$httpBody = $employee;
			}
		} 

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			$httpBody
		);
	}

	/**
	 * Create http client option
	 *
	 * @throws \RuntimeException on file opening failure
	 * @return array of http client options
	 */
	protected function createHttpClientOption() {
		$options = [];
		if ($this->config->getDebug()) {
			$options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
			if (!$options[RequestOptions::DEBUG]) {
				throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
			}
		}

		return $options;
	}
	
	/**
	 * Send a request with support for timeout retries
	 *
	 * @param RequestInterface $request The request to send
	 * @param array $options Request options to apply to the given request
	 *
	 * @throws ApiException on non-2xx response
	 * @return ResponseInterface
	 */
	protected function sendRequestWithRetries(RequestInterface $request, array $options): ResponseInterface {
		// Get the configured number of retries for timeout errors
		$retries = $this->config->getRetries();
		$attempt = 0;
		$timeoutStatusCodes = $this->config->getRetryableStatusCodes();
		
		do {
			$attempt++;
			try {
				$response = $this->client->send($request, $options);
				// If we get here, the request was successful, so break out of the retry loop
				return $response;
			} catch (RequestException $e) {
				$statusCode = $e->getResponse() ? $e->getResponse()->getStatusCode() : 0;
				
				// Check if this is a timeout error and if we should retry
				if (in_array($statusCode, $timeoutStatusCodes) && $attempt <= $retries) {
					// Wait before retrying (simple exponential backoff)
					usleep(100000 * pow(2, $attempt - 1)); // 100ms, 200ms, 400ms, etc.
					continue;
				}

				$exception = ApiErrorHelper::createException(
					(int)$e->getCode(), 
					$e->getMessage(), 
					$statusCode, 
					$e->getResponse() ? $e->getResponse()->getHeaders() : null, 
					$e->getResponse() ? $e->getResponse()->getBody() : null			
				);
				
				throw $exception;
			} catch (ConnectException $e) {
				// Connection exceptions can also be timeout-related
				if ($attempt <= $retries) {
					// Wait before retrying (simple exponential backoff)
					usleep(100000 * pow(2, $attempt - 1)); // 100ms, 200ms, 400ms, etc.
					continue;
				}
				
				$eInner = new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					(int) $e->getCode(),
					null,
					null
				);
				$data = ObjectSerializer::deserialize($eInner->getResponseBody(), '', $eInner->getResponseHeaders());
				$eInner->setResponseObject($data);

				throw $eInner;
			}
		} while ($attempt <= $retries);
		
		throw new ApiException(
			'Request failed after maximum retries',
			0,
			null,
			null
		);
	}

	/**
	 * Send an asynchronous request with support for timeout retries
	 *
	 * @param RequestInterface $request The request to send
	 * @param array $options Request options to apply to the given request
	 *
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	protected function sendRequestWithRetriesAsync(RequestInterface $request, array $options): \GuzzleHttp\Promise\PromiseInterface {
		// Get the configured number of retries for timeout errors
		$retries = $this->config->getRetries();
		$timeoutStatusCodes = $this->config->getRetryableStatusCodes();
		$attempt = 0;
		
		$doRequest = function () use ($request, $options, &$attempt, $retries, $timeoutStatusCodes, &$doRequest) {
			$attempt++;
			
			return $this->client->sendAsync($request, $options)
				->otherwise(function ($reason) use ($request, $options, $attempt, $retries, $timeoutStatusCodes, $doRequest) {
					// Check if this is a RequestException with a response
					if ($reason instanceof RequestException && $reason->hasResponse()) {
						$statusCode = $reason->getResponse()->getStatusCode();

						// Check if this is a timeout error and if we should retry
						if (in_array($statusCode, $timeoutStatusCodes) && $attempt <= $retries) {
							// Calculate delay with exponential backoff (similar to the sync version)
							$options['delay'] = 100 * pow(2, $attempt - 1); // 100ms, 200ms, 400ms, etc.

							return $doRequest(); // Try again with delay
						}
					}
					
					// For ConnectException (timeout-related)
					if ($reason instanceof ConnectException && $attempt <= $retries) {
						// Calculate delay with exponential backoff (similar to the sync version)
						$options['delay'] = 100 * pow(2, $attempt - 1); // 100ms, 200ms, 400ms, etc.

						return $doRequest(); // Try again with delay
					}
					
					// If we can't retry or have exceeded retries, create a proper ApiException
					if ($reason instanceof RequestException) {
						$exception = ApiErrorHelper::createException(
							(int)$reason->getCode(), 
							$reason->getMessage(), 
							$statusCode, 
							$reason->getResponse() ? $reason->getResponse()->getHeaders() : null, 
							$reason->getResponse() ? $reason->getResponse()->getBody() : null
						);
						
						return \GuzzleHttp\Promise\Create::rejectionFor($exception);
					} elseif ($reason instanceof ConnectException) {
						$eInner = new ApiException(
							"[{$reason->getCode()}] {$reason->getMessage()}",
							(int) $reason->getCode(),
							null,
							null
						);
						$data = ObjectSerializer::deserialize($eInner->getResponseBody(), '', $eInner->getResponseHeaders());
						$eInner->setResponseObject($data);
						return \GuzzleHttp\Promise\Create::rejectionFor($eInner);
					} else {
						// For any other type of exception, just reject with the original reason
						return \GuzzleHttp\Promise\Create::rejectionFor($reason);
					}
				});
		};
		
		return $doRequest();
	}

	private function handleResponseWithDataType(
		string $dataType,
		RequestInterface $request,
		ResponseInterface $response
	): array {
		if ($dataType === '\SplFileObject') {
			$content = $response->getBody(); //stream goes to serializer
		} else {
			$content = (string) $response->getBody();
			if ($dataType !== 'string') {
				try {
					$content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
				} catch (\JsonException $exception) {
					throw new ApiException(
						sprintf(
							'Error JSON decoding server response (%s)',
							$request->getUri()
						),
						$response->getStatusCode(),
						$response->getHeaders(),
						$content
					);
				}
			}
		}

		return [
			ObjectSerializer::deserialize($content, $dataType, []),
			$response->getStatusCode(),
			$response->getHeaders()
		];
	}

	private function responseWithinRangeCode(
		string $rangeCode,
		int $statusCode
	): bool {
		$left = (int) ($rangeCode[0].'00');
		$right = (int) ($rangeCode[0].'99');

		return $statusCode >= $left && $statusCode <= $right;
	}

	/**
	* Validates required parameters and throws an exception if any are missing
	* 
	* @param array $params Associative array of parameter name => value pairs
	* @param string $methodName Name of the calling method for error messages
	* @throws \InvalidArgumentException If any required parameter is missing
	*/
	private function validateRequiredParameters(array $params, string $methodName): void {
		foreach ($params as $paramName => $paramValue) {
			if ($paramValue === null || (is_array($paramValue) && count($paramValue) === 0)) {
				throw new \InvalidArgumentException(
					"Missing the required parameter \${$paramName} when calling {$methodName}"
				);
			}
		}
	}
}
