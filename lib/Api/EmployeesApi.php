<?php
declare(strict_types=1);
/**
 * EmployeesApi
 * PHP version 8.1
 *
 * @category Class
 * @package  BhrSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BambooHR API
 *
 * BambooHR API documentation. https://www.bamboohr.com/api/documentation/
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace BhrSdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use BhrSdk\ApiException;
use BhrSdk\Configuration;
use BhrSdk\FormDataProcessor;
use BhrSdk\HeaderSelector;
use BhrSdk\ObjectSerializer;
use BhrSdk\Client\Logger\LoggerInterface;
use BhrSdk\ApiHelper;

/**
 * EmployeesApi Class Doc Comment
 *
 * @category Class
 * @package  BhrSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class EmployeesApi {
	/**
	 * @var ClientInterface
	 */
	protected $client;

	/**
	 * @var Configuration
	 */
	protected $config;

	/**
	 * @var HeaderSelector
	 */
	protected $headerSelector;

	/**
	 * @var int Host index
	 */
	protected $hostIndex;

	/**
	 * @var LoggerInterface|null Logger instance
	 */
	protected $logger;

	/** @var string[] $CONTENT_TYPES **/
	public const CONTENT_TYPES = [
		'addEmployee' => [
			'application/json',
        ],
		'getCompanyInformation' => [
			'application/json',
        ],
		'getEmployee' => [
			'application/json',
        ],
		'getEmployeesDirectory' => [
			'application/json',
        ],
		'getEmployeesList' => [
			'application/json',
        ],
		'updateEmployee' => [
			'application/json',
        ],
	];

	/**
	 * @param ClientInterface $client
	 * @param Configuration   $config
	 * @param HeaderSelector  $selector
	 * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
	 * @param LoggerInterface|null $logger (Optional) logger instance for secure logging
	 */
	public function __construct(
		?ClientInterface $client = null,
		?Configuration $config = null,
		?HeaderSelector $selector = null,
		int $hostIndex = 0,
		?LoggerInterface $logger = null
	) {
		$this->client = $client ?: new Client();
		$this->config = $config ?: Configuration::getDefaultConfiguration();
		$this->headerSelector = $selector ?: new HeaderSelector();
		$this->hostIndex = $hostIndex;
		$this->logger = $logger;
	}

	/**
	 * Set the host index
	 *
	 * @param int $hostIndex Host index (required)
	 */
	public function setHostIndex($hostIndex): void {
		$this->hostIndex = $hostIndex;
	}

	/**
	 * Get the host index
	 *
	 * @return int Host index
	 */
	public function getHostIndex() {
		return $this->hostIndex;
	}

	/**
	 * @return Configuration
	 */
	public function getConfig() {
		return $this->config;
	}

	/**
	 * Operation addEmployee
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function addEmployee($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		$this->addEmployeeWithHttpInfo($post_new_employee, $contentType);
	}

	/**
	 * Operation addEmployeeWithHttpInfo
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function addEmployeeWithHttpInfo($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		$request = $this->addEmployeeRequest($post_new_employee, $contentType);
		$options = ApiHelper::createHttpClientOption($this->config);
		
		// Send request with retry support for timeout errors
		$response = ApiHelper::sendRequestWithRetries($this->logger, $this->client, $this->config, $request, $options);

		$statusCode = $response->getStatusCode();

		return ApiHelper::handleResponseWithDataType(
			'object', // or 'mixed' or any other generic type
			$request,
			$response,
		);
	}

	/**
	 * Operation addEmployeeAsync
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeAsync($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		return $this->addEmployeeAsyncWithHttpInfo($post_new_employee, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation addEmployeeAsyncWithHttpInfo
	 *
	 * Add Employee
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function addEmployeeAsyncWithHttpInfo($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		
		$request = $this->addEmployeeRequest($post_new_employee, $contentType);

		return ApiHelper::sendRequestWithRetriesAsync($this->logger, $this->client, $this->config, $request, ApiHelper::createHttpClientOption($this->config))
			->then(
				function ($response) {
					$content = (string) $response->getBody();
					$content = json_decode($content);

					return [
						ObjectSerializer::deserialize($content, 'object', []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'addEmployee'
	 *
	 * @param  \BhrSdk\Model\PostNewEmployee $post_new_employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['addEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function addEmployeeRequest($post_new_employee, string $contentType = self::CONTENT_TYPES['addEmployee'][0]) {
		// PHP 8.0+ only
		ApiHelper::validateRequiredParameters(
			params: [
				'post_new_employee' => $post_new_employee,
			],
			methodName: 'addEmployee'
		);

		$resourcePath = '/api/v1/employees';
		$this->logger->info('Request method: [POST], URL: ' . $resourcePath);
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($post_new_employee)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_new_employee));
			} else {
				$httpBody = is_array($post_new_employee) ? json_encode($post_new_employee) : $post_new_employee;
			}
		} 

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$this->logger->info('Using Basic authentication');	
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$this->logger->info('Using Bearer authentication');
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$this->logger->debug('Using User-Agent: ' . $this->config->getUserAgent());	
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		/** @phpstan-ignore-next-line */
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$this->logger->debug('Overriding Accept header: ' . $accept_header_parameter);
			/** @phpstan-ignore-next-line */
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			is_string($httpBody) ? $httpBody : (string)$httpBody
		);
	}

	/**
	 * Operation getCompanyInformation
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetCompanyInformation200Response
	 */
	public function getCompanyInformation(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		list($response) = $this->getCompanyInformationWithHttpInfo($contentType);
		return $response;
	}

	/**
	 * Operation getCompanyInformationWithHttpInfo
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetCompanyInformation200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getCompanyInformationWithHttpInfo(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		$request = $this->getCompanyInformationRequest($contentType);
		$options = ApiHelper::createHttpClientOption($this->config);
		
		// Send request with retry support for timeout errors
		$response = ApiHelper::sendRequestWithRetries($this->logger, $this->client, $this->config, $request, $options);

		$statusCode = $response->getStatusCode();

		switch($statusCode) {
			case 200:
				return ApiHelper::handleResponseWithDataType(
					'\BhrSdk\Model\GetCompanyInformation200Response',
					$request,
					$response,
				);
		}

		if ($statusCode < 200 || $statusCode > 299) {
			throw new ApiException(
				sprintf(
					'[%d] Error connecting to the API (%s)',
					$statusCode,
					(string) $request->getUri()
				),
				$statusCode,
				$response->getHeaders(),
				(string) $response->getBody()
			);
		}

		return ApiHelper::handleResponseWithDataType(
			'\BhrSdk\Model\GetCompanyInformation200Response',
			$request,
			$response,
		);
	}

	/**
	 * Operation getCompanyInformationAsync
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyInformationAsync(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		return $this->getCompanyInformationAsyncWithHttpInfo($contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getCompanyInformationAsyncWithHttpInfo
	 *
	 * Get Company Information
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getCompanyInformationAsyncWithHttpInfo(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {
		$returnType = '\BhrSdk\Model\GetCompanyInformation200Response';
		$request = $this->getCompanyInformationRequest($contentType);

		return ApiHelper::sendRequestWithRetriesAsync($this->logger, $this->client, $this->config, $request, ApiHelper::createHttpClientOption($this->config))
			->then(
				function ($response) use ($returnType) {
					$content = (string) $response->getBody();
					if ($returnType !== 'string') {
						$content = json_decode($content);
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getCompanyInformation'
	 *
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getCompanyInformation'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getCompanyInformationRequest(string $contentType = self::CONTENT_TYPES['getCompanyInformation'][0]) {

		$resourcePath = '/api/v1/company_information';
		$this->logger->info('Request method: [GET], URL: ' . $resourcePath);
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$this->logger->info('Using Basic authentication');	
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$this->logger->info('Using Bearer authentication');
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$this->logger->debug('Using User-Agent: ' . $this->config->getUserAgent());	
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		/** @phpstan-ignore-next-line */
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$this->logger->debug('Overriding Accept header: ' . $accept_header_parameter);
			/** @phpstan-ignore-next-line */
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			is_string($httpBody) ? $httpBody : (string)$httpBody
		);
	}

	/**
	 * Operation getEmployee
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array<string,mixed>
	 */
	public function getEmployee($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		list($response) = $this->getEmployeeWithHttpInfo($fields, $id, $only_current, $accept_header_parameter, $contentType);
		return $response;
	}

	/**
	 * Operation getEmployeeWithHttpInfo
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeeWithHttpInfo($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		$request = $this->getEmployeeRequest($fields, $id, $only_current, $accept_header_parameter, $contentType);
		$options = ApiHelper::createHttpClientOption($this->config);
		
		// Send request with retry support for timeout errors
		$response = ApiHelper::sendRequestWithRetries($this->logger, $this->client, $this->config, $request, $options);

		$statusCode = $response->getStatusCode();

		switch($statusCode) {
			case 200:
				return ApiHelper::handleResponseWithDataType(
					'array<string,mixed>',
					$request,
					$response,
				);
		}

		if ($statusCode < 200 || $statusCode > 299) {
			throw new ApiException(
				sprintf(
					'[%d] Error connecting to the API (%s)',
					$statusCode,
					(string) $request->getUri()
				),
				$statusCode,
				$response->getHeaders(),
				(string) $response->getBody()
			);
		}

		return ApiHelper::handleResponseWithDataType(
			'array<string,mixed>',
			$request,
			$response,
		);
	}

	/**
	 * Operation getEmployeeAsync
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeAsync($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		return $this->getEmployeeAsyncWithHttpInfo($fields, $id, $only_current, $accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeeAsyncWithHttpInfo
	 *
	 * Get Employee
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeeAsyncWithHttpInfo($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		$returnType = 'array<string,mixed>';
		$request = $this->getEmployeeRequest($fields, $id, $only_current, $accept_header_parameter, $contentType);

		return ApiHelper::sendRequestWithRetriesAsync($this->logger, $this->client, $this->config, $request, ApiHelper::createHttpClientOption($this->config))
			->then(
				function ($response) use ($returnType) {
					$content = (string) $response->getBody();
					if ($returnType !== 'string') {
						$content = json_decode($content);
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployee'
	 *
	 * @param  string $fields {fields} is a comma separated list of values taken from the official list of field names. (required)
	 * @param  string $id {id} is an employee ID. The special employee ID of zero (0) means to use the employee ID associated with the API key (if any). (required)
	 * @param  bool|null $only_current Setting to false will return future dated values from history table fields. (optional, default to false)
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeeRequest($fields, $id, $only_current = false, $accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployee'][0]) {
		// PHP 8.0+ only
		ApiHelper::validateRequiredParameters(
			params: [
				'fields' => $fields,
				'id' => $id,
			],
			methodName: 'getEmployee'
		);

		$resourcePath = '/api/v1/employees/{id}';
		$this->logger->info('Request method: [GET], URL: ' . $resourcePath);
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		$parameters = [
			'fields' => ['value' => $fields, 'type' => 'string', 'required' => true, 'style' => 'form', 'explode' => true],
			'onlyCurrent' => ['value' => $only_current, 'type' => 'boolean', 'required' => false, 'style' => 'form', 'explode' => true],
		];

		// Process parameters and build query values directly
		$queryParams = [];

		foreach ($parameters as $paramName => $config) {
			$value = ObjectSerializer::toQueryValue($config['value'], $paramName, $config['type'], $config['style'], $config['explode'], $config['required']);
			
			if ($value !== null) {
				// Merge each parameter value directly into queryParams
				$queryParams = array_merge($queryParams, $value);
			}
		}

		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue((string) $id),
				$resourcePath
			);
		}

		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$this->logger->info('Using Basic authentication');	
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$this->logger->info('Using Bearer authentication');
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$this->logger->debug('Using User-Agent: ' . $this->config->getUserAgent());	
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		/** @phpstan-ignore-next-line */
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$this->logger->debug('Overriding Accept header: ' . $accept_header_parameter);
			/** @phpstan-ignore-next-line */
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			is_string($httpBody) ? $httpBody : (string)$httpBody
		);
	}

	/**
	 * Operation getEmployeesDirectory
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetEmployeesDirectory200Response
	 */
	public function getEmployeesDirectory($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		list($response) = $this->getEmployeesDirectoryWithHttpInfo($accept_header_parameter, $contentType);
		return $response;
	}

	/**
	 * Operation getEmployeesDirectoryWithHttpInfo
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetEmployeesDirectory200Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeesDirectoryWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		$request = $this->getEmployeesDirectoryRequest($accept_header_parameter, $contentType);
		$options = ApiHelper::createHttpClientOption($this->config);
		
		// Send request with retry support for timeout errors
		$response = ApiHelper::sendRequestWithRetries($this->logger, $this->client, $this->config, $request, $options);

		$statusCode = $response->getStatusCode();

		switch($statusCode) {
			case 200:
				return ApiHelper::handleResponseWithDataType(
					'\BhrSdk\Model\GetEmployeesDirectory200Response',
					$request,
					$response,
				);
		}

		if ($statusCode < 200 || $statusCode > 299) {
			throw new ApiException(
				sprintf(
					'[%d] Error connecting to the API (%s)',
					$statusCode,
					(string) $request->getUri()
				),
				$statusCode,
				$response->getHeaders(),
				(string) $response->getBody()
			);
		}

		return ApiHelper::handleResponseWithDataType(
			'\BhrSdk\Model\GetEmployeesDirectory200Response',
			$request,
			$response,
		);
	}

	/**
	 * Operation getEmployeesDirectoryAsync
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeesDirectoryAsync($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		return $this->getEmployeesDirectoryAsyncWithHttpInfo($accept_header_parameter, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeesDirectoryAsyncWithHttpInfo
	 *
	 * Get Employee Directory
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeesDirectoryAsyncWithHttpInfo($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {
		$returnType = '\BhrSdk\Model\GetEmployeesDirectory200Response';
		$request = $this->getEmployeesDirectoryRequest($accept_header_parameter, $contentType);

		return ApiHelper::sendRequestWithRetriesAsync($this->logger, $this->client, $this->config, $request, ApiHelper::createHttpClientOption($this->config))
			->then(
				function ($response) use ($returnType) {
					$content = (string) $response->getBody();
					if ($returnType !== 'string') {
						$content = json_decode($content);
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployeesDirectory'
	 *
	 * @param  string|null $accept_header_parameter This endpoint can produce either JSON or XML. (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesDirectory'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeesDirectoryRequest($accept_header_parameter = null, string $contentType = self::CONTENT_TYPES['getEmployeesDirectory'][0]) {

		$resourcePath = '/api/v1/employees/directory';
		$this->logger->info('Request method: [GET], URL: ' . $resourcePath);
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// header params
		if ($accept_header_parameter !== null) {
			$headerParams['AcceptHeaderParameter'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$headers = $this->headerSelector->selectHeaders(
			['application/json', 'application/xml', ],
			$contentType,
			$multipart
		);

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$this->logger->info('Using Basic authentication');	
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$this->logger->info('Using Bearer authentication');
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$this->logger->debug('Using User-Agent: ' . $this->config->getUserAgent());	
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		/** @phpstan-ignore-next-line */
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$this->logger->debug('Overriding Accept header: ' . $accept_header_parameter);
			/** @phpstan-ignore-next-line */
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			is_string($httpBody) ? $httpBody : (string)$httpBody
		);
	}

	/**
	 * Operation getEmployeesList
	 *
	 * Get Employees
	 *
	 * @param  \BhrSdk\Model\GetEmployeesFilterRequestObject|null $filter Filters used to match employees. Encode filter properties using deepObject style. If the caller does not have access to the filtered field on a matching employee, that employee is excluded from the results to avoid leaking sensitive data. (optional)
	 * @param  string|null $sort Comma-separated list of sortable fields. Prefix a field with \&quot;-\&quot; for descending order. Allowed fields: &#x60;employeeId&#x60;, &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;preferredName&#x60;, &#x60;jobTitleName&#x60;, &#x60;status&#x60;. Nulls sort first in ascending order and last in descending order. If the caller does not have access to the sort field for an employee, that employee is excluded from the final result set to avoid leaking sensitive information. (optional)
	 * @param  \BhrSdk\Model\CursorPaginationQueryObject|null $page Cursor-based pagination parameters (&#x60;limit&#x60;, &#x60;after&#x60;, &#x60;before&#x60;). (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesList'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return \BhrSdk\Model\GetEmployeesResponseObject|\BhrSdk\Model\GetEmployeesList400Response
	 */
	public function getEmployeesList($filter = null, $sort = null, $page = null, string $contentType = self::CONTENT_TYPES['getEmployeesList'][0]) {
		list($response) = $this->getEmployeesListWithHttpInfo($filter, $sort, $page, $contentType);
		return $response;
	}

	/**
	 * Operation getEmployeesListWithHttpInfo
	 *
	 * Get Employees
	 *
	 * @param  \BhrSdk\Model\GetEmployeesFilterRequestObject|null $filter Filters used to match employees. Encode filter properties using deepObject style. If the caller does not have access to the filtered field on a matching employee, that employee is excluded from the results to avoid leaking sensitive data. (optional)
	 * @param  string|null $sort Comma-separated list of sortable fields. Prefix a field with \&quot;-\&quot; for descending order. Allowed fields: &#x60;employeeId&#x60;, &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;preferredName&#x60;, &#x60;jobTitleName&#x60;, &#x60;status&#x60;. Nulls sort first in ascending order and last in descending order. If the caller does not have access to the sort field for an employee, that employee is excluded from the final result set to avoid leaking sensitive information. (optional)
	 * @param  \BhrSdk\Model\CursorPaginationQueryObject|null $page Cursor-based pagination parameters (&#x60;limit&#x60;, &#x60;after&#x60;, &#x60;before&#x60;). (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesList'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of \BhrSdk\Model\GetEmployeesResponseObject|\BhrSdk\Model\GetEmployeesList400Response, HTTP status code, HTTP response headers (array of strings)
	 */
	public function getEmployeesListWithHttpInfo($filter = null, $sort = null, $page = null, string $contentType = self::CONTENT_TYPES['getEmployeesList'][0]) {
		$request = $this->getEmployeesListRequest($filter, $sort, $page, $contentType);
		$options = ApiHelper::createHttpClientOption($this->config);
		
		// Send request with retry support for timeout errors
		$response = ApiHelper::sendRequestWithRetries($this->logger, $this->client, $this->config, $request, $options);

		$statusCode = $response->getStatusCode();

		switch($statusCode) {
			case 200:
				return ApiHelper::handleResponseWithDataType(
					'\BhrSdk\Model\GetEmployeesResponseObject',
					$request,
					$response,
				);
			case 400:
				return ApiHelper::handleResponseWithDataType(
					'\BhrSdk\Model\GetEmployeesList400Response',
					$request,
					$response,
				);
		}

		if ($statusCode < 200 || $statusCode > 299) {
			throw new ApiException(
				sprintf(
					'[%d] Error connecting to the API (%s)',
					$statusCode,
					(string) $request->getUri()
				),
				$statusCode,
				$response->getHeaders(),
				(string) $response->getBody()
			);
		}

		return ApiHelper::handleResponseWithDataType(
			'\BhrSdk\Model\GetEmployeesResponseObject',
			$request,
			$response,
		);
	}

	/**
	 * Operation getEmployeesListAsync
	 *
	 * Get Employees
	 *
	 * @param  \BhrSdk\Model\GetEmployeesFilterRequestObject|null $filter Filters used to match employees. Encode filter properties using deepObject style. If the caller does not have access to the filtered field on a matching employee, that employee is excluded from the results to avoid leaking sensitive data. (optional)
	 * @param  string|null $sort Comma-separated list of sortable fields. Prefix a field with \&quot;-\&quot; for descending order. Allowed fields: &#x60;employeeId&#x60;, &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;preferredName&#x60;, &#x60;jobTitleName&#x60;, &#x60;status&#x60;. Nulls sort first in ascending order and last in descending order. If the caller does not have access to the sort field for an employee, that employee is excluded from the final result set to avoid leaking sensitive information. (optional)
	 * @param  \BhrSdk\Model\CursorPaginationQueryObject|null $page Cursor-based pagination parameters (&#x60;limit&#x60;, &#x60;after&#x60;, &#x60;before&#x60;). (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesList'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeesListAsync($filter = null, $sort = null, $page = null, string $contentType = self::CONTENT_TYPES['getEmployeesList'][0]) {
		return $this->getEmployeesListAsyncWithHttpInfo($filter, $sort, $page, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation getEmployeesListAsyncWithHttpInfo
	 *
	 * Get Employees
	 *
	 * @param  \BhrSdk\Model\GetEmployeesFilterRequestObject|null $filter Filters used to match employees. Encode filter properties using deepObject style. If the caller does not have access to the filtered field on a matching employee, that employee is excluded from the results to avoid leaking sensitive data. (optional)
	 * @param  string|null $sort Comma-separated list of sortable fields. Prefix a field with \&quot;-\&quot; for descending order. Allowed fields: &#x60;employeeId&#x60;, &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;preferredName&#x60;, &#x60;jobTitleName&#x60;, &#x60;status&#x60;. Nulls sort first in ascending order and last in descending order. If the caller does not have access to the sort field for an employee, that employee is excluded from the final result set to avoid leaking sensitive information. (optional)
	 * @param  \BhrSdk\Model\CursorPaginationQueryObject|null $page Cursor-based pagination parameters (&#x60;limit&#x60;, &#x60;after&#x60;, &#x60;before&#x60;). (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesList'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function getEmployeesListAsyncWithHttpInfo($filter = null, $sort = null, $page = null, string $contentType = self::CONTENT_TYPES['getEmployeesList'][0]) {
		$returnType = '\BhrSdk\Model\GetEmployeesResponseObject';
		$request = $this->getEmployeesListRequest($filter, $sort, $page, $contentType);

		return ApiHelper::sendRequestWithRetriesAsync($this->logger, $this->client, $this->config, $request, ApiHelper::createHttpClientOption($this->config))
			->then(
				function ($response) use ($returnType) {
					$content = (string) $response->getBody();
					if ($returnType !== 'string') {
						$content = json_decode($content);
					}

					return [
						ObjectSerializer::deserialize($content, $returnType, []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'getEmployeesList'
	 *
	 * @param  \BhrSdk\Model\GetEmployeesFilterRequestObject|null $filter Filters used to match employees. Encode filter properties using deepObject style. If the caller does not have access to the filtered field on a matching employee, that employee is excluded from the results to avoid leaking sensitive data. (optional)
	 * @param  string|null $sort Comma-separated list of sortable fields. Prefix a field with \&quot;-\&quot; for descending order. Allowed fields: &#x60;employeeId&#x60;, &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;preferredName&#x60;, &#x60;jobTitleName&#x60;, &#x60;status&#x60;. Nulls sort first in ascending order and last in descending order. If the caller does not have access to the sort field for an employee, that employee is excluded from the final result set to avoid leaking sensitive information. (optional)
	 * @param  \BhrSdk\Model\CursorPaginationQueryObject|null $page Cursor-based pagination parameters (&#x60;limit&#x60;, &#x60;after&#x60;, &#x60;before&#x60;). (optional)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['getEmployeesList'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function getEmployeesListRequest($filter = null, $sort = null, $page = null, string $contentType = self::CONTENT_TYPES['getEmployeesList'][0]) {

		$resourcePath = '/api/v1/employees';
		$this->logger->info('Request method: [GET], URL: ' . $resourcePath);
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		$parameters = [
			'filter' => ['value' => $filter, 'type' => 'object', 'required' => false, 'style' => 'deepObject', 'explode' => true],
			'sort' => ['value' => $sort, 'type' => 'string', 'required' => false, 'style' => 'form', 'explode' => true],
			'page' => ['value' => $page, 'type' => 'object', 'required' => false, 'style' => 'deepObject', 'explode' => true],
		];

		// Process parameters and build query values directly
		$queryParams = [];

		foreach ($parameters as $paramName => $config) {
			$value = ObjectSerializer::toQueryValue($config['value'], $paramName, $config['type'], $config['style'], $config['explode'], $config['required']);
			
			if ($value !== null) {
				// Merge each parameter value directly into queryParams
				$queryParams = array_merge($queryParams, $value);
			}
		}

		$headers = $this->headerSelector->selectHeaders(
			['application/json', ],
			$contentType,
			$multipart
		);

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$this->logger->info('Using Basic authentication');	
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$this->logger->info('Using Bearer authentication');
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$this->logger->debug('Using User-Agent: ' . $this->config->getUserAgent());	
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		/** @phpstan-ignore-next-line */
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$this->logger->debug('Overriding Accept header: ' . $accept_header_parameter);
			/** @phpstan-ignore-next-line */
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'GET',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			is_string($httpBody) ? $httpBody : (string)$httpBody
		);
	}

	/**
	 * Operation updateEmployee
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return void
	 */
	public function updateEmployee($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		$this->updateEmployeeWithHttpInfo($id, $employee, $contentType);
	}

	/**
	 * Operation updateEmployeeWithHttpInfo
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \BhrSdk\ApiException on non-2xx response or if the response body is not in the expected format
	 * @throws \InvalidArgumentException
	 * @return array of null, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateEmployeeWithHttpInfo($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		$request = $this->updateEmployeeRequest($id, $employee, $contentType);
		$options = ApiHelper::createHttpClientOption($this->config);
		
		// Send request with retry support for timeout errors
		$response = ApiHelper::sendRequestWithRetries($this->logger, $this->client, $this->config, $request, $options);

		$statusCode = $response->getStatusCode();

		return ApiHelper::handleResponseWithDataType(
			'object', // or 'mixed' or any other generic type
			$request,
			$response,
		);
	}

	/**
	 * Operation updateEmployeeAsync
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeAsync($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		return $this->updateEmployeeAsyncWithHttpInfo($id, $employee, $contentType)
			->then(
				function ($response) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateEmployeeAsyncWithHttpInfo
	 *
	 * Update Employee
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateEmployeeAsyncWithHttpInfo($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		
		$request = $this->updateEmployeeRequest($id, $employee, $contentType);

		return ApiHelper::sendRequestWithRetriesAsync($this->logger, $this->client, $this->config, $request, ApiHelper::createHttpClientOption($this->config))
			->then(
				function ($response) {
					$content = (string) $response->getBody();
					$content = json_decode($content);

					return [
						ObjectSerializer::deserialize($content, 'object', []),
						$response->getStatusCode(),
						$response->getHeaders()
					];
				},
				function ($exception) {
					$response = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						(string) $response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateEmployee'
	 *
	 * @param  string $id {id} is an employee ID. (required)
	 * @param  \BhrSdk\Model\Employee $employee (required)
	 * @param  string $contentType The value for the Content-Type header. Check self::CONTENT_TYPES['updateEmployee'] to see the possible values for this operation
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	public function updateEmployeeRequest($id, $employee, string $contentType = self::CONTENT_TYPES['updateEmployee'][0]) {
		// PHP 8.0+ only
		ApiHelper::validateRequiredParameters(
			params: [
				'id' => $id,
				'employee' => $employee,
			],
			methodName: 'updateEmployee'
		);

		$resourcePath = '/api/v1/employees/{id}';
		$this->logger->info('Request method: [POST], URL: ' . $resourcePath);
		
		$queryParams = [];
		$headerParams = [];
		$httpBody = '';
		$multipart = false;

		// path params
		if ($id !== null) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue((string) $id),
				$resourcePath
			);
		}

		$headers = $this->headerSelector->selectHeaders(
			['application/xml', 'application/json', ],
			$contentType,
			$multipart
		);

		// for model (json/xml)
		if (isset($employee)) {
			if (stripos($headers['Content-Type'], 'application/json') !== false) {
				# if Content-Type contains "application/json", json_encode the body
				$httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($employee));
			} else {
				$httpBody = is_array($employee) ? json_encode($employee) : $employee;
			}
		} 

		// Authentication methods
		
		// Basic authentication
		if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
			$this->logger->info('Using Basic authentication');	
			$headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
		}
		
		// OAuth/Bearer authentication
		if (!empty($this->config->getAccessToken())) {
			$this->logger->info('Using Bearer authentication');
			$headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
		}

		$defaultHeaders = [];
		if ($this->config->getUserAgent()) {
			$this->logger->debug('Using User-Agent: ' . $this->config->getUserAgent());	
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);
		
		// Special handling for accept_header_parameter to set the Accept header directly
		/** @phpstan-ignore-next-line */
		if (isset($accept_header_parameter) && $accept_header_parameter !== null) {
			$this->logger->debug('Overriding Accept header: ' . $accept_header_parameter);
			/** @phpstan-ignore-next-line */
			$headers['Accept'] = ObjectSerializer::toHeaderValue($accept_header_parameter);
		}

		$operationHost = $this->config->getHost();
		$query = ObjectSerializer::buildQuery($queryParams);
		return new Request(
			'POST',
			$operationHost . $resourcePath . ($query ? "?{$query}" : ''),
			$headers,
			is_string($httpBody) ? $httpBody : (string)$httpBody
		);
	}

}
